<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></head><body><p name="2699" id="2699" class="graf graf--p graf-after--p">This stuff matters [<a href="https://youtu.be/xXXiC4YRGrQ?t=41m41s" data-href="https://youtu.be/xXXiC4YRGrQ?t=41m41s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">41:41</a>]. It matters in ways more than just awkward translations or black people’s photos not being classified correctly. Maybe there’s some wins too as well — like horrifying surveillance everywhere and maybe won’t work on black people. “Or it’ll be even worse because it’s horrifying surveillance and it’s flat-out racist and wrong” (Rachel). But let’s go deeper. For all we say about human failings, there is a long history of civilization and societies creating layers of human judgement which avoid, hopefully, the most horrible things happening. And sometimes companies which love technology think “let’s throw away humans and replace them with technology” like Facebook did. A couple years ago, Facebook literally got rid of their human editors, and this was in the news at the time. And they were replaced with algorithms. So now as algorithms put all the stuff on your news feed and human editors were out of the loop. What happened next?</p><figure name="90db" id="90db" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_VkIbRF2g5fsRvgfopPRDZQ.png"></figure><p name="00b5" id="00b5" class="graf graf--p graf-after--figure">Many things happened next. One of which was a massive horrifying genocide in Myanmar. Babies getting torn out of their mothers arms and thrown into fires. Mass rape, murder, and an entire people exiled from their homeland.</p><figure name="e7d8" id="e7d8" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_6-Uu8ezBnUol5cYw4Q11lA.png"></figure><p name="1abd" id="1abd" class="graf graf--p graf-after--figure">Okay, I’m not gonna say that was because Facebook did this, but what I will say is that when the leaders of this horrifying project are interviewed, they regularly talk about how everything they learnt about the disgusting animal behaviors of Rohingyas that need to be thrown off the earth, they learnt from Facebook. Because the algorithms just want to feed you more stuff that gets you clicking. If you get told these people that don’t look like you and you don’t know the bad people and here’s lots of stories about bad people and then you start clicking on them and then they feed you more of those things. Next thing you know, you have this extraordinary cycle. People have been studying this, so for example, we’ve been told a few times people click on our fast.ai videos and then the next thing recommended to them is like conspiracy theory videos from Alex Jones, and then continues from there. Because humans click on things that shock us, surprise us, and horrify us. At so many levels, this decision has had extraordinary consequences which we’re only beginning to understand. Again, this is not to say this particular consequence is because of this one thing, but to say it’s entirely unrelated would be clearly ignoring all of the evidence and information that we have.</p><h4 name="c15c" id="c15c" class="graf graf--h4 graf-after--p">Unintended consequences [<a href="https://youtu.be/xXXiC4YRGrQ?t=45m4s" data-href="https://youtu.be/xXXiC4YRGrQ?t=45m4s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">45:04</a>]</h4><figure name="fe24" id="fe24" class="graf graf--figure graf-after--h4"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_8stxAKlNajQqn4Q6mt9HpQ.png"></figure><p name="b958" id="b958" class="graf graf--p graf-after--figure">The key takeaway is to think what are you building and how could it be used. Lots and lots of effort now being put into face detection including in our course. We’ve been spending a lot of time thinking about how to recognize stuff and where it is. There’s lots of good reasons to want to be good at that for improving crop yields in agriculture, for improving diagnostic and treatment planning in medicine, for improving your LEGO sorting robot system, etc. But it’s also being widely used in surveillance, propaganda, and disinformation. Again, the question is what do I do about that? I don’t exactly know. But it’s definitely at least important to be thinking about it, talking about it.</p><h4 name="c669" id="c669" class="graf graf--h4 graf-after--p">Runaway feedback loops&nbsp;[<a href="https://youtu.be/xXXiC4YRGrQ?t=46m10s" data-href="https://youtu.be/xXXiC4YRGrQ?t=46m10s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">46:10</a>]</h4><figure name="9306" id="9306" class="graf graf--figure graf-after--h4"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_MQa0eNjEl__LOn8pc0YmDw.png"></figure><p name="d7d6" id="d7d6" class="graf graf--p graf-after--figure">Sometimes you can do really good things. For example, meetup.com did something which I would put in the category of really good thing which is they recognized early a potential problem which is that more men are tending to go to their meet ups. And that was causing their collaborative filtering systems, which you are familiar building now to recommend more technical content to men. And that was causing more men to go to more technical content which was causing the recommendation system to suggest more technical content to men. This kind of runaway feedback loop is extremely common when we interface the algorithm and the human together. So what did Meetup do? They intentionally made the decision to recommend more technical content to women, not because highfalutin idea about how the world should be, but just because that makes sense. Runaway feedback loop was a bug — there are women that want to go to tech meetups, but when you turn up for a tech meet up and it’s all men and you don’t go, then it recommends more to men and so on and so forth. So Meetup made a really strong product management decision here which was to not do what the algorithm said to do. Unfortunately this is rare. Most of these runaway feedback loops, for example, in predictive policing where algorithms tell policemen where to go which very often is more black neighborhoods which end up crawling with more policemen which leads to more arrests which is assisting to tell more policemen to go to more black neighborhoods and so forth.</p><h4 name="62ad" id="62ad" class="graf graf--h4 graf-after--p">Bias in AI&nbsp;[<a href="https://youtu.be/xXXiC4YRGrQ?t=48m9s" data-href="https://youtu.be/xXXiC4YRGrQ?t=48m9s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">48:09</a>]</h4><figure name="b15b" id="b15b" class="graf graf--figure graf-after--h4"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_Bd_fR4tfFYj5fBQYgum35A.png"></figure><p name="7617" id="7617" class="graf graf--p graf-after--figure">This problem of algorithmic bias is now very wide spread and as algorithms become more and more widely used for specific policy decisions, judicial decisions, day-to-day decisions about who to give what offer to, this just keeps becoming a bigger problem. Some of them are really things that the people involved in the product management decision should have seen at the very start, didn’t make sense, and unreasonable under any definition of the term. For example, this stuff Abe Gong pointed out — these were questions that were used for both pretrial so who was required to post bail, so these are people that haven’t even been convicted, as well as for sentencing and for who gets parole. This was upheld by the Wisconsin Supreme Court last year despite all the flaws. So whether you have to stay in jail because you can’t pay the bail and how long your sentence is for, and how long you stay in jail for depends on what your father did, whether your parents stayed married, who your friends are, and where you live. Now turns out these algorithms are actually terribly terribly bad so some recent analysis showed that they are basically worse than chance. But even if the company’s building them were confident on these were statistically accurate correlations, does anybody imagine there’s a world where it makes sense to decide what happens to you based on what your dad did?</p><p name="3c69" id="3c69" class="graf graf--p graf-after--p">A lot of this stuff at the basic level is obviously unreasonable and a lot of it just fails in these ways that you can see empirically that these kind of runaway feedback loops must have happened and these over generalizations must have happened. For example, these are the cross tabs that anybody working in any field using these algorithm should be preparing. So prediction of likelihood of reoffending for black vs. white defendants, we can just calculate this very simply. Of the people that were labeled high-risk but didn’t reoffend — they were 23.5% white but about twice that African American. Where else, those that were labeled lower risk but did reoffend was half the white people and only 28% of the African American. This is the kind of stuff where at least if you are taking the technologies we’ve been talking about and putting the production in any way, building an API for other people, providing training for people, or whatever — then at least make sure that what you are doing can be tracked in a way that people know what’s going on so at least they are informed. I think it’s a mistake in my opinion to assume that people are evil and trying to break society. I think I would prefer to start with an assumption of if people are doing dumb stuff, it’s because they don’t know better. So at least make sure they have this information. I find very few ML practitioners thinking about what is the information they should be presenting in their interface. Then often I’ll talk to data scientists who will say “oh, the stuff I’m working on doesn’t have a societal impact.” Really? A number of people who think that what they are doing is entirely pointless? Come on. People are paying you to do it for a reason. It’s going to impact people in some way. So think about what that is.</p><h4 name="86d1" id="86d1" class="graf graf--h4 graf-after--p">Responsibility in hiring&nbsp;[<a href="https://youtu.be/xXXiC4YRGrQ?t=52m46s" data-href="https://youtu.be/xXXiC4YRGrQ?t=52m46s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">52:46</a>]</h4><figure name="45dd" id="45dd" class="graf graf--figure graf-after--h4"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_7V8grUptQO556VPQ4Dw8Sw.png"></figure><p name="28d8" id="28d8" class="graf graf--p graf-after--figure">The other thing I know is a lot of people involved here are hiring people and if you are hiring people, I guess you are all very familiar with the fast.ai philosophy now which is the basic premise that, and I thin it comes back to this idea that I don’t think people on the whole are evil, I think they need to be informed and have tools. So we are trying to give as many people the tools as possible that they need and particularly we are trying to put those tools in the hands of a more diverse range of people. So if you are involved in hiring decisions, perhaps you can keep this kind of philosophy in mind as well. If you are not just hiring a wider range of people, but also promoting a wider range of people, and providing appropriate career management for a wider range of people, apart from anything else, your company will do better. It actually turns out that more diverse teams are more creative and tend to solve problems more quickly and better than less diverse teams, but also you might avoid these kind of awful screw-ups which, at one level, are bad for the world and another level if you ever get found out, they can destroy your company.</p><h4 name="d834" id="d834" class="graf graf--h4 graf-after--p">IBM &amp; “Death’s Calculator” [<a href="https://youtu.be/xXXiC4YRGrQ?t=54m8s" data-href="https://youtu.be/xXXiC4YRGrQ?t=54m8s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">54:08</a>]</h4><figure name="aa4f" id="aa4f" class="graf graf--figure graf-after--h4"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_sOrJFBPiJYdUsxzythGk8w.png"></figure><p name="4c4c" id="4c4c" class="graf graf--p graf-after--figure">Also they can destroy you or at least make you look pretty bad in history. A couple of examples, one is going right back to the second world war. IBM provided all of the infrastructure necessary to track the Holocaust. These are the forms they used and they had different code — Jews were 8, Gypsies were 12, death in the gas chambers was 6, and they all went on these punch cards. You can go and look at these punch cards in museums now and this has actually been reviewed by a Swiss judge who said that IBM’s technical assistance facilitated the task of the Nazis and the commission their crimes against humanity. It is interesting to read back the history from these times to see what was going through the minds of people at IBM at that time. What was clearly going through the minds was the opportunity to show technical superiority, the opportunity to test out their new systems, and of course the extraordinary amount of money that they were making. When you do something which at some point down the line turns out to be a problem, even if you were told to do it, that can turn out to be a problem for you personally. For example, you all remember the diesel emission scandal in VW. Who is the one guy that went to jail? It was the engineer just doing his job. If all of this stuff about actually not messing up the world isn’t enough to convince you, it can mess up your life too. If you do something that turns out to cause problems even though somebody told you to do it, you can absolutely be held criminally responsible. Aleksandr Kogan was the guy that handed over the Cambridge Analytica data. He is a Cambridge academic. Now a very famous Cambridge academic the world over for doing his part to destroy the foundations of democracy. This is not how we want to go down in history.</p><figure name="1621" id="1621" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_qXLN21dyZdaaYfxXuCTWhg.png"></figure><p name="80ea" id="80ea" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Question:</strong> In one of your tweets, you said dropout is patented [<a href="https://youtu.be/xXXiC4YRGrQ?t=56m50s" data-href="https://youtu.be/xXXiC4YRGrQ?t=56m50s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">56:50</a>]. I think this is about WaveNet patent from Google. What does it mean? Can you please share more insight on this subject? Does it mean that we will have to pay to use dropout in the future? One of the patent holders is Geoffrey Hinton. So what? Isn’t that great? Invention is all about patents, blah blah. My answer is no. Patents have gone wildly crazy. The amount of things that are patentable that we talk about every week would be dozens. It’s so easy to come up with a little tweak and then if you turn that into a patent to stop everybody from using that little tweak for the next 14 years and you end up with a situation we have now where everything is patented in 50 different ways. Then you get these patent trolls who have made a very good business out of buying lots of crappy little patents and then suing anybody who accidentally turned out did that thing like putting rounded corners on buttons. So what does it mean for us that a lot of stuff is patented in deep learning? I don’t know.</p><p name="8891" id="8891" class="graf graf--p graf-after--p">One of the main people doing this is Google and people from Google who replied to this patent tend to assume that Google doing it because they want to have it defensively so if somebody sues them, they can say don’t sue us we’ll sue you back because we have all these patents. The problem is that as far as I know, they haven’t signed what’s called a defensive patent pledge so basically you can sign a legally binding document that says our patent portfolio will only be used in defense and not offense. Even if you believe all the management of Google would never turn into a patent troll, you’ve got to remember that management changes. To give you a specific example I know, the somewhat recent CFO of Google has a much more aggressive stance towards the PNL, I don’t know, maybe she might decide that they should start monetizing their patents or maybe the group that made that patent might get spun off and then sold to another company that might end up in private equity hands and decide to monetize the patents or whatever. So I think it’s a problem. There has been a big shift legally recently away from software patents actually having any legal standing, so it’s possible that these will all end up thrown out of court but the reality is that anything but a big company is unlikely to have the financial ability to defend themselves against one of these huge patent trolls.</p><p name="6e75" id="6e75" class="graf graf--p graf-after--p">You can’t avoid using patented stuff if you write code. I wouldn’t be surprised if most lines of code you write have patents on them. Actually funnily enough, the best thing to do is not to study the patents because if you do and you infringe knowingly then the penalties are worse. So the best thing to do is to put your hands in your ear, sing a song, and get back to work. So the thing about dropouts patented, forget I said that. You don’t know that. You skipped that bit.</p><h3 name="5e3d" id="5e3d" class="graf graf--h3 graf-after--p">Style Transfer [<a href="https://youtu.be/xXXiC4YRGrQ?t=1h1m28s" data-href="https://youtu.be/xXXiC4YRGrQ?t=1h1m28s" class="markup--anchor markup--h3-anchor" rel="nofollow noopener" target="_blank">1:01:28</a>]</h3><p name="4f6c" id="4f6c" class="graf graf--p graf-after--h3"><a href="https://github.com/fastai/fastai/blob/master/courses/dl2/style-transfer.ipynb" data-href="https://github.com/fastai/fastai/blob/master/courses/dl2/style-transfer.ipynb" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Notebook</a></p><figure name="1bf8" id="1bf8" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_GPdF7Xu7mAiUAYEDbT-SHA.png"><figcaption class="imageCaption"><a href="https://arxiv.org/abs/1508.06576" data-href="https://arxiv.org/abs/1508.06576" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://arxiv.org/abs/1508.06576</a></figcaption></figure><p name="1fb9" id="1fb9" class="graf graf--p graf-after--figure">This is super fun — artistic style. We are going a bit retro here because this is actually the original artistic style paper and there’s been a lot of updates to it and a lot of different approaches and I actually think in many ways the original is the best. We are going to look at some of the newer approaches as well, but I actually think the original is a terrific way to do it even with everything that’s gone since. Let’s jump to the code.</p><pre name="3013" id="3013" class="graf graf--pre graf-after--p">%matplotlib inline<br>%reload_ext autoreload<br>%autoreload 2</pre><pre name="a0c0" id="a0c0" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">from</strong> <strong class="markup--strong markup--pre-strong">fastai.conv_learner</strong> <strong class="markup--strong markup--pre-strong">import</strong> *<br><strong class="markup--strong markup--pre-strong">from</strong> <strong class="markup--strong markup--pre-strong">pathlib</strong> <strong class="markup--strong markup--pre-strong">import</strong> Path<br><strong class="markup--strong markup--pre-strong">from</strong> <strong class="markup--strong markup--pre-strong">scipy</strong> <strong class="markup--strong markup--pre-strong">import</strong> ndimage<br>torch.cuda.set_device(3)<br><br>torch.backends.cudnn.benchmark=<strong class="markup--strong markup--pre-strong">True</strong></pre><pre name="0911" id="0911" class="graf graf--pre graf-after--pre">PATH = Path('data/imagenet')<br>PATH_TRN = PATH/'train'</pre><pre name="69b2" id="69b2" class="graf graf--pre graf-after--pre">m_vgg = to_gpu(vgg16(<strong class="markup--strong markup--pre-strong">True</strong>)).eval()<br>set_trainable(m_vgg, <strong class="markup--strong markup--pre-strong">False</strong>)</pre><p name="0740" id="0740" class="graf graf--p graf-after--pre">The idea here is that we want to take a photo of a bird, and we want to create a painting that looks like Van Gogh painted the picture of the bird. Quite a bit of the stuff that I’m doing, by the way, uses an ImageNet. You don’t have to download the whole of ImageNet for any of the things I’m doing. There is an ImageNet sample in <a href="http://files.fast.ai/data/" data-href="http://files.fast.ai/data/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">files.fast.ai/data</a> which has a couple of gig which should be plenty good enough for everything we are doing. If you want to get really great result, you can grab ImageNet. You can download it from <a href="https://www.kaggle.com/c/imagenet-object-localization-challenge/data" data-href="https://www.kaggle.com/c/imagenet-object-localization-challenge/data" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Kaggle</a>. The localization competition actually contains all of the classification data as well. If you’ve got room, it’s good to have a copy of ImageNet because it comes in handy all the time.</p><pre name="ad91" id="ad91" class="graf graf--pre graf-after--p">img_fn = PATH_TRN/'n01558993'/'n01558993_9684.JPEG'<br>img = open_image(img_fn)<br>plt.imshow(img);</pre><p name="3cf8" id="3cf8" class="graf graf--p graf-after--pre">So I just grabbed the bird out of my ImageNet folder and there is my bird:</p><figure name="6a00" id="6a00" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_eZb9GpF1VGMMIukO2AE91w.png"></figure><pre name="141b" id="141b" class="graf graf--pre graf-after--figure">sz=288</pre><pre name="d73f" id="d73f" class="graf graf--pre graf-after--pre">trn_tfms,val_tfms = tfms_from_model(vgg16, sz)<br>img_tfm = val_tfms(img)<br>img_tfm.shape</pre><pre name="d3d4" id="d3d4" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">(3, 288, 288)</em></pre><pre name="e3cd" id="e3cd" class="graf graf--pre graf-after--pre">opt_img = np.random.uniform(0, 1, size=img.shape).astype(np.float32)<br>plt.imshow(opt_img);</pre><p name="6185" id="6185" class="graf graf--p graf-after--pre">What I’m going to do is I’m going to start with this picture:</p><figure name="4182" id="4182" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_jJzsPvZ9uHAtHqu9mZ_skA.png"></figure><p name="49b8" id="49b8" class="graf graf--p graf-after--figure">And I’m going to try to make it more and more like a picture of the bird painted by Van Gogh. The way I do that is actually very simple. You’re all familiar with it [<a href="https://youtu.be/xXXiC4YRGrQ?t=1h3m44s" data-href="https://youtu.be/xXXiC4YRGrQ?t=1h3m44s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:03:44</a>]. We will create a loss function which we will call <em class="markup--em markup--p-em">f</em>. The loss function is going to take as input a picture and spit out as output a value. The value will be lower if the image looks more like the bird photo painted by Van Gogh. Having written that loss function, we will then use the PyTorch gradient and optimizers. Gradient times the learning rate, and and we are not going to update any weights, we are going to update the pixels of the input image to make it a little bit more like a picture which would be a bird painted by Van Gogh. And we will stick it through the loss function again to get more gradients, and do it again and again. That’s it. So it’s identical to how we solve every problem. You know I’m a one-trick pony, right? This is my only trick. Create a loss function, use it to get some gradients, multiply it by learning rates to update something, always before, we’ve updated weights in a model but today, we are not going to do that. They’re going to update the pixels in the input. But it’s no different at all. We are just taking the gradient with respect to the input rather than respect to the weights. That’s it. So we are nearly done.</p><figure name="03bf" id="03bf" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_6sYVxXfPJU86MMBBKib7Rw.png"></figure><p name="2104" id="2104" class="graf graf--p graf-after--figure">Let’s do a couple more things [<a href="https://youtu.be/xXXiC4YRGrQ?t=1h5m49s" data-href="https://youtu.be/xXXiC4YRGrQ?t=1h5m49s" class="markup--anchor markup--p-anchor" rel="noopener nofollow" target="_blank">1:05:49</a>]. Let’s mention here that there’s going to be two more inputs to our loss function One is the picture of the bird. The second is an artwork by Van Gogh. By having those as inputs as well, that means we’ll be able to rerun the function later to make it look like a bird painted by Monet or a jumbo jet painted by Van Gogh, etc. Those are going to be the three inputs. Initially, as we discussed, our input here is some random noise. We start with some random noise, use the loss function, get the gradients, make it a little bit more like a bird painted by Van Gogh, and so forth.</p><p name="b297" id="b297" class="graf graf--p graf-after--p">So the only outstanding question which I guess we can talk about briefly is how we calculate how much our image looks like this bird painted by Van Gogh [<a href="https://youtu.be/xXXiC4YRGrQ?t=1h7m9s" data-href="https://youtu.be/xXXiC4YRGrQ?t=1h7m9s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:07:09</a>]. Let’s split it into two parts:</p><p name="4f27" id="4f27" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Content Loss</strong>: Returns a value that’s lower if it looks more like the bird (not just any bird, the specific bird that we have coming in).</p><p name="8dca" id="8dca" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Style Loss</strong>: Returns a lower number if the image is more like V.G.’s style</p><figure name="95b3" id="95b3" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_MetpfEESntmYRQ5Z6e5rQw.png"></figure><p name="20b1" id="20b1" class="graf graf--p graf-after--figure">There is one way to do the content loss which is very simple — we could look at the pixel of the output, compare them to the pixel of the bird, and do a mean squared error, and add them up. So if we did that, I ran this for a while. Eventually our image would turn into an image of the bird. You should try it. You should try this as an exercise. Try to use the optimizer in PyTorch to start with a random image and turn it into another image by using mean squared error pixel loss. Not terribly exciting but that would be step one.</p><p name="9cc2" id="9cc2" class="graf graf--p graf-after--p">The problem is, even if we already had our style loss function working beautifully and then presumably, what we are going to do is we are going to add these two together, and then one of them, we’ll multiply by some lambda to adjust how much style versus how much content. Assuming we had a style loss and we picked some sensible lambda, if we used pixel wise content loss then anything that makes it look more like Van Gogh and less like the exact photo, the exact background, the exact contrast, lighting, everything will increase the content loss — which is not what we want. We want it to look like the bird but not in the same way. It is still going to have the same two eyes in the same place and be the same kind of shape and so forth, but not the same representation. So what we are going to do is, this is going to shock you, we are going to use a neural network! We are going to use the VGG neural network because that’s what I used last year and I didn’t have time to see if other things worked so you can try that yourself during the week.</p><p name="673f" id="673f" class="graf graf--p graf-after--p">The VGG network is something which takes in an input and sticks it through a number of layers, and I’m going to treat these as just the convolutional layers there’s obviously ReLU there and if it’s a VGG with batch norm, which most are today, then it’s also got batch norm. There’s some max pooling and so forth but that’s fine. What we could do is, we could take one of these convolutional activations and then rather than comparing the pixels of this bird, we could instead compare the VGG layer 5 activations of this (bird painted by V.G.) to the VGG layer 5 activations of our original bird (or layer 6, or layer 7, etc). So why might that be more interesting? Well for one thing, it wouldn’t be the same bird. It wouldn’t be exactly the same because we are not checking the pixels. We are checking some later set of activations. So what are those later sets of activations contain? Assuming it’s after some max pooling, they contain a smaller grid — so it’s less specific about where things are. And rather than containing pixel color values, they are more like semantic things like is this kind of an eyeball, is this kind of furry, is this kind of bright, or is this kind of reflective, or laying flat, or whatever. So we would hope that there’s some level of semantic features through those layers where if we get a picture that matches those activations, then any picture that matches those activations looks like the bird but it’s not the same representation of the bird. So that’s what we are going to do. That’s what our content loss is going to be. People generally call this a <strong class="markup--strong markup--p-strong">perceptual loss</strong> because it’s really important in deep learning that you always create a new name for every obvious thing you do. If you compare two activations together, you are doing a perceptual loss. That’s it. Our content loss is going to be a perceptual loss. Then we will do the style loss later.</p><p name="aa9a" id="aa9a" class="graf graf--p graf-after--p">Let’s start by trying to create a bird that initially is random noise and we are going to use perceptual loss to create something that is bird-like but it’s not the particular bird [<a href="https://youtu.be/xXXiC4YRGrQ?t=1h13m13s" data-href="https://youtu.be/xXXiC4YRGrQ?t=1h13m13s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:13:13</a>]. We are going to start with 288 by 288. Because we are going to do one bird, there is going to be no GPU memory problems. I was actually disappointed that I realized that I picked a rather small input image. It would be fun to try this with something much bigger to create a really grand scale piece. The other thing to remember is if you are productionizing this, you could do a whole batch at a time. People sometimes complain about this approach (Gatys is the lead author) the Gatys’ style transfer approaches being slow, and I don’t agree it’s slow. It takes a few seconds and you can do a whole batch in a few seconds.</p><figure name="f635" id="f635" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_eZb9GpF1VGMMIukO2AE91w.png"></figure><pre name="5017" id="5017" class="graf graf--pre graf-after--figure">sz=288</pre><p name="03c0" id="03c0" class="graf graf--p graf-after--pre">So we are going to stick it through some transforms for VGG16 model as per usual [<a href="https://youtu.be/xXXiC4YRGrQ?t=1h14m12s" data-href="https://youtu.be/xXXiC4YRGrQ?t=1h14m12s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:14:12</a>]. Remember, the transform class has dunder call method (<code class="markup--code markup--p-code">__call__</code>) so we can treat it as if it’s a function. If you pass an image into that, then we get the transformed image. Try not to treat the fast.ai and PyTorch infrastructure as a black box because it’s all designed to be really easy to use in a decoupled way. So this idea of that transforms are just “callables” (i.e. things that you can do with parentheses) comes from PyTorch and we totally plagiarized the idea. So with torch.vision or with fast.ai, your transforms are just callables. And the whole pipelines of transforms is just a callable.</p><pre name="7e9c" id="7e9c" class="graf graf--pre graf-after--p">trn_tfms,val_tfms = tfms_from_model(vgg16, sz)<br>img_tfm = val_tfms(img)<br>img_tfm.shape</pre><pre name="df6d" id="df6d" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">(3, 288, 288)</em></pre><p name="d8c1" id="d8c1" class="graf graf--p graf-after--pre">Now we have something of 3 by 288 by 288 because PyTorch likes the channel to be first [<a href="https://youtu.be/xXXiC4YRGrQ?t=1h15m5s" data-href="https://youtu.be/xXXiC4YRGrQ?t=1h15m5s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:15:05</a>]. As you can see, it’s been turned into a square for us, it’s been normalized to (0, 1), all that normal stuff.</p><p name="a691" id="a691" class="graf graf--p graf-after--p">Now we are creating a random image.</p><pre name="3a8a" id="3a8a" class="graf graf--pre graf-after--p">opt_img = np.random.uniform(0, 1, size=img.shape).astype(np.float32)<br>plt.imshow(opt_img);</pre><figure name="c7c4" id="c7c4" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_jJzsPvZ9uHAtHqu9mZ_skA.png"></figure><p name="acda" id="acda" class="graf graf--p graf-after--figure">Here is something I discovered. Trying to turn this into a picture of anything is actually really hard. I found it very difficult to actually get an optimizer to get reasonable gradients that went anywhere. And just as I thought I was going to run out of time for this class and really embarrass myself, I realized the key issue is that pictures don’t look like this. They have more smoothness, so I turned this into the following by blurring it a little bit:</p><pre name="bb0c" id="bb0c" class="graf graf--pre graf-after--p">opt_img = scipy.ndimage.filters.median_filter(opt_img, [8,8,1])<br>plt.imshow(opt_img);</pre><figure name="dbf0" id="dbf0" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_84Vk7fPct3lIUwXWFZhWRQ.png"></figure><p name="e63a" id="e63a" class="graf graf--p graf-after--figure">I used a median filter — basically it is like a median pooling, effectively. As soon as I change it to this, it immediately started training really well. A number of little tweaks you have to do to get these things to work is kind of insane, but here is a little tweak.</p><p name="cc96" id="cc96" class="graf graf--p graf-after--p">So we start with a random image which is at least somewhat smooth [<a href="https://youtu.be/xXXiC4YRGrQ?t=1h16m21s" data-href="https://youtu.be/xXXiC4YRGrQ?t=1h16m21s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:16:21</a>]. I found that my bird image had a mean of pixels that was about half of this, so I divided it by 2 just trying to make it a little bit easier for it to match (I don’t know if it matters). Turn that into a variable because this image, remember, we are going to be modifying those pixels with an optimization algorithm, so anything that’s involved in the loss function needs to be a variable. And specifically, it requires a gradient because we are actually updating the image.</p><pre name="e9eb" id="e9eb" class="graf graf--pre graf-after--p">opt_img = val_tfms(opt_img)/2<br>opt_img_v = V(opt_img[<strong class="markup--strong markup--pre-strong">None</strong>], requires_grad=<strong class="markup--strong markup--pre-strong">True</strong>)<br>opt_img_v.shape</pre><pre name="7ab1" id="7ab1" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">torch.Size([1, 3, 288, 288])</em></pre><p name="ec11" id="ec11" class="graf graf--p graf-after--pre">So we now have a mini batch of 1, 3 channels, 288 by 288 random noise.</p><pre name="c255" id="c255" class="graf graf--pre graf-after--p">m_vgg = nn.Sequential(*children(m_vgg)[:37])</pre><p name="94cc" id="94cc" class="graf graf--p graf-after--pre">We are going to use, for no particular reason, the 37th layer of VGG. If you print out the VGG network (you can just type in <code class="markup--code markup--p-code">m_vgg</code> and prints it out), you’ll see that this is mid to late stage layer. So we can just grab the first 37 layers and turn it into a sequential model. So now we have a subset of VGG that will spit out some mid layer activations, and that’s what the model is going to be. So we can take our actual bird image and we want to create a mini batch of one. Remember, if you slice in Numpy with <code class="markup--code markup--p-code">None</code>, also known as <code class="markup--code markup--p-code">np.newaxis</code>, it introduces a new unit axis in that point. Here, I want to create an axis of size 1 to say this is a mini batch of size one. So slicing with None just like I did here (<code class="markup--code markup--p-code u-paddingRight0 u-marginRight0">opt_img_v = V(opt_img[<strong class="markup--strong markup--p-strong">None</strong>], requires_grad=<strong class="markup--strong markup--p-strong">True</strong>)</code>) to get one unit axis at the front. Then we turn that into a variable and this one doesn’t need to be updated, so we use <code class="markup--code markup--p-code">VV</code> to say you don’t need gradients for this guy. So that is going to give us our target activations.</p><ul class="postList"><li name="9341" id="9341" class="graf graf--li graf-after--p">We’ve taken our bird image</li><li name="e909" id="e909" class="graf graf--li graf-after--li">Turned it into a variable</li><li name="013d" id="013d" class="graf graf--li graf-after--li">Stuck it through our model to grab the 37th layer activations which is our target. We want our content loss to be this set of activations.</li><li name="0517" id="0517" class="graf graf--li graf-after--li">We are going to create an optimizer (we will go back to the details of this in a moment)</li><li name="afb1" id="afb1" class="graf graf--li graf-after--li">We are going to step a bunch of times</li><li name="a132" id="a132" class="graf graf--li graf-after--li">Zero the gradients</li><li name="a328" id="a328" class="graf graf--li graf-after--li">Call some loss function</li><li name="8bbf" id="8bbf" class="graf graf--li graf-after--li">Loss.backward()</li></ul><p name="fd4d" id="fd4d" class="graf graf--p graf-after--li">That’s the high level version. I’m going to come back to the details in a moment, but the key thing is that the loss function we are passing in that randomly generated image — the variable of optimization image. So we pass that to our loss function and it’s going to update this using the loss function, and the loss function is the mean squared error loss comparing our current optimization image passed through our VGG to get the intermediate activations and comparing it to our target activations. We run that bunch of times and we’ll print it out. And we have our bird but not the representation of it.</p><pre name="8cd0" id="8cd0" class="graf graf--pre graf-after--p">targ_t = m_vgg(VV(img_tfm[<strong class="markup--strong markup--pre-strong">None</strong>]))<br>targ_v = V(targ_t)<br>targ_t.shape</pre><pre name="0238" id="0238" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">torch.Size([1, 512, 18, 18])</em></pre><pre name="42fe" id="42fe" class="graf graf--pre graf-after--pre">max_iter = 1000<br>show_iter = 100<br>optimizer = optim.LBFGS([opt_img_v], lr=0.5)</pre><h4 name="03ea" id="03ea" class="graf graf--h4 graf-after--pre">Broyden–Fletcher–Goldfarb–Shanno (BFGS) [<a href="https://youtu.be/xXXiC4YRGrQ?t=1h20m18s" data-href="https://youtu.be/xXXiC4YRGrQ?t=1h20m18s" class="markup--anchor markup--h4-anchor" rel="noopener nofollow" target="_blank">1:20:18</a>]</h4><p name="e7a5" id="e7a5" class="graf graf--p graf-after--h4">A couple of new details here. One is a weird optimizer (<code class="markup--code markup--p-code">optim.LBFGS</code>). Anybody who’s done certain parts of math and computer science courses comes into deep learning discovers we use all this stuff like Adam and the SGD and always assume that nobody in the field knows the first thing about computer science and immediately says “any of you guys tried using BFGS?” There’s basically a long history of a totally different kind of algorithm for optimization that we don’t use to train neural networks. And of course the answer is actually the people who have spent decades studying neural networks do know a thing or two about computer science and it turns out these techniques on the whole don’t work very well. But it’s actually going to work well for this, and it’s a good opportunity to talk about an interesting algorithm for those of you that haven’t studied this type of optimization algorithm at school. BFGS (initials of four different people) and the L stands for limited memory. It is an optimizer so as an optimizer, that means that there’s some loss function and it’s going to use some gradients (not all optimizers use gradients but all the ones we use do) to find a direction to go and try to make the loss function go lower and lower by adjusting some parameters. It’s just an optimizer. But it’s an interesting kind of optimizer because it does a bit more work than the ones we’re used to on each step. Specifically, the way it works is it starts the same way that we are used to which is we just pick somewhere to get started and in this case, we’ve picked a random image as you saw. As per usual, we calculate the gradient. But we then don’t just take a step but we actually do is as well as finding the gradient, we also try to find the second derivative. The second derivative says how fast does the gradient change.</p><p name="62b2" id="62b2" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Gradient</strong>: how fast the function change</p><p name="c639" id="c639" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">The second derivative</strong>: how fast the gradient change</p><p name="c222" id="c222" class="graf graf--p graf-after--p">In other words, how curvy is it? The basic idea is that if you know that it’s not very curvy, then you can probably jump farther. But if it’s very curvy then you probably don’t want to jump as far. So in higher dimensions, the gradient is called the Jacobian and the second derivative is called the Hessian. You’ll see those words all the time, but that’s all they mean. Again, mathematicians have to invent your words for everything as well. They are just like deep learning researchers — maybe a bit more snooty. With BFGS, we are going to try and calculate the second derivative and then we are going to use that to figure out what direction to go and how far to go — so it’s less of a wild jump into the unknown.</p><p name="8379" id="8379" class="graf graf--p graf-after--p">Now the problem is that actually calculating the Hessian (the second derivative) is almost certainly not a good idea[<a href="https://youtu.be/xXXiC4YRGrQ?t=1h24m15s" data-href="https://youtu.be/xXXiC4YRGrQ?t=1h24m15s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:24:15</a>]. Because in each possible direction that you are going to head, for each direction that you’re measuring the gradient in, you also have to calculate the Hessian in every direction. It gets ridiculously big. So rather than actually calculating it, we take a few steps and we basically look at how much the gradient is changing as we do each step, and we approximate the Hessian using that little function. Again, this seems like a really obvious thing to do but nobody thought of it until someone did surprisingly a long time later. Keeping track of every single step you take takes a lot of memory, so duh, don’t keep track of every step you take — just keep the last ten or twenty. And the second bit there, that’s the L to the LBFGS. So a limited-memory BFGS means keep the last 10 or 20 gradients, use that to approximate the amount of curvature, and then use the curvature in gradient to estimate what direction to travel and how far. That’s normally not a good idea in deep learning for a number of reasons. It’s obviously more work to do than than Adam or SGD update, and it also uses more memory — memory is much more of a big issue when you’ve got a GPU to store it on and hundreds of millions of weights. But more importantly, the mini-batch is super bumpy so figuring out curvature to decide exactly how far to travel is kind of polishing turds as we say (yeah, Australian and English expression — you get the idea). Interestingly, actually using the second derivative information, it turns out, is like a magnet for saddle points. So there’s some interesting theoretical results that basically say it actually sends you towards nasty flat areas of the function if you use second derivative information. So normally not a good idea.</p><pre name="e3fb" id="e3fb" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">def</strong> actn_loss(x): <strong class="markup--strong markup--pre-strong">return</strong> F.mse_loss(m_vgg(x), targ_v)*1000</pre><pre name="b18b" id="b18b" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">def</strong> step(loss_fn):<br>    <strong class="markup--strong markup--pre-strong">global</strong> n_iter<br>    optimizer.zero_grad()<br>    loss = loss_fn(opt_img_v)<br>    loss.backward()<br>    n_iter+=1<br>    <strong class="markup--strong markup--pre-strong">if</strong> n_iter%show_iter==0: <br>        print(f'Iteration: n_iter, loss: <strong class="markup--strong markup--pre-strong">{loss.data[0]}</strong>')<br>    <strong class="markup--strong markup--pre-strong">return</strong> loss</pre><p name="4a66" id="4a66" class="graf graf--p graf-after--pre">But in this case [<a href="https://youtu.be/xXXiC4YRGrQ?t=1h26m40s" data-href="https://youtu.be/xXXiC4YRGrQ?t=1h26m40s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:26:40</a>], we are not optimizing weights, we are optimizing pixels so all the rules change and actually turns out BFGS does make sense. Because it does more work each time, it’s a different kind of optimizer, the API is a little bit different in PyTorch. As you can see here, when you say <code class="markup--code markup--p-code">optimizer.step</code>, you actually pass in the loss function. So our loss function is to call <code class="markup--code markup--p-code">step</code> with a particular loss function which is our activation loss (<code class="markup--code markup--p-code">actn_loss</code>). And inside the loop, you don’t say step, step, step. But rather it looks like this. So it’s a little bit different and you’re welcome to try and rewrite this to use SGD, it’ll still work. It’ll just take a bit longer — I haven’t tried it with SGD yet and I’d be interested to know how much longer it takes.</p><pre name="b82e" id="b82e" class="graf graf--pre graf-after--p">n_iter=0<br><strong class="markup--strong markup--pre-strong">while</strong> n_iter &lt;= max_iter: optimizer.step(partial(step,actn_loss))</pre><pre name="5d11" id="5d11" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">Iteration: n_iter, loss: 0.8466196656227112<br>Iteration: n_iter, loss: 0.34066855907440186<br>Iteration: n_iter, loss: 0.21001280844211578<br>Iteration: n_iter, loss: 0.15562333166599274<br>Iteration: n_iter, loss: 0.12673595547676086<br>Iteration: n_iter, loss: 0.10863320529460907<br>Iteration: n_iter, loss: 0.0966048613190651<br>Iteration: n_iter, loss: 0.08812198787927628<br>Iteration: n_iter, loss: 0.08170554041862488<br>Iteration: n_iter, loss: 0.07657770067453384</em></pre><p name="b4fa" id="b4fa" class="graf graf--p graf-after--pre">So you can see the loss function going down [<a href="https://youtu.be/xXXiC4YRGrQ?t=1h27m38s" data-href="https://youtu.be/xXXiC4YRGrQ?t=1h27m38s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:27:38</a>]. The mean squared error between the activations at layer 37 of our VGG model for our optimized image vs. the target activations, remember the target activations were the VGG applied to our bird. Make sense? So we’ve now got a content loss. Now, one thing I’ll say about this content loss is we don’t know which layer is going to work the best. So it would be nice if we were able to experiment a little bit more. And the way it is here is annoying:</p><figure name="18c3" id="18c3" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_KTfbdTPG-pZ95vEOLrJa9Q.png"></figure><p name="c12c" id="c12c" class="graf graf--p graf-after--figure">Maybe we even want to use multiple layers. So rather than lopping off all of the layers after the one we want, wouldn’t it be nice if we could somehow grab the activations of a few layers as it calculates. Now, we already know one way to do that back when we did SSD, we actually wrote our own network which had a number of outputs. Remember? The different convolutional layers, we spat out a different <code class="markup--code markup--p-code">oconv</code> thing? But I don’t really want to go and add that to the torch.vision ResNet model especially not if later on, I want to try torch.vision VGG model, and then I want to try NASNet-A model, I don’t want to go into all of them and change their outputs. Beside which, I’d like to easily be able to turn certain activations on and off on demand. So we briefly touched before this idea that PyTorch has these fantastic things called hooks. You can have forward hooks that let you plug anything you like into the forward pass of a calculation or a backward hook that lets you plug anything you like into the backward pass. So we are going to create the world’s simplest forward hook.</p><pre name="d744" id="d744" class="graf graf--pre graf-after--p">x = val_tfms.denorm(np.rollaxis(to_np(opt_img_v.data),1,4))[0]<br>plt.figure(figsize=(7,7))<br>plt.imshow(x);</pre><figure name="a43b" id="a43b" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_CzZ-KObFhqarMxnV5lD-IQ.png"></figure><h3 name="f018" id="f018" class="graf graf--h3 graf-after--figure">Forward hook [<a href="https://youtu.be/xXXiC4YRGrQ?t=1h29m42s" data-href="https://youtu.be/xXXiC4YRGrQ?t=1h29m42s" class="markup--anchor markup--h3-anchor" rel="nofollow noopener" target="_blank">1:29:42</a>]</h3><p name="29c7" id="29c7" class="graf graf--p graf-after--h3">This is one of these things that almost nobody knows about so almost any code you find on the internet that implements style transfer will have all kind of horrible hacks rather than using forward hooks. But forward hook is really easy.</p><p name="ee12" id="ee12" class="graf graf--p graf-after--p">To create a forward hook, you just create a class. The class has to have something called <code class="markup--code markup--p-code">hook_fn</code>. And your hook function is going to receive the <code class="markup--code markup--p-code">module</code> that you’ve hooked, the <code class="markup--code markup--p-code">input</code> for the forward pass, and the <code class="markup--code markup--p-code">output</code> then you do whatever you’d like. So what I’m going to do is I’m just going to store the output of this module in some attribute. That’s it. So <code class="markup--code markup--p-code">hook_fn</code> can actually be called anything you like, but “hook function” seems to be the standard because, as you can see, what happens in the constructor is I store inside some attribute the result of <code class="markup--code markup--p-code">m.register_forward_hook</code> (<code class="markup--code markup--p-code">m</code> is going to be the layer that I’m going to hook) and pass in the function that you want to be called when the module’s forward method is called. When its forward method is called, it will call <code class="markup--code markup--p-code">self.hook_fn</code> which will store the output in an attribute called <code class="markup--code markup--p-code">features</code>.</p><pre name="bbf0" id="bbf0" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">class</strong> <strong class="markup--strong markup--pre-strong">SaveFeatures</strong>():<br>    features=<strong class="markup--strong markup--pre-strong">None</strong><br>    <strong class="markup--strong markup--pre-strong">def</strong> __init__(self, m): <br>        self.hook = m.register_forward_hook(self.hook_fn)<br>    <strong class="markup--strong markup--pre-strong">def</strong> hook_fn(self, module, input, output): self.features = output<br>    <strong class="markup--strong markup--pre-strong">def</strong> close(self): self.hook.remove()</pre><p name="66f3" id="66f3" class="graf graf--p graf-after--pre">So now what we can do is we can create a VGG as before. And let’s set it to not trainable so we don’t waste time and memory calculating gradients for it. And let’s go through and find all the max pool layers. So let’s go through all of the children of this module and if it’s a max pool layer, let’s spit out index minus 1 — so that’s going to give me the layer before the max pool. In general, the layer before a max pool or stride 2 conv is a very layer. It’s the most complete representation we have at that grid cell size because the very next layer is changing the grid. So that seems to me like a good place to grab the content loss from. The best most semantic, most interesting content we have at that grid size. So that’s why I’m going to pick those indexes.</p><pre name="da84" id="da84" class="graf graf--pre graf-after--p">m_vgg = to_gpu(vgg16(<strong class="markup--strong markup--pre-strong">True</strong>)).eval()<br>set_trainable(m_vgg, <strong class="markup--strong markup--pre-strong">False</strong>)</pre><p name="75a6" id="75a6" class="graf graf--p graf-after--pre">These are the indexes of the last layer before each max pool in VGG [<a href="https://youtu.be/xXXiC4YRGrQ?t=1h32m30s" data-href="https://youtu.be/xXXiC4YRGrQ?t=1h32m30s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:32:30</a>].</p><pre name="f9b8" id="f9b8" class="graf graf--pre graf-after--p">block_ends = [i-1 <strong class="markup--strong markup--pre-strong">for</strong> i,o <strong class="markup--strong markup--pre-strong">in</strong> enumerate(children(m_vgg))<br>              <strong class="markup--strong markup--pre-strong">if</strong> isinstance(o,nn.MaxPool2d)]<br>block_ends</pre><pre name="a7c6" id="a7c6" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">[5, 12, 22, 32, 42]</em></pre><p name="fa5c" id="fa5c" class="graf graf--p graf-after--pre">I’m going to grab <code class="markup--code markup--p-code">32</code> — no particular reason, just try something else. So I’m going to say <code class="markup--code markup--p-code">block_ends[3]</code> (i.e. 32). <code class="markup--code markup--p-code">children(m_vgg)[block_ends[3]]</code> will give me the 32nd layer of VGG as a module.</p><pre name="d83d" id="d83d" class="graf graf--pre graf-after--p">sf = SaveFeatures(children(m_vgg)[block_ends[3]])</pre><p name="cefe" id="cefe" class="graf graf--p graf-after--pre">Then if I call the <code class="markup--code markup--p-code">SaveFeatures</code> constructor, it’s going to go:</p><p name="8aef" id="8aef" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">self.hook = {32nd layer of VGG}.register_forward_hook(self.hook_fn)</code></p><p name="e770" id="e770" class="graf graf--p graf-after--p">Now, every time I do a forward pass on this VGG model, it’s going to store the 32nd layer’s output inside <code class="markup--code markup--p-code">sf.features</code>.</p><pre name="1392" id="1392" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">def</strong> get_opt():<br>    opt_img = np.random.uniform(0, 1, <br>                                size=img.shape).astype(np.float32)<br>    opt_img = scipy.ndimage.filters.median_filter(opt_img, [8,8,1])<br>    opt_img_v = V(val_tfms(opt_img/2)[<strong class="markup--strong markup--pre-strong">None</strong>], requires_grad=<strong class="markup--strong markup--pre-strong">True</strong>)<br>    <strong class="markup--strong markup--pre-strong">return</strong> opt_img_v, optim.LBFGS([opt_img_v])</pre><pre name="8725" id="8725" class="graf graf--pre graf-after--pre">opt_img_v, optimizer = get_opt()</pre><p name="0fdc" id="0fdc" class="graf graf--p graf-after--pre">See here [<a href="https://youtu.be/xXXiC4YRGrQ?t=1h33m33s" data-href="https://youtu.be/xXXiC4YRGrQ?t=1h33m33s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:33:33</a>], I’m calling my VGG network, but I’m not storing it anywhere. I’m not saying <code class="markup--code markup--p-code u-paddingRight0 u-marginRight0">activations = m_vgg(VV(img_tfm[<strong class="markup--strong markup--p-strong">None</strong>]))</code>. I’m calling it, throwing away the answer, and then grabbing the features we stored in our <code class="markup--code markup--p-code">SaveFeatures</code> object.</p><p name="2411" id="2411" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">m_vgg()</code> — this is how you do a forward path in PyTorch. You don’t say <code class="markup--code markup--p-code">m_vgg.forward()</code>, you just use it as a callable. Using as a callable on an <code class="markup--code markup--p-code">nn.module</code> automatically calls <code class="markup--code markup--p-code">forward</code>. That’s how PyTorch modules work.</p><p name="8e8b" id="8e8b" class="graf graf--p graf-after--p">So we call it as a callable, that ends up calling our forward hook, that forward hook stores the activations in <code class="markup--code markup--p-code">sf.features</code>, and so now we have our target variable — just like before but in a much more flexible way.</p><p name="d422" id="d422" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">get_opt</code> contains the same 4 lines of code we had earlier [<a href="https://youtu.be/xXXiC4YRGrQ?t=1h34m34s" data-href="https://youtu.be/xXXiC4YRGrQ?t=1h34m34s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:34:34</a>]. It is just giving me my random image to optimize and an optimizer to optimize that image.</p></body></html>