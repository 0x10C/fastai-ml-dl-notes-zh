
<!-- saved from url=(0064)file:///C:/Users/asus/Desktop/fastai-ml-dl-notes-zh/en/dl14.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></head><body><hr class="section-divider"><h1 name="36cf" id="36cf" class="graf graf--h3 graf--leading graf--title">Deep Learning 2: Part 2 Lesson&nbsp;14</h1><p name="5787" id="5787" class="graf graf--p graf-after--h3"><em class="markup--em markup--p-em">My personal notes from </em><a href="http://www.fast.ai/" data-href="http://www.fast.ai/" class="markup--anchor markup--p-anchor" rel="noopener nofollow nofollow noopener noopener noopener nofollow noopener nofollow noopener noopener nofollow noopener noopener nofollow noopener nofollow noopener" target="_blank"><em class="markup--em markup--p-em">fast.ai course</em></a><em class="markup--em markup--p-em">. These notes will continue to be updated and improved as I continue to review the course to “really” understand it. Much appreciation to </em><a href="https://twitter.com/jeremyphoward" data-href="https://twitter.com/jeremyphoward" class="markup--anchor markup--p-anchor" rel="noopener nofollow nofollow noopener noopener noopener nofollow noopener nofollow noopener noopener nofollow noopener noopener nofollow noopener nofollow noopener" target="_blank"><em class="markup--em markup--p-em">Jeremy</em></a><em class="markup--em markup--p-em"> and </em><a href="https://twitter.com/math_rachel" data-href="https://twitter.com/math_rachel" class="markup--anchor markup--p-anchor" rel="noopener nofollow nofollow noopener noopener noopener nofollow noopener nofollow noopener noopener nofollow noopener noopener nofollow noopener nofollow noopener" target="_blank"><em class="markup--em markup--p-em">Rachel</em></a><em class="markup--em markup--p-em"> who gave me this opportunity to learn.</em></p><p name="bd83" id="bd83" class="graf graf--p graf-after--p graf--trailing">Lessons: <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-1-602f73869197" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-1-602f73869197" class="markup--anchor markup--p-anchor" target="_blank">1</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-2-eeae2edd2be4" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-2-eeae2edd2be4" class="markup--anchor markup--p-anchor" target="_blank">2</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-3-74b0ef79e56" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-3-74b0ef79e56" class="markup--anchor markup--p-anchor" target="_blank">3</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-4-2048a26d58aa" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-4-2048a26d58aa" class="markup--anchor markup--p-anchor" target="_blank">4</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-5-dd904506bee8" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-5-dd904506bee8" class="markup--anchor markup--p-anchor" target="_blank">5</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-6-de70d626976c" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-6-de70d626976c" class="markup--anchor markup--p-anchor" target="_blank">6</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-7-1b9503aff0c" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-7-1b9503aff0c" class="markup--anchor markup--p-anchor" target="_blank">7</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-8-5ae195c49493" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-8-5ae195c49493" class="markup--anchor markup--p-anchor" target="_blank">8</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-9-5f0cf9e4bb5b" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-9-5f0cf9e4bb5b" class="markup--anchor markup--p-anchor" target="_blank">9</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-10-422d87c3340c" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-10-422d87c3340c" class="markup--anchor markup--p-anchor" target="_blank">10</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-11-61477d24dc34" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-11-61477d24dc34" class="markup--anchor markup--p-anchor" target="_blank">11</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-12-215dfbf04a94" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-12-215dfbf04a94" class="markup--anchor markup--p-anchor" target="_blank">12</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-13-43454b21a5d0" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-13-43454b21a5d0" class="markup--anchor markup--p-anchor" target="_blank">13</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-14-e0d23c7a0add" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-14-e0d23c7a0add" class="markup--anchor markup--p-anchor" target="_blank"><strong class="markup--strong markup--p-strong">14</strong></a></p><hr class="section-divider"><p name="88ab" id="88ab" class="graf graf--p graf--leading"><a href="http://forums.fast.ai/t/part-2-lesson-14-wiki/15650/1" data-href="http://forums.fast.ai/t/part-2-lesson-14-wiki/15650/1" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Forum</a> / <a href="https://youtu.be/nG3tT31nPmQ" data-href="https://youtu.be/nG3tT31nPmQ" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Video</a></p><figure name="ed31" id="ed31" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_X98pzSCWnxb5gbQxDyZ92Q.png"></figure><h4 name="56df" id="56df" class="graf graf--h4 graf-after--figure">Show and tell from last&nbsp;week</h4><figure name="f17e" id="f17e" class="graf graf--figure graf-after--h4"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_iZP-sgkKoKU2dlGj5CUBaw.jpeg"></figure><p name="563a" id="563a" class="graf graf--p graf-after--figure">Alena Harley did something really interesting which was she tried finding out what would happen if you did cycle GAN on just three or four hundred images and I really like these projects where people just go to Google Image Search using the API or one of the libraries out there. Some of our students have created some very good libraries for interacting with Google images API to download a bunch of stuff they are interested in, in this case some photos and some stained glass windows. With 300~400 photos of that, she trained a few different model — this is what I particularly liked. As you can see, with quite a small number of images, she gets very nice stained-glass effects. So I thought that was an interesting example of using pretty small amounts of data that was readily available that she was able to download pretty quickly. There is more information about that on the forum if you are interested.&nbsp;<br>It’s interesting to wonder about what kinds of things people will come up with with this kind of generative model. It’s clearly a great artistic medium. It’s clearly a great medium for forgeries and fakeries. I wonder what other kinds of things people will realize they can do with these kind of generative models. I think audio is going to be the next big area. Also very interactive type stuff. Nvidia just released a paper showing a interactive kind of photo repair tool where you just brush over an object and it replaces it with a deep learning generated replacement very nicely. Those kinds of interactive tools, I think would be very interesting too.</p><h3 name="0c8a" id="0c8a" class="graf graf--h3 graf-after--p">Super-Resolution [<a href="https://youtu.be/nG3tT31nPmQ?t=2m6s" data-href="https://youtu.be/nG3tT31nPmQ?t=2m6s" class="markup--anchor markup--h3-anchor" rel="noopener nofollow" target="_blank">2:06</a>]</h3><p name="8d3c" id="8d3c" class="graf graf--p graf-after--h3"><a href="https://arxiv.org/abs/1603.08155" data-href="https://arxiv.org/abs/1603.08155" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Perceptual Losses for Real-Time Style Transfer and Super-Resolution</a></p><p name="110a" id="110a" class="graf graf--p graf-after--p">Last time, we looked at doing style transfer by actually directly optimizing pixels. Like with most of the things in part two, it’s not so much that I’m wanting you to understand style transfer per se, but the kind of idea of optimizing your input directly and using activations as part of a loss function is really the key takeaway here.</p><p name="3153" id="3153" class="graf graf--p graf-after--p">So it’s interesting then to see effectively the follow-up paper, not from the same people but the paper that came next in the sequence of these vision generative models with this one from Justin Johnson and folks at Stanford. It actually does the same thing — style transfer, but does it in a different way. Rather than optimizing the pixels, we are going to go back to something much more familiar and optimize some weights. So specifically, we are going to train a model which learns to take a photo and translate it into a photo in the style of a particular artwork. So each conv net will learn to produce one kind of style.</p><p name="a777" id="a777" class="graf graf--p graf-after--p">Now it turns out that getting to that point, there is an intermediate point which (I actually think more useful and takes us half way there) is something called super resolution. So we are actually going to start with super resolution [<a href="https://youtu.be/nG3tT31nPmQ?t=3m55s" data-href="https://youtu.be/nG3tT31nPmQ?t=3m55s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">3:55</a>]. Because then we’ll build on top of super resolution to finish off the conv net based style transfer.</p><p name="ad6b" id="ad6b" class="graf graf--p graf-after--p">Super resolution is where we take a low resolution image (we are going to take 72 by 72) and upscale it to a larger image (288 by 288 in our case) trying to create a higher res image that looks as real as possible. This is a challenging thing to do because at 72 by 72, there’s not that much information about a lot of the details. The cool thing is that we are going to do it in a way as we tend to do with vision models which is not tied to the input size so you could totally then take this model and apply it to a 288 by 288 image and get something that’s four times bigger on each side so 16 times bigger than the original. Often it even works better at that level because you’re really introducing a lot of detail into the finer details and you could really print out a high resolution print of something which earlier on was pretty pixelated.</p><h4 name="6b95" id="6b95" class="graf graf--h4 graf-after--p"><a href="https://github.com/fastai/fastai/blob/master/courses/dl2/enhance.ipynb" data-href="https://github.com/fastai/fastai/blob/master/courses/dl2/enhance.ipynb" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">Notebook</a> [<a href="https://youtu.be/nG3tT31nPmQ?t=5m6s" data-href="https://youtu.be/nG3tT31nPmQ?t=5m6s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">5:06</a>]</h4><p name="2a13" id="2a13" class="graf graf--p graf-after--h4">It is a lot like that kind of CSI style enhancement where we’re going to take something that appears the information is just not there and we kind of invent it — but the conv net is going to learn to invent it in a way that’s consistent with the information that is there, so hopefully it’s inventing the right information. One of the really nice things about this kind of problem is that we can create our own dataset as big as we like without any labeling requirements because we can easily create a low res image from a high res image just by down sampling our images. So something I would love some of you to try this week would be to do other types of image-to-image translation where you can invent “labels” (your dependent variables). For example:</p><ul class="postList"><li name="db7f" id="db7f" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Deskewing</strong>: Either recognize things that have been rotated by 90 degrees or better still that have been rotated by 5 degrees and straighten them.</li><li name="6b3f" id="6b3f" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Colorization</strong>: Make a bunch of images into black-and-white and learn to put the color back again.</li><li name="184a" id="184a" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Noise-reduction</strong>: Maybe do a really low quality JPEG save, and learn to put it back to how it should have been.</li><li name="4610" id="4610" class="graf graf--li graf-after--li">Maybe taking something that’s in a 16 color palette and put it back to a higher color palette.</li></ul><p name="4147" id="4147" class="graf graf--p graf-after--li">I think these things are all interesting because they can be used to take pictures that you may have taken back on crappy old digital cameras before there are high resolution or you may have scanned in some old photos that are now faded, etc. I think it’s really useful thing to be able to do and it’s a good project because it’s really similar to what we are doing here but different enough that you come across some interesting challenges on the way, I’m sure.</p><p name="daf5" id="daf5" class="graf graf--p graf-after--p">I’m going to use ImageNet again [<a href="https://youtu.be/nG3tT31nPmQ?t=7m19s" data-href="https://youtu.be/nG3tT31nPmQ?t=7m19s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">7:19</a>]. You don’t need to use all of the ImageNet at all, I just happen to have it lying around. You can download the one percent sample of ImageNet from files.fast.ai. You can use any set of pictures you have lying around honestly.</p><pre name="60e7" id="60e7" class="graf graf--pre graf-after--p">matplotlib inline<br>%reload_ext autoreload<br>%autoreload 2</pre><h3 name="1757" id="1757" class="graf graf--h3 graf-after--pre">Super resolution data</h3><pre name="5e20" id="5e20" class="graf graf--pre graf-after--h3"><strong class="markup--strong markup--pre-strong">from</strong> <strong class="markup--strong markup--pre-strong">fastai.conv_learner</strong> <strong class="markup--strong markup--pre-strong">import</strong> *<br><strong class="markup--strong markup--pre-strong">from</strong> <strong class="markup--strong markup--pre-strong">pathlib</strong> <strong class="markup--strong markup--pre-strong">import</strong> Path<br><br>torch.backends.cudnn.benchmark=<strong class="markup--strong markup--pre-strong">True</strong></pre><pre name="8467" id="8467" class="graf graf--pre graf-after--pre">PATH = Path('data/imagenet')<br>PATH_TRN = PATH/'train'</pre><p name="706d" id="706d" class="graf graf--p graf-after--pre">In this case, as I say we don’t really have labels per se, so I’m just going to give everything a label of zero just so we can use it with our existing infrastructure more easily.</p><pre name="0bcc" id="0bcc" class="graf graf--pre graf-after--p">fnames_full,label_arr_full,all_labels = folder_source(PATH, 'train')<br>fnames_full = ['/'.join(Path(fn).parts[-2:]) <strong class="markup--strong markup--pre-strong">for</strong> fn <strong class="markup--strong markup--pre-strong">in</strong> fnames_full]<br>list(zip(fnames_full[:5],label_arr_full[:5]))</pre><pre name="e032" id="e032" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">[('n01440764/n01440764_9627.JPEG', 0),<br> ('n01440764/n01440764_9609.JPEG', 0),<br> ('n01440764/n01440764_5176.JPEG', 0),<br> ('n01440764/n01440764_6936.JPEG', 0),<br> ('n01440764/n01440764_4005.JPEG', 0)]</em></pre><pre name="56be" id="56be" class="graf graf--pre graf-after--pre">all_labels[:5]</pre><pre name="ae3e" id="ae3e" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">['n01440764', 'n01443537', 'n01484850', 'n01491361', 'n01494475']</em></pre><p name="8c9c" id="8c9c" class="graf graf--p graf-after--pre">Now, because I’m pointing at a folder that contains all of ImageNet, I certainly don’t want to wait for all of ImageNet to finish to run an epoch. So here, I’m just, most of the time, I would set “keep percent” ( <code class="markup--code markup--p-code">keep_pct</code> ) to 1 or 2%. And then I just generate a bunch of random numbers and then I just keep those which are less than 0.02 and so that lets me quickly subsample my rows.</p><pre name="5e38" id="5e38" class="graf graf--pre graf-after--p">np.random.seed(42)<br># keep_pct = 1.<br><em class="markup--em markup--pre-em">keep_pct = 0.02</em><br>keeps = np.random.rand(len(fnames_full)) &lt; keep_pct<br>fnames = np.array(fnames_full, copy=<strong class="markup--strong markup--pre-strong">False</strong>)[keeps]<br>label_arr = np.array(label_arr_full, copy=<strong class="markup--strong markup--pre-strong">False</strong>)[keeps]</pre><p name="499f" id="499f" class="graf graf--p graf-after--pre">So we are going to use VGG16 [<a href="https://youtu.be/nG3tT31nPmQ?t=8m21s" data-href="https://youtu.be/nG3tT31nPmQ?t=8m21s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">8:21</a>] and VGG16 is something that we haven’t really looked at in this class but it’s a very simple model where we take our normal presumably 3 channel input, and we basically run it through a number of 3x3 convolutions, and then from time to time, we put it through a 2x2 maxpool and then we do a few more 3x3 convolutions, maxpool, so on so forth. And this is our backbone.</p><figure name="c65d" id="c65d" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_kj2sH_5R5tNvT7ajbHqXKw.png"></figure><p name="165f" id="165f" class="graf graf--p graf-after--figure">Then we don’t do an adaptive average pooling layer. After a few of these, we end up with this 7x7x512 grid as usual (or something similar). So rather than average pooling, we do something different which is we flatten the whole thing — so that spits out a very long vector of activations of size 7x7x512 if memory serves correctly. Then that gets fed into two fully connected layers each one of which has 4096 activations, and one more fully connected layer which has however many classes. So if you think about it, the weight matrix here, it’s HUGE 7x7x512x4096. It’s because of that weight matrix really that VGG went out of favor pretty quickly — because it takes a lot of memory and takes a lot of computation and it’s really slow. And there’s a lot of redundant stuff going on here because really those 512 activations are not that specific to which of those 7x7 grid cells they are in. But when you have this entire weight matrix here of every possible combination, it treats all of them uniquely. So that can also lead to generalization problems because there’s just a lot of weights and so forth.</p><figure name="7e65" id="7e65" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1__UB-iwca2SW15UhI8VLZ6g.png"></figure><p name="5ddf" id="5ddf" class="graf graf--p graf-after--figure">My view is that the approach that is used in every modern network which is here we do an adaptive average pooling (in Keras it’s known as a global average pooling, in fast.ai, we do an AdaptiveConcatPool) which spits it straight down to a 512 long activation [<a href="https://youtu.be/nG3tT31nPmQ?t=11m6s" data-href="https://youtu.be/nG3tT31nPmQ?t=11m6s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">11:06</a>]. I think that’s throwing away too much geometry. So to me, probably the correct answer is somewhere in between and will involve some kind of factored convolution or some kind tensor decomposition which maybe some of us can think about in the coming months. So for now, anyway, we’ve gone from one extreme which is the adaptive average pooling to the other extreme which is this huge flattened fully connected layer.</p><p name="e437" id="e437" class="graf graf--p graf-after--p">A couple of things which are interesting about VGG that make it still useful today [<a href="https://youtu.be/nG3tT31nPmQ?t=11m59s" data-href="https://youtu.be/nG3tT31nPmQ?t=11m59s" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener" target="_blank">11:59</a>]. The first one is that there’s more interesting layers going on here with most modern networks including the ResNet family, the very first layer generally is a 7x7 conv with stride 2 or something similar. Which means we throw away half the grid size straight away and so there is little opportunity to use the fine detail because we never do any computation with it. So that’s a bit of a problem for things like segmentation or super resolution models because the fine details matters. We actually want to restore it. Then the second problem is that the adaptive pooling layer entirely throws away the geometry in the last few sections which means that the rest of the model doesn’t really have as much interesting kind of learning that geometry as it otherwise might. Therefore for things which are dependent on position, any kind of localization based approach to anything that requires generative model is going to be less effective. So one of the things I’m hoping you are hearing as I describe this is that probably <span class="markup--quote markup--p-quote is-other" name="9887f0844031" data-creator-ids="eab3a535185e">none of the existing architectures are actually ideal. We can invent a new one</span>. Actually, I just tried inventing a new one over the week which was to take the VGG head and attach it to a ResNet backbone. Interestingly, I found I actually got a slightly better classifier than a normal ResNet but it also was something with a little bit more useful information in it. It took 5 or 10% longer to train but nothing worth worrying about. Maybe we could, in ResNet, replace this (7x7 conv stride 2) as we’ve talked about briefly before. This very early convolution with something more like an Inception stem which has a bit more computation. I think there’s definitely room for some nice little tweaks to these architectures so that we can build some models which are maybe more versatile. <span class="markup--quote markup--p-quote is-other" name="21ea327e4a82 anon_715b4d288832" data-creator-ids="eab3a535185e anon">At the moment, people tend to build architectures that just do one thing. They don’t really think what am I throwing away in terms of opportunity</span> because that’s how publishing works. You published “I’ve got state of the art of this one thing rather than you have created something that’s good at a lots of things.</p><p name="d054" id="d054" class="graf graf--p graf-after--p">For these reasons, we are going to use VGG today even though it’s ancient and it’s missing lots of great stuff [<a href="https://youtu.be/nG3tT31nPmQ?t=14m42s" data-href="https://youtu.be/nG3tT31nPmQ?t=14m42s" class="markup--anchor markup--p-anchor" rel="noopener nofollow" target="_blank">14:42</a>]. One thing we are going to do though is use a slightly more modern version which is a version of VGG where batch norm has been added after all the convolutions. In fast.ai when you ask for a VGG network, you always get the batch norm one because that’s basically always what you want. So this is VGG with batch norm. There is 16 and 19, the 19 is way bigger and heavier, and doesn’t really do any better, so no one really uses it.</p><pre name="2acc" id="2acc" class="graf graf--pre graf-after--p">arch = vgg16<br>sz_lr = 72</pre><p name="cd55" id="cd55" class="graf graf--p graf-after--pre">We are going to go from 72 by 72 LR (<code class="markup--code markup--p-code">sz_lr</code>: size low resolution) input. We are going to initially scale it up by times 2 with the batch size of 64 to get 2 * 72 so 144 by 144 output. That is going to be our stage one.</p><pre name="a195" id="a195" class="graf graf--pre graf-after--p">scale,bs = 2,64<br><em class="markup--em markup--pre-em"># scale,bs = 4,32</em><br>sz_hr = sz_lr*scale</pre><p name="f6fd" id="f6fd" class="graf graf--p graf-after--pre">We’ll create our own dataset for this and it’s very worthwhile looking inside the fastai.dataset module and seeing what’s there [<a href="https://youtu.be/nG3tT31nPmQ?t=15m45s" data-href="https://youtu.be/nG3tT31nPmQ?t=15m45s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">15:45</a>]. Because just about anything you’d want, we probably have something that’s almost what you want. So in this case, I want a dataset where my <em class="markup--em markup--p-em">x</em>’s are images and my <em class="markup--em markup--p-em">y</em>’s are also images. There’s already a files dataset we can inherit from where the <em class="markup--em markup--p-em">x</em>’s are images and then I just inherit from that and I just copied and pasted the <code class="markup--code markup--p-code">get_x</code> and turn that into <code class="markup--code markup--p-code">get_y</code> so it just opens an image. Now I’ve got something where the <em class="markup--em markup--p-em">x</em> is an image and the <em class="markup--em markup--p-em">y</em> is an image, and in both cases, what we’re passing in is an array of files names.</p><pre name="4140" id="4140" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">class</strong> <strong class="markup--strong markup--pre-strong">MatchedFilesDataset</strong>(FilesDataset):<br>    <strong class="markup--strong markup--pre-strong">def</strong> __init__(self, fnames, y, transform, path):<br>        self.y=y<br>        <strong class="markup--strong markup--pre-strong">assert</strong>(len(fnames)==len(y))<br>        super().__init__(fnames, transform, path)<br>    <strong class="markup--strong markup--pre-strong">def</strong> get_y(self, i): <br>        <strong class="markup--strong markup--pre-strong">return</strong> open_image(os.path.join(self.path, self.y[i]))<br>    <strong class="markup--strong markup--pre-strong">def</strong> get_c(self): <strong class="markup--strong markup--pre-strong">return</strong> 0</pre><p name="21b4" id="21b4" class="graf graf--p graf-after--pre">I’m going to do some data augmentation [<a href="https://youtu.be/nG3tT31nPmQ?t=16m32s" data-href="https://youtu.be/nG3tT31nPmQ?t=16m32s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">16:32</a>]. Obviously with all of ImageNet, we don’t really need it but this is mainly here for anybody who is using smaller datasets to make the most of it. <code class="markup--code markup--p-code">RandomDihedral</code> is referring to every possible 90 degree rotation plus optional left/right flipping so they are dihedral group of eight symmetries. Normally we don’t use this transformation for ImageNet pictures because you don’t normally flip dogs upside down but in this case, we are not trying to classify whether it’s a dog or a cat, we are just trying to keep the general structure of it. So actually every possible flip is a reasonably sensible thing to do for this problem.</p><pre name="64a6" id="64a6" class="graf graf--pre graf-after--p">aug_tfms = [RandomDihedral(tfm_y=TfmType.PIXEL)]</pre><p name="3cb1" id="3cb1" class="graf graf--p graf-after--pre">Create a validation set in the usual way [<a href="https://youtu.be/nG3tT31nPmQ?t=17m19s" data-href="https://youtu.be/nG3tT31nPmQ?t=17m19s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">17:19</a>]. You can see I’m using a few more slightly lower level functions — generally speaking, I just copy and paste them out of the fastai source code to find the bits I want. So here is the bit which takes an array of validation set indexes and one or more arrays of variables, and simply splits. In this case, this (<code class="markup--code markup--p-code">np.array(fnames)</code>) into a training and validation set, and this (the second <code class="markup--code markup--p-code">np.array(fnames)</code>) into a training and validation set to give us our <em class="markup--em markup--p-em">x</em>’s and our <em class="markup--em markup--p-em">y</em>’s. In this case, the <em class="markup--em markup--p-em">x</em> and the <em class="markup--em markup--p-em">y</em> are the same. Our input image and our output image are the same. We are going to use transformations to make one of them lower resolution. That’s why these are the same thing&nbsp;.</p><pre name="3283" id="3283" class="graf graf--pre graf-after--p">val_idxs = get_cv_idxs(len(fnames), val_pct=min(0.01/keep_pct, 0.1))<br>((val_x,trn_x),(val_y,trn_y)) = split_by_idx(val_idxs, <br>                                np.array(fnames), np.array(fnames))<br>len(val_x),len(trn_x)</pre><pre name="d882" id="d882" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">(12811, 1268356)</em></pre><pre name="f19a" id="f19a" class="graf graf--pre graf-after--pre">img_fn = PATH/'train'/'n01558993'/'n01558993_9684.JPEG'</pre><p name="5c5e" id="5c5e" class="graf graf--p graf-after--pre">The next thing that we need to do is to create our transformations as per usual [<a href="https://youtu.be/nG3tT31nPmQ?t=18m13s" data-href="https://youtu.be/nG3tT31nPmQ?t=18m13s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">18:13</a>]. We are going to use <code class="markup--code markup--p-code">tfm_y</code> parameter like we did for bounding boxes but rather than use <code class="markup--code markup--p-code">TfmType.COORD</code> we are going to use <code class="markup--code markup--p-code">TfmType.PIXEL</code>. That tells our transformations framework that your <em class="markup--em markup--p-em">y</em> values are images with normal pixels in them, so anything you do to the <em class="markup--em markup--p-em">x</em>, you also need to do the same thing to the <em class="markup--em markup--p-em">y</em>. You need to make sure any data augmentation transformations you use have the same parameter as well.</p><pre name="e163" id="e163" class="graf graf--pre graf-after--p">tfms = tfms_from_model(arch, sz_lr, tfm_y=TfmType.PIXEL, <br>          aug_tfms=aug_tfms, sz_y=sz_hr)<br>datasets = ImageData.get_ds(MatchedFilesDataset, (trn_x,trn_y), <br>               (val_x,val_y), tfms, path=PATH_TRN)<br>md = ImageData(PATH, datasets, bs, num_workers=16, classes=<strong class="markup--strong markup--pre-strong">None</strong>)</pre><p name="bd93" id="bd93" class="graf graf--p graf-after--pre">You can see the possible transform types you got:</p><ul class="postList"><li name="a58c" id="a58c" class="graf graf--li graf-after--p">CLASS: classification which we are about to use the segmentation in the second half of today</li><li name="f819" id="f819" class="graf graf--li graf-after--li">COORD: coordinates — no transformation at all</li><li name="6560" id="6560" class="graf graf--li graf-after--li">PIXEL</li></ul><p name="e31c" id="e31c" class="graf graf--p graf-after--li">Once we have <code class="markup--code markup--p-code">Dataset</code> class and some <em class="markup--em markup--p-em">x</em> and <em class="markup--em markup--p-em">y</em> training and validation sets. There is a handy little method called get datasets (<code class="markup--code markup--p-code">get_ds</code>) which basically runs that constructor over all the different things that you have to return all the datasets you need in exactly the right format to pass to a ModelData constructor (in this case the <code class="markup--code markup--p-code">ImageData</code> constructor). So we are kind of going back under the covers of fastai a little bit and building it up from scratch. In the next few weeks, this will all be wrapped up and refactored into something that you can do in a single step in fastai. But the point of this class is to learn a bit about going under the covers.</p><p name="c3c1" id="c3c1" class="graf graf--p graf-after--p">Something we’ve briefly seen before is that when we take images in, we transform them not just with data augmentation but we also move the channel dimension up to the start, we subtract the mean divided by the standard deviation etc [<a href="https://youtu.be/nG3tT31nPmQ?t=20m8s" data-href="https://youtu.be/nG3tT31nPmQ?t=20m8s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">20:08</a>]. So if we want to be able to display those pictures that have come out of our datasets or data loaders, we need to de-normalize them. So the model data object’s (<code class="markup--code markup--p-code">md</code>) dataset (<code class="markup--code markup--p-code">val_ds</code>) has denorm function that knows how to do that. I’m just going to give that a short name for convenience:</p><pre name="2013" id="2013" class="graf graf--pre graf-after--p">denorm = md.val_ds.denorm</pre><p name="2cc4" id="2cc4" class="graf graf--p graf-after--pre">So now I’m going to create a function that can show an image from a dataset and if you pass in something saying this is a normalized image, then we’ll denorm it.</p><pre name="c3e6" id="c3e6" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">def</strong> show_img(ims, idx, figsize=(5,5), normed=<strong class="markup--strong markup--pre-strong">True</strong>, ax=<strong class="markup--strong markup--pre-strong">None</strong>):<br>    <strong class="markup--strong markup--pre-strong">if</strong> ax <strong class="markup--strong markup--pre-strong">is</strong> <strong class="markup--strong markup--pre-strong">None</strong>: fig,ax = plt.subplots(figsize=figsize)<br>    <strong class="markup--strong markup--pre-strong">if</strong> normed: ims = denorm(ims)<br>    <strong class="markup--strong markup--pre-strong">else</strong>:      ims = np.rollaxis(to_np(ims),1,4)<br>    ax.imshow(np.clip(ims,0,1)[idx])<br>    ax.axis('off')</pre><pre name="4c65" id="4c65" class="graf graf--pre graf-after--pre">x,y = next(iter(md.val_dl))<br>x.size(),y.size()</pre><pre name="1382" id="1382" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">(torch.Size([32, 3, 72, 72]), torch.Size([32, 3, 288, 288]))</em></pre><p name="4c2c" id="4c2c" class="graf graf--p graf-after--pre">You’ll see here we’ve passed in size low res (<code class="markup--code markup--p-code">sz_lr</code>) as our size for the transforms and size high res (<code class="markup--code markup--p-code">sz_hr</code>) as, this is something new, the size y parameter (<code class="markup--code markup--p-code">sz_y</code>) [<a href="https://youtu.be/nG3tT31nPmQ?t=20m58s" data-href="https://youtu.be/nG3tT31nPmQ?t=20m58s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">20:58</a>]. So the two bits are going to get different sizes.</p><figure name="7cd3" id="7cd3" class="graf graf--figure graf--layoutOutsetCenter graf-after--p" data-scroll="native"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_7-vIZ1E_I3mvI59kTj_sVQ.png"></figure><p name="7584" id="7584" class="graf graf--p graf-after--figure">Here you can see the two different resolutions of our <em class="markup--em markup--p-em">x</em> and our <em class="markup--em markup--p-em">y</em> for a whole bunch of fish.</p><pre name="fd45" id="fd45" class="graf graf--pre graf-after--p">idx=1<br>fig,axes = plt.subplots(1, 2, figsize=(9,5))<br>show_img(x,idx, ax=axes[0])<br>show_img(y,idx, ax=axes[1])</pre><figure name="7aa7" id="7aa7" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_vPyOJ9-D-s2gzRhraY21YA.png"></figure><p name="2b89" id="2b89" class="graf graf--p graf-after--figure">As per usual, <code class="markup--code markup--p-code">plt.subplots</code> to create our two plots and then we can just use the different axes that came back to put stuff next to each other.</p><pre name="6a1b" id="6a1b" class="graf graf--pre graf-after--p">batches = [next(iter(md.aug_dl)) <strong class="markup--strong markup--pre-strong">for</strong> i <strong class="markup--strong markup--pre-strong">in</strong> range(9)]</pre><p name="f6ce" id="f6ce" class="graf graf--p graf-after--pre">We can then have a look at a few different versions of the data transformation [<a href="https://youtu.be/nG3tT31nPmQ?t=21m37s" data-href="https://youtu.be/nG3tT31nPmQ?t=21m37s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">21:37</a>]. There you can see them being flipped in all different directions.</p><pre name="8960" id="8960" class="graf graf--pre graf-after--p">fig, axes = plt.subplots(3, 6, figsize=(18, 9))<br><strong class="markup--strong markup--pre-strong">for</strong> i,(x,y) <strong class="markup--strong markup--pre-strong">in</strong> enumerate(batches):<br>    show_img(x,idx, ax=axes.flat[i*2])<br>    show_img(y,idx, ax=axes.flat[i*2+1])</pre><figure name="d73b" id="d73b" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_9OOex0WAIoQPqzT6SwvW8g.png"></figure><h4 name="1415" id="1415" class="graf graf--h4 graf-after--figure">Model [<a href="https://youtu.be/nG3tT31nPmQ?t=21m48s" data-href="https://youtu.be/nG3tT31nPmQ?t=21m48s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">21:48</a>]</h4><p name="ef39" id="ef39" class="graf graf--p graf-after--h4">Let’s create our model. We are going to have a small image coming in, and we want to have a big image coming out. So we need to do some computation between those two to calculate what the big image would look like. Essentially there’re two ways of doing that computation:</p><ul class="postList"><li name="c25a" id="c25a" class="graf graf--li graf-after--p">We could first of all do some upsampling and then do a few stride one layers to do lots of computation.</li><li name="af3a" id="af3a" class="graf graf--li graf-after--li">We could first do lots of stride one layers to do all the computation and then at the end do some upsampling.</li></ul><p name="9b8f" id="9b8f" class="graf graf--p graf-after--li">We are going to pick the second approach because we want to do lots of computation on something smaller because it’s much faster to do it that way. Also, all that computation we get to leverage during the upsampling process. Upsampling, we know a couple of possible ways to do that. We can use:</p><ul class="postList"><li name="55d6" id="55d6" class="graf graf--li graf-after--p">Transposed or fractionally strided convolutions</li><li name="2aa1" id="2aa1" class="graf graf--li graf-after--li">Nearest neighbor upsampling followed by a 1x1 conv</li></ul><p name="ff45" id="ff45" class="graf graf--p graf-after--li">And in “do lots of computation” section, we could just have a whole bunch of 3x3 convs. But in this case particular, it seems likely that ResNet blocks are going to be better because really the output and the input are very very similar. So we really want a flow through path that allows as little fussing around as possible except a minimal amount necessary to do our super resolution. If we use ResNet blocks, then they have an identity path already. So you can imagine those simple version where it does a bilinear sampling approach or something it could just go through identity block all the way through and then in the upsampling blocks, just learn to take the averages of the inputs and get something that’s not too terrible.</p><p name="fc59" id="fc59" class="graf graf--p graf-after--p">So that’s what we are going to do. We are going to create something with five ResNet blocks and then for each 2x scale up we have to do, we’ll have one upsampling block.</p><figure name="6523" id="6523" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_d6GkM4JtsJb3WHmTA5NLUg.png"></figure><p name="824c" id="824c" class="graf graf--p graf-after--figure">They are all going to consist of, as per usual, convolution layers possibly with activation functions after many of them [<a href="https://youtu.be/nG3tT31nPmQ?t=24m37s" data-href="https://youtu.be/nG3tT31nPmQ?t=24m37s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">24:37</a>]. I like to put my standard convolution block into a function so I can refactor it more easily. I won’t worry about passing in padding and just calculate it directly as kernel size over two.</p><pre name="e738" id="e738" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">def</strong> conv(ni, nf, kernel_size=3, actn=<strong class="markup--strong markup--pre-strong">False</strong>):<br>    layers = [nn.Conv2d(ni, nf, kernel_size, <br>              padding=kernel_size//2)]<br>    <strong class="markup--strong markup--pre-strong">if</strong> actn: layers.append(nn.ReLU(<strong class="markup--strong markup--pre-strong">True</strong>))<br>    <strong class="markup--strong markup--pre-strong">return</strong> nn.Sequential(*layers)</pre><p name="621b" id="621b" class="graf graf--p graf-after--pre">One interesting thing about our little conv block is that there is no batch norm which is pretty unusual for ResNet type models.</p><figure name="aeae" id="aeae" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_rMC3ob6YdywFeTHcAruD_A.png"><figcaption class="imageCaption"><a href="https://arxiv.org/abs/1707.02921" data-href="https://arxiv.org/abs/1707.02921" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://arxiv.org/abs/1707.02921</a></figcaption></figure><p name="f7e1" id="f7e1" class="graf graf--p graf-after--figure">The reason there is no batch norm is because I’m stealing ideas from this fantastic recent paper which actually won a recent competition in super resolution performance. To see how good this paper is, SRResNet is the previous state of the art and what they’ve done here is they’ve zoomed way in to an upsampled mesh/fence. HR is the original. You can see in the previous best approach, there’s a whole lot of distortion and blurring going on. Or else, in their approach, it’s nearly perfect. So this paper was a really big step-up. They call their model EDSR ( Enhanced Deep Super-Resolution network) and they did two things differently to the previous standard approaches:</p><ol class="postList"><li name="6bee" id="6bee" class="graf graf--li graf-after--p">Take the ResNet blocks and throw away the batch norms. Why would they throw away the batch norm? The reason is because batch norm changes stuff and we want a nice straight through path that doesn’t change stuff. So the idea here is if you don’t want to fiddle with the input more than you have to, then don’t force it to have to calculate things like batch norm parameters — so throw away the batch norm.</li><li name="6c67" id="6c67" class="graf graf--li graf-after--li">Scaling factor (we will see shortly).</li></ol><pre name="99ed" id="99ed" class="graf graf--pre graf-after--li"><strong class="markup--strong markup--pre-strong">class</strong> <strong class="markup--strong markup--pre-strong">ResSequential</strong>(nn.Module):<br>    <strong class="markup--strong markup--pre-strong">def</strong> __init__(self, layers, res_scale=1.0):<br>        super().__init__()<br>        self.res_scale = res_scale<br>        self.m = nn.Sequential(*layers)<br><br>    <strong class="markup--strong markup--pre-strong">def</strong> forward(self, x): <strong class="markup--strong markup--pre-strong">return</strong> x + self.m(x) * self.res_scale</pre><p name="e41d" id="e41d" class="graf graf--p graf-after--pre">So we are going to create a residual block containing two convolutions. As you see in their approach, they don’t even have a ReLU after their second conv. So that’s why I’ve only got activation on the first one.</p><pre name="064a" id="064a" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">def</strong> res_block(nf):<br>    <strong class="markup--strong markup--pre-strong">return</strong> ResSequential(<br>        [conv(nf, nf, actn=<strong class="markup--strong markup--pre-strong">True</strong>), conv(nf, nf)],<br>        0.1)</pre><p name="df6b" id="df6b" class="graf graf--p graf-after--pre">A couple of interesting things here [<a href="https://youtu.be/nG3tT31nPmQ?t=27m10s" data-href="https://youtu.be/nG3tT31nPmQ?t=27m10s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">27:10</a>]. One is that this idea of having some kind of a main ResNet path (conv, ReLU, conv) and then turning that into a ReLU block by adding it back to the identity — it’s something we do so often that I factored it out into a tiny little module called ResSequential. It simply takes a bunch of layers that you want to put into your residual path, turns that into a sequential model, runs it, and then adds it back to the input. With this little module, we can now turn anything, like conv activation conv, into a ResNet block just by wrapping in ResSequential.</p><p name="79d6" id="79d6" class="graf graf--p graf-after--p">But that’s not quite all I’m doing because normally a Res block just has <code class="markup--code markup--p-code">x + self.m(x)</code> in its <code class="markup--code markup--p-code">forward</code>. But I’ve also got <code class="markup--code markup--p-code">* self.res_scale</code>. What’s <code class="markup--code markup--p-code">res_scale</code>? <code class="markup--code markup--p-code">res_scale</code> is the number 0.1. Why is it there? I’m not sure anybody quite knows. But the short answer is that the guy who invented batch norm also somewhat more recently did a paper in which he showed for (I think) the first time the ability to train ImageNet in under an hour. The way he did it was fire up lots and lots of machines and have them work in parallel to create really large batch sizes. Now generally when you increase the batch size by order <em class="markup--em markup--p-em">N</em>, you also increase the learning rate by order <em class="markup--em markup--p-em">N</em> to go with it. So generally a very large batch size training means very high learning rate training as well. He found that with these very large batch sizes of 8,000+ or even up to 32,000, at the start of training, <span class="markup--quote markup--p-quote is-other" name="a289def0e1ff" data-creator-ids="eab3a535185e">his activations would basicall y go straight to infinity</span>. And a lot of other people have found that. We actually found that when we were competing in DAWN bench both on the CIFAR and ImageNet competitions that we really struggled to make the most of even the eight GPUs that we were trying to take advantage of because of these challenges with these larger batch sizes and taking advantage of them. Something Christian found was that in the ResNet blocks, if he multiplied them by some number smaller than 1, something like&nbsp;.1 or&nbsp;.2, it really helped stabilize training at the start. That’s kind of weird because mathematically, it’s identical. Because obviously whatever I’m multiplying it by here, I could just scale the weights by the opposite amount and have the same number. But we are not dealing with abstract math — we are dealing with real optimization problems, different initializations, learning rates, and whatever else. So the problem of weights disappearing off into infinity, I guess generally is really about the discrete and finite nature of computers in practice partly. So often these kind of little tricks can make the difference.</p><p name="782c" id="782c" class="graf graf--p graf-after--p">In this case, we are just toning things down based on our initial initialization. So there are probably other ways to do this. For example, one approach from some folks at Nvidia called LARS which I briefly mentioned last week is an approach which uses discriminative learning rates calculated in real time. Basically looking at the ration between the gradients and the activations to scale learning rates by layer. So they found that they didn’t need this trick to scale up the batch sizes a lot. Maybe a different initialization would be all that’s necessary. The reason I mentioned this is not so much because I think a lot of you are likely to want to train on massive clusters of computers but rather that I think a lot of you want to train models quickly and that means using high learning rates and ideally getting super convergence. I think these kinds of tricks are the tricks that we’ll need to be able to get super convergence across more different architectures and so forth. Other than Leslie Smith, no one else is really working on super convergence other than some fastai students nowadays. So these kind of things about how do we train at very very high learning rates, we’re going to have to be the ones who figure it out because as far as I can tell, nobody else cares yet. So looking at the literature around training ImageNet in one hour, or more recently there’s now train ImageNet in 15 minutes, these papers actually, I think, have some of the tricks to allow us to train things at high learning rates. So here is one of them.</p><p name="e80e" id="e80e" class="graf graf--p graf-after--p">Interestingly, other than the train ImageNet in one hour paper, the only other place I’ve seen this mentioned was in this EDSR paper. It’s really cool because people who win competitions, I find them to be very pragmatic and well-read. They actually have to get things to work. So this paper describes an approach which actually worked better than anybody else’s approach and they did these pragmatic things like throw away batch norm and use this little scaling factor which almost nobody seems to know about. So that’s where&nbsp;.1 comes from.</p><pre name="9c34" id="9c34" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">def</strong> upsample(ni, nf, scale):<br>    layers = []<br>    <strong class="markup--strong markup--pre-strong">for</strong> i <strong class="markup--strong markup--pre-strong">in</strong> range(int(math.log(scale,2))):<br>        layers += [conv(ni, nf*4), nn.PixelShuffle(2)]<br>    <strong class="markup--strong markup--pre-strong">return</strong> nn.Sequential(*layers)</pre><p name="a5d2" id="a5d2" class="graf graf--p graf-after--pre">So basically our super-resolution ResNet (<code class="markup--code markup--p-code">SrResnet</code>) is going to do a convolution to go from our three channels to 64 channels just to richen up the space a little bit [<a href="https://youtu.be/nG3tT31nPmQ?t=33m25s" data-href="https://youtu.be/nG3tT31nPmQ?t=33m25s" class="markup--anchor markup--p-anchor" rel="noopener nofollow" target="_blank">33:25</a>]. Then also we’ve got actually 8 not 5 Res blocks. Remember, every one of these Res block is stride 1 so the grid size doesn’t change, the number of filters doesn’t change. It’s just 64 all the way through. We’ll do one more convolution, and then we’ll do our upsampling by however much scale we asked for. Then something I’ve added which is one batch norm here because it felt like it might be helpful just to scale the last layer. Then finally conv to go back to the three channels we want. So you can see that here’s lots and lots of computation and then a little bit of upsampling just like we described.</p><pre name="0e18" id="0e18" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">class</strong> <strong class="markup--strong markup--pre-strong">SrResnet</strong>(nn.Module):<br>    <strong class="markup--strong markup--pre-strong">def</strong> __init__(self, nf, scale):<br>        super().__init__()<br>        features = [conv(3, 64)]<br>        <strong class="markup--strong markup--pre-strong">for</strong> i <strong class="markup--strong markup--pre-strong">in</strong> range(8): features.append(res_block(64))<br>        features += [conv(64,64), upsample(64, 64, scale),<br>                     nn.BatchNorm2d(64),<br>                     conv(64, 3)]<br>        self.features = nn.Sequential(*features)<br>        <br>    <strong class="markup--strong markup--pre-strong">def</strong> forward(self, x): <strong class="markup--strong markup--pre-strong">return</strong> self.features(x)</pre><p name="f28f" id="f28f" class="graf graf--p graf-after--pre">Just to mention, as I’m tending to do now, this whole thing is done by creating a list with layers and then at the end, turning into a sequential model so my forward function is as simple as can be.</p><p name="0412" id="0412" class="graf graf--p graf-after--p">Here is our upsampling and upsampling is a bit interesting because it is not doing either of two things (transposed or fractionally strided convolutions or nearest neighbor upsampling followed by a 1x1 conv). So let’s talk a bit about upsampling.</p><figure name="8a1e" id="8a1e" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_he7T9_w-2Q2wo0jgno5Qfg.png"></figure><p name="8c42" id="8c42" class="graf graf--p graf-after--figure">Here is the picture from the paper (Perceptual Losses for Real-Time Style Transfer and Super Resolution). So they are saying “hey, our approach is so much better” but look at their approach. It’s got artifacts in it. These just pop up everywhere, don’t they. One of the reason for this is that they use transposed convolutions and we all know don’t use transposed convolutions.</p><figure name="d819" id="d819" class="graf graf--figure graf--layoutOutsetCenter graf-after--p" data-scroll="native"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_s9IHmwTn9La0u0M8omsd2w.png"></figure><p name="53f0" id="53f0" class="graf graf--p graf-after--figure">Here are transposed convolutions [<a href="https://youtu.be/nG3tT31nPmQ?t=35m39s" data-href="https://youtu.be/nG3tT31nPmQ?t=35m39s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">35:39</a>]. This is from this fantastic convolutional arithmetic paper that was shown also in the Theano docs. If we are going from (blue is the original image) 3x3 image up to a 5x5 image (6x6 if we added a layer of padding), then all a transpose convolution does is it uses a regular 3x3 conv but it sticks white zero pixels between every pair of pixels. That makes the input image bigger and when we run this convolution over it, therefore gives us a larger output. But that’s obviously stupid because when we get here, for example, of the nine pixels coming in, eight of them are zero. So we are just wasting a whole a lot of computation. On the other hand, if we are slightly off then four of our nine are non-zero. But yet, we only have one filter/kernel to use so it can’t change depending on how many zeros are coming in. So it has to be suitable for both and it’s just not possible so we end up with these artifacts.</p><figure name="e093" id="e093" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_afBXEvE8aOwzNjRNb5bt6Q.png"><figcaption class="imageCaption"><a href="http://deeplearning.net/software/theano/tutorial/conv_arithmetic.html" data-href="http://deeplearning.net/software/theano/tutorial/conv_arithmetic.html" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">http://deeplearning.net/software/theano/tutorial/conv_arithmetic.html</a></figcaption></figure><p name="baa4" id="baa4" class="graf graf--p graf-after--figure">One approach we’ve learnt to make it a bit better is to not put white things here but instead to copy the pixel’s value to each of these three locations [<a href="https://youtu.be/nG3tT31nPmQ?t=36m53s" data-href="https://youtu.be/nG3tT31nPmQ?t=36m53s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">36:53</a>]. So that’s a nearest neighbor upsampling. That’s certainly a bit better, but it’s still pretty crappy because now when we get to these nine (as shown above), 4 of them are exactly the same number. And when we move across one, then now we’ve got a different situation entirely. So depending on where we are, in particular, if we are here, there’s going to be a lot less repetition:</p><figure name="b592" id="b592" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_uOVWwijHzuyf8IY4g6lKhQ.png"></figure><p name="c4a0" id="c4a0" class="graf graf--p graf-after--figure">So again, we have this problem where there’s wasted computation and too much structure in the data, and it’s going to lead to artifacts again. So upsampling is better than transposed convolutions — it’s better to copy them rather than replace them with zero. But it’s still not quite good enough.</p><p name="ed11" id="ed11" class="graf graf--p graf-after--p">So instead, we are going to do the pixel shuffle [<a href="https://youtu.be/nG3tT31nPmQ?t=37m56s" data-href="https://youtu.be/nG3tT31nPmQ?t=37m56s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">37:56</a>]. Pixel shuffle is an operation in this sub-pixel convolutional neural network and it’s a little bit mind-bending but it’s kind of fascinating.</p><figure name="b087" id="b087" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_Yj-niImdJg30IKlk0aBJFQ.png"><figcaption class="imageCaption"><a href="https://arxiv.org/abs/1609.05158" data-href="https://arxiv.org/abs/1609.05158" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank"><strong class="markup--strong markup--figure-strong">Real-Time Single Image and Video Super-Resolution Using an Efficient Sub-Pixel Convolutional Neural&nbsp;Network</strong></a></figcaption></figure><p name="6ffc" id="6ffc" class="graf graf--p graf-after--figure">We start with our input, we go through some convolutions to create some feature maps for a while until eventually we get to layer <em class="markup--em markup--p-em">n[i-1]</em> which has n[i-1] feature maps. We are going to do another 3x3 conv and our goal here is to go from a 7x7 grid cell (we’re going to do a 3x3 upscaling) so we are going to go up to a 21x21 grid cell. So what’s another way we could do that? To make it simpler, let’s just pick one face/layer- so let’s take the top most filter and just do a convolution over that just to see what happens. What we are going to do is we are going to use a convolution where the kernel size (the number of filters) is nine times bigger than we need (strictly speaking). So if we needed 64 filters, we are actually going to do 64 times 9 filters. Why? Here, r is the the scale factor so 3² is 9, so here are the nine filters to cover one of these input layers/slices. But what we can do is we started with 7x7, and we turned it into 7x7x9. The output that we want is equal to 7 times 3 by 7 times 3. In other words, there is an equal number of pixels/activations here as there are activations in the previous step. So we can literally re-shuffle these 7x7x9 activations to create this 7x3 by 7x3 map [<a href="https://youtu.be/nG3tT31nPmQ?t=40m16s" data-href="https://youtu.be/nG3tT31nPmQ?t=40m16s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">40:16</a>]. So what we are going to do is we’re going to take one little tube here (all the top left hand of each grid) and we are going to put the purple one up in the top left, then the blue one one to the right, and light blue one on to the right of that, then the slightly darker one in the middle of the far left, the green one in the middle, and so forth. So each of these nine cells in the top left, they are going to end up in the little 3x3 section of our grid. Then we are going to take (2, 1) and take all of those 9 and more them to these 3x3 part of the grid and so on. So we are going to end up having every one of these 7x7x9 activations inside the 7x3 by 7x3 image.</p><p name="4149" id="4149" class="graf graf--p graf-after--p">So the first thing to realize is yes of course this works under some definition of works because we have a learnable convolution here and it’s going to get some gradients which is going to do the best job it can of filling in the correct activation such that this output is the thing we want. So the first step is to realize there’s nothing particularly magical here. We can create any architecture we like. We can move things around anyhow we want to and our weights in the convolution will do their best to do all we asked. The real question is — is it good idea? Is this an easier thing for it to do and a more flexible thing for it to do than the transposed convolution or the upsampling followed by one by one conv? The short answer is yes it is, and the reason it’s better in short is that the convolution here is happening in the low resolution 7x7 space which is quite efficient. Or else, if we first of all upsampled and then did our conv then our conv would be happening in the 21 by 21 space which is a lot of computation. Furthermore, as we discussed, there’s a lot of replication and redundancy in the nearest neighbor upsample version. They actually show in this paper, in fact, I think they have a follow-up technical note where they provide some more mathematical details as to exactly what work is being done and show that the work really is more efficient this way. So that’s what we are going to do. For our upsampling, we have two steps:</p><ol class="postList"><li name="dd15" id="dd15" class="graf graf--li graf-after--p">3x3 conv with <em class="markup--em markup--li-em">r</em>² times more channels than we originally wanted</li><li name="c78c" id="c78c" class="graf graf--li graf-after--li">Then a pixel shuffle operation which moves everything in each grid cell into the little <em class="markup--em markup--li-em">r</em> by <em class="markup--em markup--li-em">r</em> grids that are located through out here.</li></ol><p name="a91b" id="a91b" class="graf graf--p graf-after--li">So here it is:</p><figure name="3341" id="3341" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_he7T9_w-2Q2wo0jgno5Qfg.png"></figure><p name="d039" id="d039" class="graf graf--p graf-after--figure">It’s one line of code. Here is a conv with number of in to number of filters out times four because we are doing a scale two upsample (2²=4). That’s our convolution and then here is our pixel shuffle it’s built into PyTorch. Pixel shuffle is the thing that moves each thing into its right spot. So that will upsample by a scale factor of 2. So we need to do that log base 2 scale times. If scale is four, then we’ll do two times to go two times two. So that’s what this upsample here does.</p><h4 name="1f51" id="1f51" class="graf graf--h4 graf-after--p">Checkerboard pattern&nbsp;[<a href="https://youtu.be/nG3tT31nPmQ?t=44m19s" data-href="https://youtu.be/nG3tT31nPmQ?t=44m19s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">44:19</a>]</h4><p name="a78d" id="a78d" class="graf graf--p graf-after--h4">Great. Guess what. That does not get rid of the checkerboard patterns. We still have checkerboard patterns. So I’m sure in great fury and frustration, the same team from Twitter I think this is back when they used to be a startup called magic pony that Twitter bought came back again with another paper saying okay, this time we’ve got rid of the checkerboard.</p><figure name="f7b0" id="f7b0" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_GHf4mB-n_o6owwX6MoY_NQ.png"><figcaption class="imageCaption"><a href="https://arxiv.org/abs/1707.02937" data-href="https://arxiv.org/abs/1707.02937" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://arxiv.org/abs/1707.02937</a></figcaption></figure><p name="03b1" id="03b1" class="graf graf--p graf-after--figure">Why do we still have a checkerboard? The reason we still have a checkerboard even after doing this is that when we randomly initialize this convolutional kernel at the start, it means that each of these 9 pixels in this little 3x3 grid over here are going to be totally randomly different. But then the next set of 3 pixels will be randomly different to each other but will be very similar to their corresponding pixel in the previous 3x3 section. So we are going to have repeating 3x3 things all the way across. Then as we try to learn something better, it’s starting from this repeating 3x3 starting point which is not what we want. What we actually would want is for these 3x3 pixels to be the same to start with. To make these 3x3 pixels the same, we would need to make these 9 channels the same here for each filter. So the solution in this paper is very simple. It’s that when we initialize this convolution at start when we randomly initialize it, we don’t totally randomly initialize it. We randomly initialize one of the <em class="markup--em markup--p-em">r</em>² sets of channels then we copy that to the other <em class="markup--em markup--p-em">r</em>² so they are all the same. That way, initially, each of these 3x3 will be the same. So that is called ICNR and that’s what we are going to use in a moment.</p><h4 name="686e" id="686e" class="graf graf--h4 graf-after--p">Pixel loss&nbsp;[<a href="https://youtu.be/nG3tT31nPmQ?t=46m41s" data-href="https://youtu.be/nG3tT31nPmQ?t=46m41s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">46:41</a>]</h4><p name="759e" id="759e" class="graf graf--p graf-after--h4">Before we do, let’s take a quick look. So we’ve got this super resolution ResNet which just does lots of computation with lots of ResNet blocks and then it does some upsampling and gets our final three channels out.</p><p name="ef25" id="ef25" class="graf graf--p graf-after--p">Then to make life faster, we are going to run tins in parallel. One reason we want to run it in parallel is because Gerardo told us that he has 6 GPUs and this is what his computer looks like right now.</p><figure name="0599" id="0599" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_rPTiAdy8iIVV3twfOG7mHg.png"></figure><p name="8d51" id="8d51" class="graf graf--p graf-after--figure">So I’m sure anybody who has more than one GPU has had this experience before. So how do we get these men working together? All you need to do is to take your PyTorch module and wrap it with <code class="markup--code markup--p-code">nn.DataParallel</code>. Once you’ve done that, it copies it to each of your GPUs and will automatically run it in parallel. It scales pretty well to two GPUs, okay to three GPUs, better than nothing to four GPUs and beyond that, performance does go backwards. By default, it will copy it to all of your GPUs — you can add an array of GPUs otherwise if you want to avoid getting in trouble, for example, I have to share our box with Yannet and if I didn’t put this here, then she would be yelling at me right now or boycotting my class. So this is how you avoid getting into trouble with Yannet.</p><pre name="7cbd" id="7cbd" class="graf graf--pre graf-after--p">m = to_gpu(SrResnet(64, scale))<br>m = nn.DataParallel(m, [0,2])<br>learn = Learner(md, SingleModel(m), opt_fn=optim.Adam)<br>learn.crit = F.mse_loss</pre><p name="cece" id="cece" class="graf graf--p graf-after--pre">One thing to be aware of here is that once you do this, it actually modifies your module [<a href="https://youtu.be/nG3tT31nPmQ?t=48m21s" data-href="https://youtu.be/nG3tT31nPmQ?t=48m21s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">48:21</a>]. So if you now print out your module, let’s say previously it was just an endless sequential, now you’ll find it’s an <code class="markup--code markup--p-code">nn.Sequential </code>embedded inside a module called <code class="markup--code markup--p-code">Module</code>. In other words, if you save something which you had <code class="markup--code markup--p-code">nn.DataParallel</code> and then tried and load it back into something you haven’t <code class="markup--code markup--p-code">nn.DataParallel</code>, it’ll say it doesn’t match up because one of them is embedded inside this Module attribute and the other one isn’t. It may also depend even on which GPU IDs you have had it copy to. Two possible solutions:</p><ol class="postList"><li name="e8cc" id="e8cc" class="graf graf--li graf-after--p">Don’t save the module <code class="markup--code markup--li-code">m</code> but instead save the module attribute <code class="markup--code markup--li-code">m.module</code> because that’s actually the non data parallel bit.</li><li name="1f19" id="1f19" class="graf graf--li graf-after--li">Always put it on the same GPU IDs and then use data parallel and load and save that every time. That’s what I was using.</li></ol><p name="7ef5" id="7ef5" class="graf graf--p graf-after--li">This is an easy thing for me to fix automatically in fast.ai and I’ll do it pretty soon so it will look for that module attribute and deal with it automatically. But for now, we have to do it manually. It’s probably useful to know what’s going on behind the scenes anyway.</p><p name="87f6" id="87f6" class="graf graf--p graf-after--p">So we’ve got our module [<a href="https://youtu.be/nG3tT31nPmQ?t=49m46s" data-href="https://youtu.be/nG3tT31nPmQ?t=49m46s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">49:46</a>]. I find it’ll run 50 or 60% faster on a 1080Ti if you are running on volta, it actually parallelize a bit better. There are much faster ways to parallelize but this is a super easy way.</p><p name="5327" id="5327" class="graf graf--p graf-after--p">We create our learner in the usual way. We can use MSE loss here so that’s just going to compare the pixels of the output to the pixels that we expected. We can run our learning rate finder and we can train it for a while.</p><pre name="9d98" id="9d98" class="graf graf--pre graf-after--p">learn.lr_find(start_lr=1e-5, end_lr=10000)<br>learn.sched.plot()</pre><pre name="16cd" id="16cd" class="graf graf--pre graf-after--pre">31%|███▏      | 225/720 [00:24&lt;00:53,  9.19it/s, loss=0.0482]</pre><figure name="e25a" id="e25a" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_3NGCeWjks8iCWo97ag8KgQ.png"></figure><pre name="9825" id="9825" class="graf graf--pre graf-after--figure">lr=2e-3</pre><pre name="6465" id="6465" class="graf graf--pre graf-after--pre">learn.fit(lr, 1, cycle_len=1, use_clr_beta=(40,10))</pre><pre name="3614" id="3614" class="graf graf--pre graf-after--pre">2%|▏         | 15/720 [00:02&lt;01:52,  6.25it/s, loss=0.042]  <br>epoch      trn_loss   val_loss                                 <br>    0      0.007431   0.008192</pre><pre name="4ceb" id="4ceb" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">[array([0.00819])]</em></pre><pre name="e978" id="e978" class="graf graf--pre graf-after--pre">x,y = next(iter(md.val_dl))<br>preds = learn.model(VV(x))</pre><p name="2b51" id="2b51" class="graf graf--p graf-after--pre">Here is our input:</p><pre name="8437" id="8437" class="graf graf--pre graf-after--p">idx=4<br>show_img(y,idx,normed=<strong class="markup--strong markup--pre-strong">False</strong>)</pre><figure name="a115" id="a115" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_eLOmwY4FKA-XU1MjNlw2PA.png"></figure><p name="35a2" id="35a2" class="graf graf--p graf-after--figure">And here is our output.</p><pre name="5498" id="5498" class="graf graf--pre graf-after--p">show_img(preds,idx,normed=<strong class="markup--strong markup--pre-strong">False</strong>);</pre><figure name="7610" id="7610" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_qHj8r-MMhw_koKNxyNFKxQ.png"></figure><p name="b775" id="b775" class="graf graf--p graf-after--figure">And you can see that what we’ve managed to do is to train a very advanced residual convolutional network that’s learnt to blue things. Why is that? Well, because it’s what we asked for. We said to minimize MSE loss. MSE loss between pixels really the best way to do that is just average the pixel i.e. to blur it. So that’s why pixel loss is no good. So we want to use our perceptual loss.</p><pre name="ddf6" id="ddf6" class="graf graf--pre graf-after--p">show_img(x,idx,normed=<strong class="markup--strong markup--pre-strong">True</strong>);</pre><figure name="29b8" id="29b8" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_c2wlq6d0wuNB2xIjaRMcZw.png"></figure><pre name="7438" id="7438" class="graf graf--pre graf-after--figure">x,y = next(iter(md.val_dl))<br>preds = learn.model(VV(x))</pre><pre name="e8b7" id="e8b7" class="graf graf--pre graf-after--pre">show_img(y,idx,normed=<strong class="markup--strong markup--pre-strong">False</strong>)</pre><figure name="6ab9" id="6ab9" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_MEYmY0bflI07lSFsEDMS4Q.png"></figure><pre name="5836" id="5836" class="graf graf--pre graf-after--figure">show_img(preds,idx,normed=<strong class="markup--strong markup--pre-strong">False</strong>);</pre><figure name="7822" id="7822" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_34ihffYGeiFCpgaWIcDOjw.png"></figure><pre name="b3e3" id="b3e3" class="graf graf--pre graf-after--figure">show_img(x,idx);</pre><figure name="6693" id="6693" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_SLZNRUiVAoakl-7YKNuqyw.png"></figure><h4 name="6ba2" id="6ba2" class="graf graf--h4 graf-after--figure">Perceptual loss&nbsp;[50:57]</h4><p name="c03f" id="c03f" class="graf graf--p graf-after--h4">With perceptual loss, we are basically going to take our VGG network and just like we did last week, we are going to find the block index just before we get a maxpool.</p><pre name="69e2" id="69e2" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">def</strong> icnr(x, scale=2, init=nn.init.kaiming_normal):<br>    new_shape = [int(x.shape[0] / (scale ** 2))] + list(x.shape[1:])<br>    subkernel = torch.zeros(new_shape)<br>    subkernel = init(subkernel)<br>    subkernel = subkernel.transpose(0, 1)<br>    subkernel = subkernel.contiguous().view(subkernel.shape[0],<br>                                            subkernel.shape[1], -1)<br>    kernel = subkernel.repeat(1, 1, scale ** 2)<br>    transposed_shape = [x.shape[1]] + [x.shape[0]] + <br>                          list(x.shape[2:])<br>    kernel = kernel.contiguous().view(transposed_shape)<br>    kernel = kernel.transpose(0, 1)<br>    <strong class="markup--strong markup--pre-strong">return</strong> kernel</pre><pre name="8869" id="8869" class="graf graf--pre graf-after--pre">m_vgg = vgg16(<strong class="markup--strong markup--pre-strong">True</strong>)<br><br>blocks = [i-1 <strong class="markup--strong markup--pre-strong">for</strong> i,o <strong class="markup--strong markup--pre-strong">in</strong> enumerate(children(m_vgg))<br>              <strong class="markup--strong markup--pre-strong">if</strong> isinstance(o,nn.MaxPool2d)]<br>blocks, [m_vgg[i] <strong class="markup--strong markup--pre-strong">for</strong> i <strong class="markup--strong markup--pre-strong">in</strong> blocks]</pre><pre name="4f3c" id="4f3c" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">([5, 12, 22, 32, 42],<br> [ReLU(inplace), ReLU(inplace), ReLU(inplace), ReLU(inplace), ReLU(inplace)])</em></pre><p name="eac5" id="eac5" class="graf graf--p graf-after--pre">So here are the ends of each block of the same grid size. If we just print them out, as we’d expect, every one of those is a ReLU module and so in this case these last two blocks are less interesting to us. The grid size there is small enough, and course enough that it’s not as useful for super resolution. So we are just going to use the first three. Just to save unnecessary computation, we are just going to use those first 23 layers of VGG and we’ll throw away the rest. We’ll stick it on the GPU. We are not going to be training this VGG model at all — we are just using it to compare activations. So we’ll stick it in eval mode and we will set it to not trainable.</p><pre name="c557" id="c557" class="graf graf--pre graf-after--p">vgg_layers = children(m_vgg)[:23]<br>m_vgg = nn.Sequential(*vgg_layers).cuda().eval()<br>set_trainable(m_vgg, <strong class="markup--strong markup--pre-strong">False</strong>)</pre><pre name="0d0e" id="0d0e" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">def</strong> flatten(x): <strong class="markup--strong markup--pre-strong">return</strong> x.view(x.size(0), -1)</pre><p name="e74e" id="e74e" class="graf graf--p graf-after--pre">Just like last week, we will use <code class="markup--code markup--p-code">SaveFeatures</code> class to do a forward hook which saves the output activations at each of those layers [<a href="https://youtu.be/nG3tT31nPmQ?t=52m7s" data-href="https://youtu.be/nG3tT31nPmQ?t=52m7s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">52:07</a>].</p><pre name="2107" id="2107" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">class</strong> <strong class="markup--strong markup--pre-strong">SaveFeatures</strong>():<br>    features=<strong class="markup--strong markup--pre-strong">None</strong><br>    <strong class="markup--strong markup--pre-strong">def</strong> __init__(self, m): <br>        self.hook = m.register_forward_hook(self.hook_fn)<br>    <strong class="markup--strong markup--pre-strong">def</strong> hook_fn(self, module, input, output): self.features = output<br>    <strong class="markup--strong markup--pre-strong">def</strong> remove(self): self.hook.remove()</pre><p name="b62d" id="b62d" class="graf graf--p graf-after--pre">So now we have everything we need to create our perceptual loss or as I call it here <code class="markup--code markup--p-code">FeatureLoss</code> class. We are going to pass in a list of layer IDs, the layers where we want the content loss to be calculated, and a list of weights for each of those layers. We can go through each of those layer IDs and create an object which has the forward hook function to store the activations. So in our forward, then we can just go ahead and call the forward pass of our model with the target (high res image we are trying to create). The reason we do that is because that is going to then call that hook function and store in <code class="markup--code markup--p-code">self.sfs</code> (self dot save features) the activations we want. Now we are going to need to do that for our conv net output as well. So we need to clone these because otherwise the conv net output is going to go ahead and just clobber what I already had. So now we can do the same thing for the conv net output which is the input to the loss function. And so now we’ve got those two things we can zip them all together along with the weights so we’ve got inputs, targets, and weights. Then we can do the L1 loss between the inputs and the targets and multiply by the layer weights. The only other thing I do is I also grab the pixel loss, but I weight it down quite a bit. Most people don’t do this. I haven’t seen papers that do this, but in my opinion, it’s maybe a little bit better because you’ve got the perceptual content loss activation stuff but the really finest level it also cares about the individual pixels. So that’s our loss function.</p><pre name="8d19" id="8d19" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">class</strong> <strong class="markup--strong markup--pre-strong">FeatureLoss</strong>(nn.Module):<br>    <strong class="markup--strong markup--pre-strong">def</strong> __init__(self, m, layer_ids, layer_wgts):<br>        super().__init__()<br>        self.m,self.wgts = m,layer_wgts<br>        self.sfs = [SaveFeatures(m[i]) <strong class="markup--strong markup--pre-strong">for</strong> i <strong class="markup--strong markup--pre-strong">in</strong> layer_ids]<br><br>    <strong class="markup--strong markup--pre-strong">def</strong> forward(self, input, target, sum_layers=<strong class="markup--strong markup--pre-strong">True</strong>):<br>        self.m(VV(target.data))<br>        res = [F.l1_loss(input,target)/100]<br>        targ_feat = [V(o.features.data.clone()) <strong class="markup--strong markup--pre-strong">for</strong> o <strong class="markup--strong markup--pre-strong">in</strong> self.sfs]<br>        self.m(input)<br>        res += [F.l1_loss(flatten(inp.features),flatten(targ))*wgt<br>               <strong class="markup--strong markup--pre-strong">for</strong> inp,targ,wgt <strong class="markup--strong markup--pre-strong">in</strong> zip(self.sfs, targ_feat, <br>                                       self.wgts)]<br>        <strong class="markup--strong markup--pre-strong">if</strong> sum_layers: res = sum(res)<br>        <strong class="markup--strong markup--pre-strong">return</strong> res<br>    <br>    <strong class="markup--strong markup--pre-strong">def</strong> close(self):<br>        <strong class="markup--strong markup--pre-strong">for</strong> o <strong class="markup--strong markup--pre-strong">in</strong> self.sfs: o.remove()</pre><p name="7869" id="7869" class="graf graf--p graf-after--pre">We create our super resolution ResNet telling it how much to scale up by.</p><pre name="2af4" id="2af4" class="graf graf--pre graf-after--p">m = SrResnet(64, scale)</pre><p name="ce07" id="ce07" class="graf graf--p graf-after--pre">And then we are going to do our <code class="markup--code markup--p-code">icnr</code> initialization of that pixel shuffle convolution [<a href="https://youtu.be/nG3tT31nPmQ?t=54m27s" data-href="https://youtu.be/nG3tT31nPmQ?t=54m27s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">54:27</a>]. This is very boring code, I actually stole it from somebody else. Literally all it does is just say okay, you’ve got some weight tensor <code class="markup--code markup--p-code">x</code> that you want to initialize so we are going to treat it as if it has shape (i.e. number of features) divided by scale squared features in practice. So this might be 2² = 4 because we actually want to just keep one set of then and then copy them four times, so we divide it by four and we create something of that size and we initialize that with, by default, <code class="markup--code markup--p-code">kaiming_normal</code> initialization. Then we just make scale² copies of it. And the rest of it is just kind of moving axes around a little bit. So that’s going to return a new weight matrix where each initialized sub kernel is repeated r² or <code class="markup--code markup--p-code">scale</code>² times. So that details don’t matter very much. All that matters here is that I just looked through to find what was the actual conv layer just before the pixel shuffle and store it away and then I called <code class="markup--code markup--p-code">icnr</code> on its weight matrix to get my new weight matrix. And then I copied that new weight matrix back into that layer.</p><pre name="8b60" id="8b60" class="graf graf--pre graf-after--p">conv_shuffle = m.features[10][0][0]<br>kernel = icnr(conv_shuffle.weight, scale=scale)<br>conv_shuffle.weight.data.copy_(kernel);</pre><p name="f263" id="f263" class="graf graf--p graf-after--pre">As you can see, I went to quite a lot of trouble in this exercise to really try to implement all the best practices [<a href="https://youtu.be/nG3tT31nPmQ?t=56m13s" data-href="https://youtu.be/nG3tT31nPmQ?t=56m13s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">56:13</a>]. I tend to do things a bit one extreme or the other. I show you a really hacky version that only slightly works or I go to the <em class="markup--em markup--p-em">n</em>th degree to make it work really well. So this is a version where I’m claiming that this is pretty much a state of the art implementation. It’s a competition winning or at least my re-implementation of a competition winning approach. The reason I’m doing that is because I think this is one of those rare papers where they actually get a lot of the details right and I want you to get a feel of what it feels like to get all the details right. Remember, getting the details right is the difference between the hideous blurry mess and the pretty exquisite result.</p><pre name="454f" id="454f" class="graf graf--pre graf-after--p">m = to_gpu(m)</pre><pre name="7271" id="7271" class="graf graf--pre graf-after--pre">learn = Learner(md, SingleModel(m), opt_fn=optim.Adam)</pre><pre name="1a69" id="1a69" class="graf graf--pre graf-after--pre">t = torch.load(learn.get_model_path('sr-samp0'), <br>         map_location=<strong class="markup--strong markup--pre-strong">lambda</strong> storage, loc: storage)<br>learn.model.load_state_dict(t, strict=<strong class="markup--strong markup--pre-strong">False</strong>)</pre><pre name="f9af" id="f9af" class="graf graf--pre graf-after--pre">learn.freeze_to(999)</pre><pre name="b270" id="b270" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">for</strong> i <strong class="markup--strong markup--pre-strong">in</strong> range(10,13): set_trainable(m.features[i], <strong class="markup--strong markup--pre-strong">True</strong>)</pre><pre name="e76a" id="e76a" class="graf graf--pre graf-after--pre">conv_shuffle = m.features[10][2][0]<br>kernel = icnr(conv_shuffle.weight, scale=scale)<br>conv_shuffle.weight.data.copy_(kernel);</pre><p name="f3af" id="f3af" class="graf graf--p graf-after--pre">So we are going do DataParallel on that again [<a href="https://youtu.be/nG3tT31nPmQ?t=57m14s" data-href="https://youtu.be/nG3tT31nPmQ?t=57m14s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">57:14</a>].</p><pre name="c5ea" id="c5ea" class="graf graf--pre graf-after--p">m = nn.DataParallel(m, [0,2])<br>learn = Learner(md, SingleModel(m), opt_fn=optim.Adam)</pre><pre name="613e" id="613e" class="graf graf--pre graf-after--pre">learn.set_data(md)</pre><p name="1f2a" id="1f2a" class="graf graf--p graf-after--pre">We are going to set our criterion to be FeatureLoss using our VGG model, grab the first few blocks and these are sets of layer weights that I found worked pretty well.</p><pre name="3a8c" id="3a8c" class="graf graf--pre graf-after--p">learn.crit = FeatureLoss(m_vgg, blocks[:3], [0.2,0.7,0.1])</pre><pre name="eb82" id="eb82" class="graf graf--pre graf-after--pre">lr=6e-3<br>wd=1e-7</pre><p name="0739" id="0739" class="graf graf--p graf-after--pre">Do a learning rate finder.</p><pre name="66cc" id="66cc" class="graf graf--pre graf-after--p">learn.lr_find(1e-4, 0.1, wds=wd, linear=<strong class="markup--strong markup--pre-strong">True</strong>)</pre><pre name="059b" id="059b" class="graf graf--pre graf-after--pre"> 1%|          | 15/1801 [00:06&lt;12:55,  2.30it/s, loss=0.0965]<br>12%|█▏        | 220/1801 [01:16&lt;09:08,  2.88it/s, loss=0.42]</pre><pre name="736f" id="736f" class="graf graf--pre graf-after--pre">learn.sched.plot(n_skip_end=1)</pre><figure name="5156" id="5156" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_pFxZy5AKqmhC031Q6a71PQ.png"></figure><p name="60ec" id="60ec" class="graf graf--p graf-after--figure">Fit it for a while</p><pre name="f015" id="f015" class="graf graf--pre graf-after--p">learn.fit(lr, 1, cycle_len=2, wds=wd, use_clr=(20,10))</pre><pre name="9a5e" id="9a5e" class="graf graf--pre graf-after--pre">epoch      trn_loss   val_loss                                  <br>    0      0.04523    0.042932  <br>    1      0.043574   0.041242</pre><pre name="06bd" id="06bd" class="graf graf--pre graf-after--pre">[array([0.04124])]</pre><pre name="dc7e" id="dc7e" class="graf graf--pre graf-after--pre">learn.save('sr-samp0')</pre><pre name="0ba4" id="0ba4" class="graf graf--pre graf-after--pre">learn.save('sr-samp1')</pre><p name="efe3" id="efe3" class="graf graf--p graf-after--pre">And I fiddled around for a while trying to get some of these details right. But here is my favorite part of the paper is what happens next. Now that we’ve done it for scale equals 2 — progressive resizing. So progressive resizing is the trick that let us get the best best single computer result for ImageNet training on DAWN bench. It’s this idea of starting small gradually making bigger. I only know of two papers that have used this idea. One is the progressive resizing of GANs paper which allows training a very high resolution GANs and the other one is the EDSR paper. And the cool thing about progressive resizing is not only are your earlier epochs, assuming you’ve got 2x2 smaller, four times faster. You can also make the batch size maybe 3 or 4 times bigger. But more importantly, they are going to generalize better because you are feeding in your model different sized images during training. So we were able to train half as many epochs for ImageNet as most people. Our epochs were faster and there were fewer of them. So progressive resizing is something that, particularly if you are training from scratch (I’m not so sure if it’s useful for fine-tuning transfer learning, but if you are training from scratch), you probably want to do nearly all the time.</p><h4 name="ebe2" id="ebe2" class="graf graf--h4 graf-after--p">Progressive resizing&nbsp;[<a href="https://youtu.be/nG3tT31nPmQ?t=59m7s" data-href="https://youtu.be/nG3tT31nPmQ?t=59m7s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">59:07</a>]</h4><p name="16d2" id="16d2" class="graf graf--p graf-after--h4">So the next step is to go all the way back to the top and change to 4 scale, 32 batch size, restart. I saved the model before I do that.</p><figure name="5c8a" id="5c8a" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_Wm9cQuH2YuzT4zLdjFx5gQ.png"></figure><p name="43c2" id="43c2" class="graf graf--p graf-after--figure">Go back and that’s why there’s a little bit of fussing around in here with reloading because what I needed to do now is I needed to load my saved model back in.</p><figure name="2a1c" id="2a1c" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_sbHDTKhKUuuOqvDz8RayHw.png"></figure><p name="83e5" id="83e5" class="graf graf--p graf-after--figure">But there’s a slight issue which is I now have one more upsampling layer than I used to have to go from 2x2 to 4x4. My loop here is now looping through twice, not once. Therefore, it’s added an extra conv net and an extra pixel shuffle. So how am I going to load in weights for a different network?</p><figure name="eecb" id="eecb" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_bu5wo96iiUbwq3lfABmLSg.png"></figure><p name="ca0d" id="ca0d" class="graf graf--p graf-after--figure">The answer is that I use a very handy thing in PyTorch <code class="markup--code markup--p-code">load_state_dict</code>. This is what <code class="markup--code markup--p-code">lean.load</code> calls behind the scenes. If I pass this parameter <code class="markup--code markup--p-code">strict=False</code> then it says “okay, if you can’t fill in all of the layers, just fill in the layers you can.” So after loading the model back in this way, we are going to end up with something where it’s loaded in all the layers that it can and that one conv layer that’s new is going to be randomly initialized.</p><figure name="089c" id="089c" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_FJ6Ntp4aiKC1Lav6V4Q-9A.png"></figure><p name="63e9" id="63e9" class="graf graf--p graf-after--figure">Then I freeze all my layers and then unfreeze that upsampling part [<a href="https://youtu.be/nG3tT31nPmQ?t=1h45s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h45s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:00:45</a>] Then use <code class="markup--code markup--p-code">icnr</code> on my newly added extra layer. Then I can go ahead and learn again. So then the rest is the same.</p><p name="2c30" id="2c30" class="graf graf--p graf-after--p">If you are trying to replicate this, don’t just run this top to bottom. Realize it involves a bit of jumping around.</p><pre name="5d38" id="5d38" class="graf graf--pre graf-after--p">learn.load('sr-samp1')</pre><pre name="68f5" id="68f5" class="graf graf--pre graf-after--pre">lr=3e-3</pre><pre name="65e8" id="65e8" class="graf graf--pre graf-after--pre">learn.fit(lr, 1, cycle_len=1, wds=wd, use_clr=(20,10))</pre><pre name="581f" id="581f" class="graf graf--pre graf-after--pre">epoch      trn_loss   val_loss                                <br>    0      0.069054   0.06638</pre><pre name="6920" id="6920" class="graf graf--pre graf-after--pre">[array([0.06638])]</pre><pre name="25e8" id="25e8" class="graf graf--pre graf-after--pre">learn.save('sr-samp2')</pre><pre name="57ac" id="57ac" class="graf graf--pre graf-after--pre">learn.unfreeze()</pre><pre name="1cfa" id="1cfa" class="graf graf--pre graf-after--pre">learn.load('sr-samp2')</pre><pre name="fbdb" id="fbdb" class="graf graf--pre graf-after--pre">learn.fit(lr/3, 1, cycle_len=1, wds=wd, use_clr=(20,10))</pre><pre name="793d" id="793d" class="graf graf--pre graf-after--pre">epoch      trn_loss   val_loss           <br>    0      0.06042    0.057613</pre><pre name="0753" id="0753" class="graf graf--pre graf-after--pre">[array([0.05761])]</pre><pre name="f9ee" id="f9ee" class="graf graf--pre graf-after--pre">learn.save('sr1')</pre><pre name="79cb" id="79cb" class="graf graf--pre graf-after--pre">learn.sched.plot_loss()</pre><figure name="8120" id="8120" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_M7lOaEQaa21WBgAXVd8roQ.png"></figure><pre name="59d4" id="59d4" class="graf graf--pre graf-after--figure"><strong class="markup--strong markup--pre-strong">def</strong> plot_ds_img(idx, ax=<strong class="markup--strong markup--pre-strong">None</strong>, figsize=(7,7), normed=<strong class="markup--strong markup--pre-strong">True</strong>):<br>    <strong class="markup--strong markup--pre-strong">if</strong> ax <strong class="markup--strong markup--pre-strong">is</strong> <strong class="markup--strong markup--pre-strong">None</strong>: fig,ax = plt.subplots(figsize=figsize)<br>    im = md.val_ds[idx][0]<br>    <strong class="markup--strong markup--pre-strong">if</strong> normed: im = denorm(im)[0]<br>    <strong class="markup--strong markup--pre-strong">else</strong>:      im = np.rollaxis(to_np(im),0,3)<br>    ax.imshow(im)<br>    ax.axis('off')</pre><pre name="8443" id="8443" class="graf graf--pre graf-after--pre">fig,axes=plt.subplots(6,6,figsize=(20,20))<br><strong class="markup--strong markup--pre-strong">for</strong> i,ax <strong class="markup--strong markup--pre-strong">in</strong> enumerate(axes.flat): <br>    plot_ds_img(i+200,ax=ax, normed=<strong class="markup--strong markup--pre-strong">True</strong>)</pre><figure name="9b60" id="9b60" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_iQrT4lAb6bYt0s65aYEVsA.png"></figure><pre name="a1f1" id="a1f1" class="graf graf--pre graf-after--figure">x,y=md.val_ds[215]</pre><pre name="3959" id="3959" class="graf graf--pre graf-after--pre">y=y[<strong class="markup--strong markup--pre-strong">None</strong>]</pre><pre name="ed63" id="ed63" class="graf graf--pre graf-after--pre">learn.model.eval()<br>preds = learn.model(VV(x[<strong class="markup--strong markup--pre-strong">None</strong>]))<br>x.shape,y.shape,preds.shape</pre><pre name="77c1" id="77c1" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">((3, 72, 72), (1, 3, 288, 288), torch.Size([1, 3, 288, 288]))</em></pre><pre name="f39f" id="f39f" class="graf graf--pre graf-after--pre">learn.crit(preds, V(y), sum_layers=<strong class="markup--strong markup--pre-strong">False</strong>)</pre><pre name="5e53" id="5e53" class="graf graf--pre graf-after--pre">[Variable containing:<br> 1.00000e-03 *<br>   1.1935<br> [torch.cuda.FloatTensor of size 1 (GPU 0)], Variable containing:<br> 1.00000e-03 *<br>   8.5054<br> [torch.cuda.FloatTensor of size 1 (GPU 0)], Variable containing:<br> 1.00000e-02 *<br>   3.4656<br> [torch.cuda.FloatTensor of size 1 (GPU 0)], Variable containing:<br> 1.00000e-03 *<br>   3.8243<br> [torch.cuda.FloatTensor of size 1 (GPU 0)]]</pre><pre name="5bc5" id="5bc5" class="graf graf--pre graf-after--pre">learn.crit.close()</pre><p name="2bd7" id="2bd7" class="graf graf--p graf-after--pre">The longer you train, the better it gets [<a href="https://youtu.be/nG3tT31nPmQ?t=1h1m18s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h1m18s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:01:18</a>]. I ended up training it for about 10 hours, but you’ll still get very good results much more quickly if you’re less patient. So we can try it out and and here is the result. On the left is my pixelated bird and on the right is the upsampled version. It literally invented coloration. But it figured out what kind of bird it is, and it knows what these feathers are meant to look like. So it has imagined a set of feathers which are compatible with these exact pixels which is genius. Same for the back of its head. There is no way you can tell what these blue dots are meant to represent. But if you know that this kind of bird has an array of feathers here, you know that’s what they must be. Then you can figure out whether the feathers would have to be such that when they were pixelated they would end up in these spots. So it literally reverse engineered given its knowledge of this exact species of bird, how it would have to have looked to create this output. This is so amazing. It also knows from all the signs around it that this area here (background) was almost certainly blurred out. So it actually reconstructed blurred vegetation. If it hadn’t have done all of those things, it wouldn’t have gotten such a good loss function. Because in the end, it had to match the activations saying “oh, there’s a feather over here and it’s kind of fluffy looking and it’s in this direction” and all that.</p><pre name="e380" id="e380" class="graf graf--pre graf-after--p">_,axes=plt.subplots(1,2,figsize=(14,7))<br>show_img(x[<strong class="markup--strong markup--pre-strong">None</strong>], 0, ax=axes[0])<br>show_img(preds,0, normed=<strong class="markup--strong markup--pre-strong">True</strong>, ax=axes[1])</pre><figure name="e88c" id="e88c" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_wJTo6Q3kodiPLTyxaLDYZg.png"></figure><p name="ebce" id="ebce" class="graf graf--p graf-after--figure">Well, that brings us to the end of super resolution [<a href="https://youtu.be/nG3tT31nPmQ?t=1h3m18s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h3m18s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:03:18</a>]. Don’t forget to check out the <a href="http://forums.fast.ai/t/ask-jeremy-anything/15646/1" data-href="http://forums.fast.ai/t/ask-jeremy-anything/15646/1" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">ask Jeremy anything</a> thread.</p><h3 name="7f81" id="7f81" class="graf graf--h3 graf-after--p">Ask Jeremy&nbsp;Anything</h3><p name="b14e" id="b14e" class="graf graf--p graf-after--h3"><strong class="markup--strong markup--p-strong">Question</strong>: What are the future plans for fast.ai and this course? Will there be a part 3? If there is a part 3, I would really love to take it [<a href="https://youtu.be/nG3tT31nPmQ?t=1h4m11s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h4m11s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:04:11</a>].</p><p name="d99a" id="d99a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Jeremy</strong>: I’m not quite sure. It’s always hard to guess. I hope there will be some kind of follow-up. Last year, after part 2, one of the students started up a weekly book club going through the Ian Goodfellow deep learning book, and Ian actually came in and presented quite a few of the chapters and there was somebody, an expert, who presented every chapter. That was a really cool part 3. To a large extent, it will depend on you, the community, to come up with ideas and help make them happen, and I’m definitely keen to help. I’ve got a bunch of ideas but I’m nervous about saying them because I’m not sure which ones will happen and which ones won’t. But the more support I have in making things happen that you want to happen from you, the more likely they are to happen.</p><p name="f8fb" id="f8fb" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Question</strong>: What was your experience like starting down the path of entrepreneurship? Have you always been an entrepreneur or did you start at a big company and transition to a startup? Did you go from academia to startups or startups to academia? [<a href="https://youtu.be/nG3tT31nPmQ?t=1h5m13s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h5m13s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:05:13</a>]</p><p name="0962" id="0962" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Jeremy</strong>: No, I was definitely not an academia. I am totally a fake academic. I started at McKinsey and company which is a strategy firm when I was 18 which meant I couldn’t really go to university so it didn’t really turn up. Then spent 8 years in business helping really big companies on strategic questions. I always wanted to be an entrepreneur, planned to only spend two years in McKinsey, only thing I really regret in my life was not sticking to that plan and wasting eight years instead. So two years would have been perfect. But then I went into entrepreneurship, started two companies in Australia. The best part about that was that I didn’t get any funding so all the money that I made was mine or the decisions were mine and my partner’s. I focused entirely on profit and product and customer and service. Whereas I find in San Francisco, I’m glad I came here and so the two of us came here for Kaggle, Anthony and I, and raised ridiculous amount of money 11 million dollar for this really new company. That was really interesting but it’s also really distracting trying to worry about scaling and VC’s wanting to see what your business development plans are and also just not having any real need to actually make a profit. So I had a bit of the same problem at Enlitic where I again raised a lot of money 15 million dollars pretty quickly and a lot of distractions. I think trying to bootstrap your own company and focus on making money by selling something at a profit and then plowing that back into the company, it worked really well. Because within five years, we were making a profit from 3 months in and within 5 years, we were making enough for profit not just to pay all of us and our own wages but also to see my bank account growing and after 10 years sold it for a big chunk of money, not enough that a VC would be excited but enough that I didn’t have to worry about money again. So I think bootstrapping a company is something which people in the Bay Area at least don’t seem to appreciate how good of an idea that is.</p><p name="0cec" id="0cec" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Question</strong>: If you were 25 years old today and still know what you know where would you be looking to use AI? What are you working on right now or looking to work on in the next 2 years [<a href="https://youtu.be/nG3tT31nPmQ?t=1h8m10s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h8m10s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:08:10</a>]?</p><p name="9097" id="9097" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Jeremy</strong>: You should ignore the last part of that. I won’t even answer it. Doesn’t matter where I’m looking. What you should do is leverage your knowledge about your domain. So one of the main reasons we do this is to get people who have backgrounds in recruiting, oil field surveys, journalism, activism, whatever and solve your problems. It’ll be really obvious to you what real problems are and it will be really obvious to you what data you have and where to find it. Those are all the bits that for everybody else that’s really hard. So people who start out with “oh, I know deep learning now I’ll go and find something to apply it to” basically never succeed where else people who are like “oh, I’ve been spending 25 years doing specialized recruiting for legal firms and I know that the key issue is this thing and I know that this piece of data totally solves it and so I’m just going to do that now and I already know who to call or actually start selling it to”. They are the ones who tend to win. If you’ve done nothing but academic stuff, then it’s more maybe about your hobbies and interests. So everybody has hobbies. The main thing I would say is please don’t focus on building tools for data scientists to use or for software engineers to use because every data scientist knows about the market of data scientists whereas only you know about the market for analyzing oil survey world or understanding audiology studies or whatever it is that you do.</p><p name="5bd2" id="5bd2" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Question</strong>: Given what you’ve shown us about applying transfer learning from image recognition to NLP, there looks to be a lot of value in paying attention to all of the developments that happen across the whole ML field and that if you were to focus in one area you might miss out on some great advances in other concentrations. How do you stay aware of all of the advancements across the field while still having time to dig in deep to your specific domains [<a href="https://youtu.be/nG3tT31nPmQ?t=1h10m19s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h10m19s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:10:19</a>]?</p><p name="86ca" id="86ca" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Jeremy</strong>: Yeah, that’s awesome. I mean that’s one of the key messages of this course. Lots of good work’s being done in different places and people are so specialized and most people don’t know about it. If I can get state of the art results in NLP within six months of starting to look at NLP and I think that says more about NLP than it does about me, frankly. It’s kind of like the entrepreneurship thing. You pick the areas you see that you know about and kind of transfer stuff like “oh, we could use deep learning to solve this problem” or in this case, we could use this idea of computer vision to solve that problem. So things like transfer learning, I’m sure there’s like a thousand opportunities for you to do in other field to do what Sebastian and I did in NLP with NLP classification. So the short answer to your question is the way to stay ahead of what’s going on would be to follow my feed of Twitter favorites and my approach is to then follow lots and lots of people on Twitter and put them into the Twitter favorites for you. Literally, every time I come across something interesting, I click favorite. There are two reasons I do it. The first is that when the next course comes along, I go through my favorites to find which things I want to study. The second is so that you can do the same thing. And then which you go deep into, it almost doesn’t matter. I find every time I look at something it turns out to be super interesting and important. So pick something which you feel like solving that problem would be actually useful for some reason and it doesn’t seem to be very popular which is kind of the opposite of what everybody else does. Everybody else works on the problems which everybody else is already working on because they are the ones that seem popular. I can’t quite understand this train of thinking but it seems to be very common.</p><p name="adac" id="adac" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Question</strong>: Is Deep Learning an overkill to use on Tabular data? When is it better to use DL instead of ML on tabular data [<a href="https://youtu.be/nG3tT31nPmQ?t=1h12m46s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h12m46s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:12:46</a>]?</p><p name="a89a" id="a89a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Jeremy</strong>: Is that a real question or did you just put that there so that I would point out that Rachel Thomas just wrote an article? <a href="http://www.fast.ai/2018/04/29/categorical-embeddings/" data-href="http://www.fast.ai/2018/04/29/categorical-embeddings/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">http://www.fast.ai/2018/04/29/categorical-embeddings/</a></p><p name="efae" id="efae" class="graf graf--p graf-after--p">So Rachel has just written about this and Rachel and I spent a long time talking about it and the short answer is we think it’s great to use deep learning on tabular data. Actually, of all the rich complex important and interesting things that appear in Rachel’s Twitter stream covering everything from the genocide of Rohingya through to latest ethics violations in AI companies, the one by far that got the most attention and engagement from the community was the question about is it called tabular data or structured data. So yeah, ask computer people how to name things and you’ll get plenty of interest. There are some really good links here to stuff from Instacart and Pinterest and other folks who have done some good work in this area. Any of you that went to the Data Institute conference would have seen Jeremy Stanley’s presentation about the really cool work they did at Instacart.</p><p name="3be8" id="3be8" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Rachel</strong>: I relied heavily on lessons 3 and 4 from part 1 in writing this post so much of that may be familiar to you.</p><p name="354b" id="354b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Jeremy</strong>: Rachel asked me during the post like how to tell whether you should use the decision tree ensemble like GBM or random forest or neural net and my answer is I still don’t know. Nobody I’m aware of has done that research in any particularly meaningful way. So there’s a question to be answered there, I guess. My approach has been to try to make both of those things as accessible as possible through fast.ai library so you can try them both and see what works. That’s what I do.</p><p name="ec9f" id="ec9f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Question</strong>: Reinforcement Learning popularity has been on a gradual rise in the recent past. What’s your take on Reinforcement Learning? Would fast.ai consider covering some ground in popular RL techniques in the future [<a href="https://youtu.be/nG3tT31nPmQ?t=1h15m21s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h15m21s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:15:21</a>]?</p><p name="4dc5" id="4dc5" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Jeremy</strong>: I’m still not a believer in reinforcement learning. I think it’s an interesting problem to solve but it’s not at all clear that we have a good way of solving this problem. So the problem, it really is the delayed credit problem. So I want to learn to play pong, I’ve moved up or down and three minutes later I find out whether I won the game of pong — which actions I took were actually useful? So to me, the idea of calculating the gradients of the output with respect to those inputs, the credit is so delayed that those derivatives don’t seem very interesting. I get this question quite regularly in every one of these four courses so far. I’ve always said the same thing. I’m rather pleased that finally recently there’s been some results showing that actually basically random search often does better than reinforcement learning so basically what’s happened is very well-funded companies with vast amounts of computational power throw all of it at reinforcement learning problems and get good results and people then say “oh it’s because of the reinforcement learning” rather than the vast amounts of compute power. Or they use extremely thoughtful and clever algorithms like a combination of convolutional neural nets and Monte Carlo tree search like they did with the Alpha Go stuff to get great results and people incorrectly say “oh that’s because of reinforcement learning” when it wasn’t really reinforcement learning at all. So I’m very interested in solving these kind of more generic optimization type problems rather than just prediction problems and that’s what these delayed credit problems tend to look like. But I don’t think we’ve yet got good enough best practices that I have anything on, ready to teach and say I’ve got to teach you this thing because I think it’s still going to be useful next year. So we’ll keep watching and see what happens.</p><h4 name="fbb6" id="fbb6" class="graf graf--h4 graf-after--p">Super resolution network to a style transfer network [<a href="https://youtu.be/nG3tT31nPmQ?t=1h17m57s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h17m57s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">1:17:57</a>]</h4><figure name="39a2" id="39a2" class="graf graf--figure graf-after--h4"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_nBoerE_seZP-z5lqL7bsUg.png"></figure><p name="daee" id="daee" class="graf graf--p graf-after--figure">We are going to now turn the super resolution network into a style transfer network. And we’ll do this pretty quickly. We basically already have something. <em class="markup--em markup--p-em">x</em> is my input image and I’m going to have some loss function and I’ve got some neural net again. Instead of a neural net that does a whole a lot of compute and then does upsampling at the end, our input this time is just as big as our output. So we are going to do some downsampling first. Then our computer, and then our upsampling. So that’s the first change we are going to make — we are going to add some downsampling so some stride 2 convolution layers to the front of our network. The second is rather than just comparing <em class="markup--em markup--p-em">yc</em> and <em class="markup--em markup--p-em">x </em>are the same thing here. So we are going to basically say our input image should look like itself by the end. Specifically we are going to compare it by chucking it through VGG and comparing it at one of the activation layers. And then its style should look like some painting which we’ll do just like we did with the Gatys’ approach by looking at the Gram matrix correspondence at a number of layers. So that’s basically it. So that ought to be super straight forward. It’s really combining two things we’ve already done.</p><h4 name="9209" id="9209" class="graf graf--h4 graf-after--p">Style transfer net [<a href="https://youtu.be/nG3tT31nPmQ?t=1h19m19s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h19m19s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">1:19:19</a>]</h4><p name="3448" id="3448" class="graf graf--p graf-after--h4"><a href="https://github.com/fastai/fastai/blob/master/courses/dl2/style-transfer-net.ipynb" data-href="https://github.com/fastai/fastai/blob/master/courses/dl2/style-transfer-net.ipynb" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Notebook</a></p><p name="d131" id="d131" class="graf graf--p graf-after--p">So all this code starts identical, except we don’t have high res and low res, we just have one size 256.</p><pre name="bbab" id="bbab" class="graf graf--pre graf-after--p">%matplotlib inline<br>%reload_ext autoreload<br>%autoreload 2</pre><pre name="a98a" id="a98a" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">from</strong> <strong class="markup--strong markup--pre-strong">fastai.conv_learner</strong> <strong class="markup--strong markup--pre-strong">import</strong> *<br><strong class="markup--strong markup--pre-strong">from</strong> <strong class="markup--strong markup--pre-strong">pathlib</strong> <strong class="markup--strong markup--pre-strong">import</strong> Path<br>torch.cuda.set_device(0)</pre><pre name="3c68" id="3c68" class="graf graf--pre graf-after--pre">torch.backends.cudnn.benchmark=<strong class="markup--strong markup--pre-strong">True</strong></pre><pre name="7e96" id="7e96" class="graf graf--pre graf-after--pre">PATH = Path('data/imagenet')<br>PATH_TRN = PATH/'train'</pre><pre name="ca27" id="ca27" class="graf graf--pre graf-after--pre">fnames_full,label_arr_full,all_labels = folder_source(PATH, 'train')<br>fnames_full = ['/'.join(Path(fn).parts[-2:]) <strong class="markup--strong markup--pre-strong">for</strong> fn <strong class="markup--strong markup--pre-strong">in</strong> fnames_full]<br>list(zip(fnames_full[:5],label_arr_full[:5]))</pre><pre name="0bde" id="0bde" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">[('n01440764/n01440764_9627.JPEG', 0),<br> ('n01440764/n01440764_9609.JPEG', 0),<br> ('n01440764/n01440764_5176.JPEG', 0),<br> ('n01440764/n01440764_6936.JPEG', 0),<br> ('n01440764/n01440764_4005.JPEG', 0)]</em></pre><pre name="e50e" id="e50e" class="graf graf--pre graf-after--pre">all_labels[:5]</pre><pre name="7cd0" id="7cd0" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">['n01440764', 'n01443537', 'n01484850', 'n01491361', 'n01494475']</em></pre><pre name="24cd" id="24cd" class="graf graf--pre graf-after--pre">np.random.seed(42)<br><em class="markup--em markup--pre-em"># keep_pct = 1.</em><br><em class="markup--em markup--pre-em"># keep_pct = 0.01</em><br>keep_pct = 0.1<br>keeps = np.random.rand(len(fnames_full)) &lt; keep_pct<br>fnames = np.array(fnames_full, copy=<strong class="markup--strong markup--pre-strong">False</strong>)[keeps]<br>label_arr = np.array(label_arr_full, copy=<strong class="markup--strong markup--pre-strong">False</strong>)[keeps]</pre><pre name="55df" id="55df" class="graf graf--pre graf-after--pre">arch = vgg16<br><em class="markup--em markup--pre-em"># sz,bs = 96,32</em><br>sz,bs = 256,24<br><em class="markup--em markup--pre-em"># sz,bs = 128,32</em></pre><pre name="22f6" id="22f6" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">class</strong> <strong class="markup--strong markup--pre-strong">MatchedFilesDataset</strong>(FilesDataset):<br>    <strong class="markup--strong markup--pre-strong">def</strong> __init__(self, fnames, y, transform, path):<br>        self.y=y<br>        <strong class="markup--strong markup--pre-strong">assert</strong>(len(fnames)==len(y))<br>        super().__init__(fnames, transform, path)<br>    <strong class="markup--strong markup--pre-strong">def</strong> get_y(self, i): <br>        <strong class="markup--strong markup--pre-strong">return</strong> open_image(os.path.join(self.path, self.y[i]))<br>    <strong class="markup--strong markup--pre-strong">def</strong> get_c(self): <strong class="markup--strong markup--pre-strong">return</strong> 0</pre><pre name="917d" id="917d" class="graf graf--pre graf-after--pre">val_idxs = get_cv_idxs(len(fnames), val_pct=min(0.01/keep_pct, 0.1))<br>((val_x,trn_x),(val_y,trn_y)) = split_by_idx(val_idxs, <br>                                 np.array(fnames), np.array(fnames))<br>len(val_x),len(trn_x)</pre><pre name="4fe4" id="4fe4" class="graf graf--pre graf-after--pre">(12800, 115206)</pre><pre name="2036" id="2036" class="graf graf--pre graf-after--pre">img_fn = PATH/'train'/'n01558993'/'n01558993_9684.JPEG'</pre><pre name="4445" id="4445" class="graf graf--pre graf-after--pre">tfms = tfms_from_model(arch, sz, tfm_y=TfmType.PIXEL)<br>datasets = ImageData.get_ds(MatchedFilesDataset, (trn_x,trn_y), <br>                   (val_x,val_y), tfms, path=PATH_TRN)<br>md = ImageData(PATH, datasets, bs, num_workers=16, classes=<strong class="markup--strong markup--pre-strong">None</strong>)</pre><pre name="48f6" id="48f6" class="graf graf--pre graf-after--pre">denorm = md.val_ds.denorm</pre><pre name="0c8d" id="0c8d" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">def</strong> show_img(ims, idx, figsize=(5,5), normed=<strong class="markup--strong markup--pre-strong">True</strong>, ax=<strong class="markup--strong markup--pre-strong">None</strong>):<br>    <strong class="markup--strong markup--pre-strong">if</strong> ax <strong class="markup--strong markup--pre-strong">is</strong> <strong class="markup--strong markup--pre-strong">None</strong>: fig,ax = plt.subplots(figsize=figsize)<br>    <strong class="markup--strong markup--pre-strong">if</strong> normed: ims = denorm(ims)<br>    <strong class="markup--strong markup--pre-strong">else</strong>:      ims = np.rollaxis(to_np(ims),1,4)<br>    ax.imshow(np.clip(ims,0,1)[idx])<br>    ax.axis('off')</pre><h4 name="5660" id="5660" class="graf graf--h4 graf-after--pre">Model [<a href="https://youtu.be/nG3tT31nPmQ?t=1h19m30s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h19m30s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">1:19:30</a>]</h4><p name="5e54" id="5e54" class="graf graf--p graf-after--h4">My model is the same. One thing I did here is I did not do any kind of fancy best practices for this one at all. Partly because there doesn’t seem to be any. There’s been very little follow up in this approach compared to the super resolution stuff. We’ll talk about why in a moment. So you’ll see, this is much more normal looking.</p><pre name="6f0e" id="6f0e" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">def</strong> conv(ni, nf, kernel_size=3, stride=1, actn=<strong class="markup--strong markup--pre-strong">True</strong>, pad=<strong class="markup--strong markup--pre-strong">None</strong>, <br>         bn=<strong class="markup--strong markup--pre-strong">True</strong>):<br>    <strong class="markup--strong markup--pre-strong">if</strong> pad <strong class="markup--strong markup--pre-strong">is</strong> <strong class="markup--strong markup--pre-strong">None</strong>: pad = kernel_size//2<br>    layers = [nn.Conv2d(ni, nf, kernel_size, stride=stride,<br>                          padding=pad, bias=<strong class="markup--strong markup--pre-strong">not</strong> bn)]<br>    <strong class="markup--strong markup--pre-strong">if</strong> actn: layers.append(nn.ReLU(inplace=<strong class="markup--strong markup--pre-strong">True</strong>))<br>    <strong class="markup--strong markup--pre-strong">if</strong> bn: layers.append(nn.BatchNorm2d(nf))<br>    <strong class="markup--strong markup--pre-strong">return</strong> nn.Sequential(*layers)</pre><p name="7af8" id="7af8" class="graf graf--p graf-after--pre">I’ve got batch norm layers. I don’t have scaling factor here.</p><pre name="8e05" id="8e05" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">class</strong> <strong class="markup--strong markup--pre-strong">ResSequentialCenter</strong>(nn.Module):<br>    <strong class="markup--strong markup--pre-strong">def</strong> __init__(self, layers):<br>        super().__init__()<br>        self.m = nn.Sequential(*layers)</pre><pre name="d18d" id="d18d" class="graf graf--pre graf-after--pre">    <strong class="markup--strong markup--pre-strong">def</strong> forward(self, x): <strong class="markup--strong markup--pre-strong">return</strong> x[:, :, 2:-2, 2:-2] + self.m(x)</pre><pre name="852e" id="852e" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">def</strong> res_block(nf):<br>    <strong class="markup--strong markup--pre-strong">return</strong> ResSequentialCenter([conv(nf, nf, actn=<strong class="markup--strong markup--pre-strong">True</strong>, pad=0), <br>              conv(nf, nf, pad=0)])</pre><p name="af82" id="af82" class="graf graf--p graf-after--pre">I don’t have a pixel shuffle — it’s just using a normal upsampling followed by 1x1 conf. So it’s just more normal.</p><pre name="5179" id="5179" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">def</strong> upsample(ni, nf):<br>    <strong class="markup--strong markup--pre-strong">return</strong> nn.Sequential(nn.Upsample(scale_factor=2), conv(ni, nf))</pre><p name="4132" id="4132" class="graf graf--p graf-after--pre">One thing they mentioned in the paper is they had a lot of problems with zero padding creating artifacts and the way they solved that was by adding 40 pixel of reflection padding at the start. So I did the same thing and then they used zero padding in their convolutions in their Res blocks. Now if you’ve got zero padding in your convolutions in your Res blocks, then that means that the two parts of your ResNet won’t add up anymore because you’ve lost a pixel from each side on each of your two convolutions. So my <code class="markup--code markup--p-code">ResSequential</code> has become <code class="markup--code markup--p-code">ResSequentialCenter</code> and I’ve removed the last 2 pixels on each side of those good cells. Other than that, this is basically the same as what we had before.</p><pre name="437c" id="437c" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">class</strong> <strong class="markup--strong markup--pre-strong">StyleResnet</strong>(nn.Module):<br>    <strong class="markup--strong markup--pre-strong">def</strong> __init__(self):<br>        super().__init__()<br>        features = [nn.ReflectionPad2d(40),<br>                    conv(3, 32, 9),<br>                    conv(32, 64, stride=2), conv(64, 128, stride=2)]<br>        <strong class="markup--strong markup--pre-strong">for</strong> i <strong class="markup--strong markup--pre-strong">in</strong> range(5): features.append(res_block(128))<br>        features += [upsample(128, 64), upsample(64, 32),<br>                     conv(32, 3, 9, actn=<strong class="markup--strong markup--pre-strong">False</strong>)]<br>        self.features = nn.Sequential(*features)<br>        <br>    <strong class="markup--strong markup--pre-strong">def</strong> forward(self, x): <strong class="markup--strong markup--pre-strong">return</strong> self.features(x)</pre><h4 name="a39b" id="a39b" class="graf graf--h4 graf-after--pre">Style Image [<a href="https://youtu.be/nG3tT31nPmQ?t=1h21m2s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h21m2s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">1:21:02</a>]</h4><p name="93a0" id="93a0" class="graf graf--p graf-after--h4">So then we can bring in our starry night picture.</p><pre name="e724" id="e724" class="graf graf--pre graf-after--p">style_fn = PATH/'style'/'starry_night.jpg'<br>style_img = open_image(style_fn)<br>style_img.shape</pre><pre name="1850" id="1850" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">(1198, 1513, 3)</em></pre><pre name="ff2f" id="ff2f" class="graf graf--pre graf-after--pre">plt.imshow(style_img);</pre><figure name="c999" id="c999" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_3QN8_RpikQBlk8wwjD9B3w.png"></figure><pre name="cef3" id="cef3" class="graf graf--pre graf-after--figure">h,w,_ = style_img.shape<br>rat = max(sz/h,sz/h)<br>res = cv2.resize(style_img, (int(w*rat), int(h*rat)), interpolation=cv2.INTER_AREA)<br>resz_style = res[:sz,-sz:]</pre><p name="11e8" id="11e8" class="graf graf--p graf-after--pre">We can resize it.</p><pre name="f983" id="f983" class="graf graf--pre graf-after--p">plt.imshow(resz_style);</pre><figure name="5234" id="5234" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_CExkSLE8DWFZM0M3GPkHfg.png"></figure><p name="4b03" id="4b03" class="graf graf--p graf-after--figure">We can throw it through our transformations</p><pre name="e179" id="e179" class="graf graf--pre graf-after--p">style_tfm,_ = tfms[1](resz_style,resz_style)</pre><pre name="374e" id="374e" class="graf graf--pre graf-after--pre">style_tfm = np.broadcast_to(style_tfm[<strong class="markup--strong markup--pre-strong">None</strong>], (bs,)+style_tfm.shape)</pre><p name="8185" id="8185" class="graf graf--p graf-after--pre">Just to make the method a little bit easier for my brain to handle, I took our transform style image which after transformations of 3 x 256 x 256, and I made a mini batch. My batch size is 24 — 24 copies of it. It just maeks it a little bit easier to do the kind of batch arithmetic without worrying about some of the broadcasting. They are not really 24 copies. I used <code class="markup--code markup--p-code">np.broadcast</code> to basically fake 24 pieces.</p><pre name="1e49" id="1e49" class="graf graf--pre graf-after--p">style_tfm.shape</pre><pre name="77d0" id="77d0" class="graf graf--pre graf-after--pre">(24, 3, 256, 256)</pre><h4 name="21ad" id="21ad" class="graf graf--h4 graf-after--pre">Perceptual loss [<a href="https://youtu.be/nG3tT31nPmQ?t=1h21m51s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h21m51s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">1:21:51</a>]</h4><p name="f45e" id="f45e" class="graf graf--p graf-after--h4">So just like before, we create a VGG, grab the last block. This time we are going to use all of these layers so we keep everything up to the 43rd layer.</p><pre name="3041" id="3041" class="graf graf--pre graf-after--p">m_vgg = vgg16(<strong class="markup--strong markup--pre-strong">True</strong>)</pre><pre name="9a1f" id="9a1f" class="graf graf--pre graf-after--pre">blocks = [i-1 <strong class="markup--strong markup--pre-strong">for</strong> i,o <strong class="markup--strong markup--pre-strong">in</strong> enumerate(children(m_vgg))<br>              <strong class="markup--strong markup--pre-strong">if</strong> isinstance(o,nn.MaxPool2d)]<br>blocks, [m_vgg[i] <strong class="markup--strong markup--pre-strong">for</strong> i <strong class="markup--strong markup--pre-strong">in</strong> blocks[1:]]</pre><pre name="955c" id="955c" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">([5, 12, 22, 32, 42],<br> [ReLU(inplace), ReLU(inplace), ReLU(inplace), ReLU(inplace)])</em></pre><pre name="e33e" id="e33e" class="graf graf--pre graf-after--pre">vgg_layers = children(m_vgg)[:43]<br>m_vgg = nn.Sequential(*vgg_layers).cuda().eval()<br>set_trainable(m_vgg, <strong class="markup--strong markup--pre-strong">False</strong>)</pre><pre name="b5db" id="b5db" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">def</strong> flatten(x): <strong class="markup--strong markup--pre-strong">return</strong> x.view(x.size(0), -1)</pre><pre name="00a6" id="00a6" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">class</strong> <strong class="markup--strong markup--pre-strong">SaveFeatures</strong>():<br>    features=<strong class="markup--strong markup--pre-strong">None</strong><br>    <strong class="markup--strong markup--pre-strong">def</strong> __init__(self, m): <br>        self.hook = m.register_forward_hook(self.hook_fn)<br>    <strong class="markup--strong markup--pre-strong">def</strong> hook_fn(self, module, input, output): self.features = output<br>    <strong class="markup--strong markup--pre-strong">def</strong> remove(self): self.hook.remove()</pre><pre name="54dc" id="54dc" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">def</strong> ct_loss(input, target): <strong class="markup--strong markup--pre-strong">return</strong> F.mse_loss(input,target)</pre><pre name="5228" id="5228" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">def</strong> gram(input):<br>        b,c,h,w = input.size()<br>        x = input.view(b, c, -1)<br>        <strong class="markup--strong markup--pre-strong">return</strong> torch.bmm(x, x.transpose(1,2))/(c*h*w)*1e6</pre><pre name="eee5" id="eee5" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">def</strong> gram_loss(input, target):<br>    <strong class="markup--strong markup--pre-strong">return</strong> F.mse_loss(gram(input), gram(target[:input.size(0)]))</pre><p name="41cb" id="41cb" class="graf graf--p graf-after--pre">So now our combined loss is going to add together a content loss for the third block plus the Gram loss for all of our blocks with different weights. Again, going back to everything being as normal as possible, I’ve gone back to using MSE above. Basically what happened was I had a lot of trouble getting this to train properly. So I gradually removed trick after trick and eventually just went “ok, I’m just gonna make it as bland as possible”.</p><p name="a0cf" id="a0cf" class="graf graf--p graf-after--p">Last week’s Gram matrix was wrong, by the way [<a href="https://youtu.be/nG3tT31nPmQ?t=1h22m37s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h22m37s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:22:37</a>]. It only worked for a batch size of one and we only had a batch size of one so that was fine. I was using matrix multiply which meant that every batch was being compared to every other batch. You actually need to use batch matrix multiple (<code class="markup--code markup--p-code">torch.bmm</code>) which does a matrix multiply per batch. So that’s something to be aware of there.</p><pre name="434a" id="434a" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">class</strong> <strong class="markup--strong markup--pre-strong">CombinedLoss</strong>(nn.Module):<br>    <strong class="markup--strong markup--pre-strong">def</strong> __init__(self, m, layer_ids, style_im, ct_wgt, style_wgts):<br>        super().__init__()<br>        self.m,self.ct_wgt,self.style_wgts = m,ct_wgt,style_wgts<br>        self.sfs = [SaveFeatures(m[i]) <strong class="markup--strong markup--pre-strong">for</strong> i <strong class="markup--strong markup--pre-strong">in</strong> layer_ids]<br>        m(VV(style_im))<br>        self.style_feat = [V(o.features.data.clone()) <br>                              <strong class="markup--strong markup--pre-strong">for</strong> o <strong class="markup--strong markup--pre-strong">in</strong> self.sfs]</pre><pre name="2900" id="2900" class="graf graf--pre graf-after--pre">    <strong class="markup--strong markup--pre-strong">def</strong> forward(self, input, target, sum_layers=<strong class="markup--strong markup--pre-strong">True</strong>):<br>        self.m(VV(target.data))<br>        targ_feat = self.sfs[2].features.data.clone()<br>        self.m(input)<br>        inp_feat = [o.features <strong class="markup--strong markup--pre-strong">for</strong> o <strong class="markup--strong markup--pre-strong">in</strong> self.sfs]<br>        <br>        res = [ct_loss(inp_feat[2],V(targ_feat)) * self.ct_wgt]<br>        res += [gram_loss(inp,targ)*wgt <strong class="markup--strong markup--pre-strong">for</strong> inp,targ,wgt<br>                <strong class="markup--strong markup--pre-strong">in</strong> zip(inp_feat, self.style_feat, self.style_wgts)]<br>        <br>        <strong class="markup--strong markup--pre-strong">if</strong> sum_layers: res = sum(res)<br>        <strong class="markup--strong markup--pre-strong">return</strong> res<br>    <br>    <strong class="markup--strong markup--pre-strong">def</strong> close(self):<br>        <strong class="markup--strong markup--pre-strong">for</strong> o <strong class="markup--strong markup--pre-strong">in</strong> self.sfs: o.remove()</pre><p name="05b3" id="05b3" class="graf graf--p graf-after--pre">So I’ve got Gram matrices, I do my MSE loss between the Gram matrices, I weight them by style weights, so I create that ResNet.</p><pre name="01e9" id="01e9" class="graf graf--pre graf-after--p">m = StyleResnet()<br>m = to_gpu(m)</pre><pre name="d2fb" id="d2fb" class="graf graf--pre graf-after--pre">learn = Learner(md, SingleModel(m), opt_fn=optim.Adam)</pre><p name="8ea4" id="8ea4" class="graf graf--p graf-after--pre">I create my combined loss passing in the VGG network, passing in the block IDs, passing in the transformed starry night image, and you’ll see the the very start here, I do a forward pass through my VGG model with that starry night image in order that I can save the features for it. Notice, it’s really important now that I don’t do any data augmentation because I’ve saved the style features for a particular non-augmented version. So if I augmented it, it might make some minor problems. But that’s fine because I’ve got all of ImageNet to deal with. I don’t really need to do data augmentation anyway.</p><pre name="46f3" id="46f3" class="graf graf--pre graf-after--p">learn.crit = CombinedLoss(m_vgg, blocks[1:], style_tfm, 1e4,<br>                             [0.025,0.275,5.,0.2])</pre><pre name="58a8" id="58a8" class="graf graf--pre graf-after--pre">wd=1e-7</pre><pre name="841d" id="841d" class="graf graf--pre graf-after--pre">learn.lr_find(wds=wd)<br>learn.sched.plot(n_skip_end=1)</pre><pre name="7435" id="7435" class="graf graf--pre graf-after--pre">  1%|▏         | 7/482 [00:04&lt;05:32,  1.43it/s, loss=2.48e+04] <br> 53%|█████▎    | 254/482 [02:27&lt;02:12,  1.73it/s, loss=1.13e+12]</pre><figure name="76cb" id="76cb" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_sDFoltJE1s5ugWZndD4k0A.png"></figure><pre name="464f" id="464f" class="graf graf--pre graf-after--figure">lr=5e-3</pre><p name="18e5" id="18e5" class="graf graf--p graf-after--pre">So I’ve got my loss function and I can go ahead and fit [<a href="https://youtu.be/nG3tT31nPmQ?t=1h24m6s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h24m6s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:24:06</a>]. And there is nothing clever here at all.</p><pre name="7b0f" id="7b0f" class="graf graf--pre graf-after--p">learn.fit(lr, 1, cycle_len=1, wds=wd, use_clr=(20,10))</pre><pre name="5313" id="5313" class="graf graf--pre graf-after--pre">epoch      trn_loss   val_loss                               <br>    0      105.351372 105.833994</pre><pre name="7ad2" id="7ad2" class="graf graf--pre graf-after--pre">[array([105.83399])]</pre><pre name="ff47" id="ff47" class="graf graf--pre graf-after--pre">learn.save('style-2')</pre><pre name="4c19" id="4c19" class="graf graf--pre graf-after--pre">x,y=md.val_ds[201]</pre><pre name="757d" id="757d" class="graf graf--pre graf-after--pre">learn.model.eval()<br>preds = learn.model(VV(x[<strong class="markup--strong markup--pre-strong">None</strong>]))<br>x.shape,y.shape,preds.shape</pre><pre name="9293" id="9293" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">((3, 256, 256), (3, 256, 256), torch.Size([1, 3, 256, 256]))</em></pre><p name="597a" id="597a" class="graf graf--p graf-after--pre">At the end, I have my <code class="markup--code markup--p-code">sum_layers=False</code> so I can see what each part looks like and see they are balanced. And I can finally pop it out</p><pre name="31b9" id="31b9" class="graf graf--pre graf-after--p">learn.crit(preds, VV(y[<strong class="markup--strong markup--pre-strong">None</strong>]), sum_layers=<strong class="markup--strong markup--pre-strong">False</strong>)</pre><pre name="a7e5" id="a7e5" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">[Variable containing:<br>  53.2221<br> [torch.cuda.FloatTensor of size 1 (GPU 0)], Variable containing:<br>  3.8336<br> [torch.cuda.FloatTensor of size 1 (GPU 0)], Variable containing:<br>  4.0612<br> [torch.cuda.FloatTensor of size 1 (GPU 0)], Variable containing:<br>  5.0639<br> [torch.cuda.FloatTensor of size 1 (GPU 0)], Variable containing:<br>  53.0019<br> [torch.cuda.FloatTensor of size 1 (GPU 0)]]</em></pre><pre name="c3c5" id="c3c5" class="graf graf--pre graf-after--pre">learn.crit.close()</pre><pre name="d2cd" id="d2cd" class="graf graf--pre graf-after--pre">_,axes=plt.subplots(1,2,figsize=(14,7))<br>show_img(x[<strong class="markup--strong markup--pre-strong">None</strong>], 0, ax=axes[0])<br>show_img(preds, 0, ax=axes[1])</pre><figure name="a174" id="a174" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_Hlb0cHXu_IdLZmfBxJIgJA.png"></figure><p name="232c" id="232c" class="graf graf--p graf-after--figure">So I mentioned that should be pretty easy and yet it took me about 4 days because I just found this incredibly fiddly to actually get it to work [<a href="https://youtu.be/nG3tT31nPmQ?t=1h24m26s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h24m26s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:24:26</a>]. So when I finally got up in the morning I said to Rachel “guess what, it trained correctly.” Rachel said “I never thought that was going to happen.” It just looked awful all the time and it’s really about getting the exact right mix of content loss and a style loss and the mix of the layers of the style loss. The worst part was it takes a really long time to train the darn CNN and I didn’t really know how long to train it before I decided it wasn’t doing well. Should I just train it for longer? And I don’t know all the little details didn’t seem to slightly change it but just it would totally fall apart all the time. So I kind of mentioned this partly to say just remember the final answer you see here is after me driving myself crazy all week of nearly always not working until finally the last minute it finally does. Even for things which just seemed like they couldn’t possibly be difficult because that is combining two things we already have working. The other is to be careful about how we interpret what authors claim.</p><figure name="e2ae" id="e2ae" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_6AvLQSM40JcTWE26C4GafA.png"></figure><p name="9e75" id="9e75" class="graf graf--p graf-after--figure">It was so fiddly getting this style transfer to work [<a href="https://youtu.be/nG3tT31nPmQ?t=1h26m10s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h26m10s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:26:10</a>]. After doing it, it left me thinking why did I bother because now I’ve got something that takes hours to create a network that can turn any kind of photo into one specific style. It just seems very unlikely I would want that for anything. The only reason I could think that being useful would be to do some art-y stuff on a video where I wanted to turn every frame into some style. It’s incredibly niche thing to want to do. But when I looked at the paper, the table is saying “oh, we are a thousand times faster than the Gatys’ approach which is just such an obviously meaningless thing to say. Such an incredibly misleading thing to say because it ignores all the hours of training for each individual style and I find this frustrating because groups like this Stanford group clearly know better or ought to know better, but still I guess the academic community encourages people to make these ridiculously grand claims. It also completely ignores this incredibly sensitive fiddly training process so this paper was just so well accepted when it came out. I remember everybody getting on Twitter and saying “wow, you know these Stanford people have found this way of doing style transfer a thousand times faster.” And clearly people saying this were top researchers in the field, clearly none of them actually understood it because nobody said “I don’t see why this is remotely useful, and also I tried it and it was incredibly fiddly to get it all to work.” It’s not until 18 months later I finally coming back to it and kind of thinking like “wait a minute, this is kind of stupid.” So this is the answer, I think, to the question of why haven’t people done follow ups on this to create really amazing best practices and better approaches like with a super resolution part of the paper. And I think the answer is because it’s dumb. So I think super resolution part of the paper is clearly not dumb. And it’s been improved and improved and now we have great super resolution. And I think we can derive from that great noise reduction, great colorization, great slant removal, great interactive artifact removal, etc. So I think there’s a lot of really cool techniques here. It’s also leveraging a lot of stuff that we’ve been learning and getting better and better at.</p><h3 name="90f0" id="90f0" class="graf graf--h3 graf-after--p">Segmentation [<a href="https://youtu.be/nG3tT31nPmQ?t=1h29m13s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h29m13s" class="markup--anchor markup--h3-anchor" rel="nofollow noopener" target="_blank">1:29:13</a>]</h3><figure name="e8d3" id="e8d3" class="graf graf--figure graf-after--h3"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_6iq4f7DtfqsWxsE9ib0SPg.png"></figure><p name="2144" id="2144" class="graf graf--p graf-after--figure">Finally, let’s talk about segmentation. This is from the famous CamVid dataset which is a classic example of an academic segmentation dataset. Basically you can see what we do is we start with a picture (they are actually video frames in this dataset) and we have some labels where they are not actually colors — each one has an ID and the IDs are mapped to colors. So red might be 1, purple might be 2, light pink might be 3 and so all the buildings are one class, all the cars are another class, all the people are another class, all the road is another class, and so on. So what we are actually doing here is multi-class classification for every pixel. You can see, sometimes that multi-class classification really is quite tricky — like these branches. Although, sometimes the labels are really not that great. This is very coarse as you can see. So that’s what we are going to do.</p><p name="6e73" id="6e73" class="graf graf--p graf-after--p">We are going to do segmentation and so it’s a lot like bounding boxes. But rather than just finding a box around each thing, we are actually going to label every single pixel with its class. Really, it’s actually a lot easier because it fits our CNN style so nicely that we can create any CNN where the output is an N by M grid containing the integers from 0 to C where there are C categories. And then we can use cross-entropy loss with a softmax activation and we are done. I could actually stop the class there and you can go and use exactly the same approaches you’ve learnt in lesson 1 and 2 and you’ll get a perfectly okay result. So the first thing to say is this is not actually a terribly hard thing to do. But we are going to try and do it really well.</p><h4 name="6328" id="6328" class="graf graf--h4 graf-after--p">Doing it the simple way [<a href="https://youtu.be/nG3tT31nPmQ?t=1h31m26s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h31m26s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">1:31:26</a>]</h4><p name="58b7" id="58b7" class="graf graf--p graf-after--h4"><a href="https://github.com/fastai/fastai/blob/master/courses/dl2/carvana.ipynb" data-href="https://github.com/fastai/fastai/blob/master/courses/dl2/carvana.ipynb" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Notebook</a></p><p name="5576" id="5576" class="graf graf--p graf-after--p">Let’s start by doing it the really simple way. And we are going to use Kaggle <a href="https://www.kaggle.com/c/carvana-image-masking-challenge" data-href="https://www.kaggle.com/c/carvana-image-masking-challenge" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Carvana</a> competition and you can download it with Kaggle API as usual.</p><pre name="10c5" id="10c5" class="graf graf--pre graf-after--p">%matplotlib inline<br>%reload_ext autoreload<br>%autoreload 2</pre><pre name="c2dc" id="c2dc" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">from</strong> <strong class="markup--strong markup--pre-strong">fastai.conv_learner</strong> <strong class="markup--strong markup--pre-strong">import</strong> *<br><strong class="markup--strong markup--pre-strong">from</strong> <strong class="markup--strong markup--pre-strong">fastai.dataset</strong> <strong class="markup--strong markup--pre-strong">import</strong> *<br><br><strong class="markup--strong markup--pre-strong">from</strong> <strong class="markup--strong markup--pre-strong">pathlib</strong> <strong class="markup--strong markup--pre-strong">import</strong> Path<br><strong class="markup--strong markup--pre-strong">import</strong> <strong class="markup--strong markup--pre-strong">json</strong></pre><h4 name="381e" id="381e" class="graf graf--h4 graf-after--pre">Setup</h4><p name="f902" id="f902" class="graf graf--p graf-after--h4">There is a train folder containing bunch of images which is the independent variable and a train_masks folder there’s the dependent variable and they look like below.</p><figure name="84f3" id="84f3" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_3lO9olOrpojAt5C22B5CoQ.png"></figure><p name="78b2" id="78b2" class="graf graf--p graf-after--figure">In this case, just like cats and dogs, we are going simple rather than doing multi-class classification, we are going to do binary classification. But of course multi-class is just the more general version — categorical cross entropy or binary class entropy. There is no differences conceptually, so the dependent variable is just zeros and ones, where else the independent variable is a regular image.</p><p name="da00" id="da00" class="graf graf--p graf-after--p">In order to do this well, it would really help to know what cars look like. Because really what we want to do is to figure out this is a car and its orientation and put white pixels where we expect the car to be based on the picture and their understanding of what cars look like.</p><pre name="7a38" id="7a38" class="graf graf--pre graf-after--p">PATH = Path('data/carvana')<br>list(PATH.iterdir())</pre><pre name="38eb" id="38eb" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">[PosixPath('data/carvana/train_masks.csv'),<br> PosixPath('data/carvana/train_masks-128'),<br> PosixPath('data/carvana/sample_submission.csv'),<br> PosixPath('data/carvana/train_masks_png'),<br> PosixPath('data/carvana/train.csv'),<br> PosixPath('data/carvana/train-128'),<br> PosixPath('data/carvana/train'),<br> PosixPath('data/carvana/metadata.csv'),<br> PosixPath('data/carvana/tmp'),<br> PosixPath('data/carvana/models'),<br> PosixPath('data/carvana/train_masks')]</em></pre><pre name="826c" id="826c" class="graf graf--pre graf-after--pre">MASKS_FN = 'train_masks.csv'<br>META_FN = 'metadata.csv'<br>TRAIN_DN = 'train'<br>MASKS_DN = 'train_masks'</pre><pre name="6d64" id="6d64" class="graf graf--pre graf-after--pre">masks_csv = pd.read_csv(PATH/MASKS_FN)<br>masks_csv.head()</pre><figure name="0315" id="0315" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_gSfi6-hcJG8YP3knRDQUAg.png"></figure><p name="174c" id="174c" class="graf graf--p graf-after--figure">The original dataset came with these CSV files as well [<a href="https://youtu.be/nG3tT31nPmQ?t=1h32m44s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h32m44s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:32:44</a>]. I don’t really use them for very much other than getting the list of images from them.</p><pre name="f2cd" id="f2cd" class="graf graf--pre graf-after--p">meta_csv = pd.read_csv(PATH/META_FN)<br>meta_csv.head()</pre><figure name="8173" id="8173" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_yBm5uRoK_sHQrS-ddATg6w.png"></figure><pre name="e876" id="e876" class="graf graf--pre graf-after--figure"><strong class="markup--strong markup--pre-strong">def</strong> show_img(im, figsize=<strong class="markup--strong markup--pre-strong">None</strong>, ax=<strong class="markup--strong markup--pre-strong">None</strong>, alpha=<strong class="markup--strong markup--pre-strong">None</strong>):<br>    <strong class="markup--strong markup--pre-strong">if</strong> <strong class="markup--strong markup--pre-strong">not</strong> ax: fig,ax = plt.subplots(figsize=figsize)<br>    ax.imshow(im, alpha=alpha)<br>    ax.set_axis_off()<br>    <strong class="markup--strong markup--pre-strong">return</strong> ax</pre><pre name="98c4" id="98c4" class="graf graf--pre graf-after--pre">CAR_ID = '00087a6bd4dc'</pre><pre name="b065" id="b065" class="graf graf--pre graf-after--pre">list((PATH/TRAIN_DN).iterdir())[:5]</pre><pre name="38b6" id="38b6" class="graf graf--pre graf-after--pre">[PosixPath('data/carvana/train/5ab34f0e3ea5_15.jpg'),<br> PosixPath('data/carvana/train/de3ca5ec1e59_07.jpg'),<br> PosixPath('data/carvana/train/28d9a149cb02_13.jpg'),<br> PosixPath('data/carvana/train/36a3f7f77e85_12.jpg'),<br> PosixPath('data/carvana/train/843763f47895_08.jpg')]</pre><pre name="1eb0" id="1eb0" class="graf graf--pre graf-after--pre">Image.open(PATH/TRAIN_DN/f'<strong class="markup--strong markup--pre-strong">{CAR_ID}</strong>_01.jpg').resize((300,200))</pre><figure name="b51b" id="b51b" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_KwDMh55dYxo5-ychRK2srQ.png"></figure><pre name="f946" id="f946" class="graf graf--pre graf-after--figure">list((PATH/MASKS_DN).iterdir())[:5]</pre><pre name="0341" id="0341" class="graf graf--pre graf-after--pre">[PosixPath('data/carvana/train_masks/6c0cd487abcd_03_mask.gif'),<br> PosixPath('data/carvana/train_masks/351c583eabd6_01_mask.gif'),<br> PosixPath('data/carvana/train_masks/90fdd8932877_02_mask.gif'),<br> PosixPath('data/carvana/train_masks/28d9a149cb02_10_mask.gif'),<br> PosixPath('data/carvana/train_masks/88bc32b9e1d9_14_mask.gif')]</pre><pre name="3c07" id="3c07" class="graf graf--pre graf-after--pre">Image.open(PATH/MASKS_DN/f'<strong class="markup--strong markup--pre-strong">{CAR_ID}</strong>_01_mask.gif').resize((300,200))</pre><figure name="1e7c" id="1e7c" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_zz4dhkhhF00W9VIQQiiGcg.png"></figure><p name="388e" id="388e" class="graf graf--p graf-after--figure">Each image after the car ID has a 01, 02, etc of which I’ve printed out all 16 of them for one car and as you can see basically those numbers are the 16 orientations of one car [<a href="https://youtu.be/nG3tT31nPmQ?t=1h32m58s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h32m58s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:32:58</a>]. I don’t think anybody in this competition actually used these orientation information. I believe they all kept the car’s images just treated them separately.</p><pre name="d3fa" id="d3fa" class="graf graf--pre graf-after--p">ims = [open_image(PATH/TRAIN_DN/f'<strong class="markup--strong markup--pre-strong">{CAR_ID}</strong>_{i+1:02d}.jpg') <br>          <strong class="markup--strong markup--pre-strong">for</strong> i <strong class="markup--strong markup--pre-strong">in</strong> range(16)]</pre><pre name="58e5" id="58e5" class="graf graf--pre graf-after--pre">fig, axes = plt.subplots(4, 4, figsize=(9, 6))<br><strong class="markup--strong markup--pre-strong">for</strong> i,ax <strong class="markup--strong markup--pre-strong">in</strong> enumerate(axes.flat): show_img(ims[i], ax=ax)<br>plt.tight_layout(pad=0.1)</pre><figure name="c9fd" id="c9fd" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_ran3w5qDWsvfVaoPileaxw.png"></figure><h4 name="b9a4" id="b9a4" class="graf graf--h4 graf-after--figure">Resize and convert [<a href="https://youtu.be/nG3tT31nPmQ?t=1h33m27s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h33m27s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">1:33:27</a>]</h4><p name="9975" id="9975" class="graf graf--p graf-after--h4">These images are pretty big — over 1000 by 1000 in size and just opening the JPEGs and resizing them is slow. So I processed them all. Also OpenCV can’t handle GIF files so I converted them.</p><p name="f033" id="f033" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Question</strong>: How would somebody get these masks for training initially? <a href="https://www.mturk.com/" data-href="https://www.mturk.com/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Mechanical turk</a> or something [<a href="https://youtu.be/nG3tT31nPmQ?t=1h33m48s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h33m48s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:33:48</a>]? Yeah, just a lot of boring work. Probably there are some tools that help you with a bit of edge snapping so that the human can do it roughly and then just fine tune the bits it gets wrong. These kinds of labels are expensive. So one of the things I really want to work on is deep learning enhanced interactive labeling tools because that’s clearly something that would help a lot of people.</p><p name="e0f5" id="e0f5" class="graf graf--p graf-after--p">I’ve got a little section here that you can run if you want to. You probably want to. It converts the GIFs into PNGs so just open int up with PIL and then save it as PNG because OpenCV doesn’t have GIF support. As per usual for this kind of stuff, I do it with a ThreadPool so I can take advantage of parallel processing. And then also create a separate directory <code class="markup--code markup--p-code">train-128</code> and <code class="markup--code markup--p-code">train_masks-128</code> which contains the 128 by 128 resized versions of them.</p><p name="ca7c" id="ca7c" class="graf graf--p graf-after--p">This is the kind of stuff that keeps you sane if you do it early in the process. So anytime you get a new dataset, seriously think about creating a smaller version to make life fast. Anytime you find yourself waiting on your computer, try and think of a way to create a smaller version.</p><pre name="d7eb" id="d7eb" class="graf graf--pre graf-after--p">(PATH/'train_masks_png').mkdir(exist_ok=<strong class="markup--strong markup--pre-strong">True</strong>)</pre><pre name="49bf" id="49bf" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">def</strong> convert_img(fn):<br>    fn = fn.name<br>    Image.open(PATH/'train_masks'/fn).save(PATH/'train_masks_png'/<br>                     f'<strong class="markup--strong markup--pre-strong">{fn[:-4]}</strong>.png')</pre><pre name="6a95" id="6a95" class="graf graf--pre graf-after--pre">files = list((PATH/'train_masks').iterdir())<br><strong class="markup--strong markup--pre-strong">with</strong> ThreadPoolExecutor(8) <strong class="markup--strong markup--pre-strong">as</strong> e: e.map(convert_img, files)</pre><pre name="42f4" id="42f4" class="graf graf--pre graf-after--pre">(PATH/'train_masks-128').mkdir(exist_ok=<strong class="markup--strong markup--pre-strong">True</strong>)</pre><pre name="9b6b" id="9b6b" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">def</strong> resize_mask(fn):<br>    Image.open(fn).resize((128,128)).save((fn.parent.parent)<br>        /'train_masks-128'/fn.name)<br><br>files = list((PATH/'train_masks_png').iterdir())<br><strong class="markup--strong markup--pre-strong">with</strong> ThreadPoolExecutor(8) <strong class="markup--strong markup--pre-strong">as</strong> e: e.map(resize_img, files)</pre><pre name="0b2b" id="0b2b" class="graf graf--pre graf-after--pre">(PATH/'train-128').mkdir(exist_ok=<strong class="markup--strong markup--pre-strong">True</strong>)</pre><pre name="eb5f" id="eb5f" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">def</strong> resize_img(fn):<br>    Image.open(fn).resize((128,128)).save((fn.parent.parent)<br>         /'train-128'/fn.name)<br><br>files = list((PATH/'train').iterdir())<br><strong class="markup--strong markup--pre-strong">with</strong> ThreadPoolExecutor(8) <strong class="markup--strong markup--pre-strong">as</strong> e: e.map(resize_img, files)</pre><p name="c665" id="c665" class="graf graf--p graf-after--pre">So after you grab it from Kaggle, you probably want to run this stuff, go away, have lunch, come back and when you are done, you’ll have these smaller directories which we are going to use below 128 by 128 to start with.</p><h4 name="b90f" id="b90f" class="graf graf--h4 graf-after--p">Dataset [<a href="https://youtu.be/nG3tT31nPmQ?t=1h35m33s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h35m33s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">1:35:33</a>]</h4><pre name="30b1" id="30b1" class="graf graf--pre graf-after--h4">TRAIN_DN = 'train-128'<br>MASKS_DN = 'train_masks-128'<br>sz = 128<br>bs = 64</pre><pre name="6925" id="6925" class="graf graf--pre graf-after--pre">ims = [open_image(PATH/TRAIN_DN<br>            /f'<strong class="markup--strong markup--pre-strong">{CAR_ID}</strong>_{i+1:02d}.jpg') <strong class="markup--strong markup--pre-strong">for</strong> i <strong class="markup--strong markup--pre-strong">in</strong> range(16)]<br>im_masks = [open_image(PATH/MASKS_DN<br>            /f'<strong class="markup--strong markup--pre-strong">{CAR_ID}</strong>_{i+1:02d}_mask.png') <strong class="markup--strong markup--pre-strong">for</strong> i <strong class="markup--strong markup--pre-strong">in</strong> range(16)]</pre><p name="d0be" id="d0be" class="graf graf--p graf-after--pre">So here is a cool trick. If you use the same axis object (<code class="markup--code markup--p-code">ax</code>) to plot an image twice and the second time you use alpha which you might know means transparency in the computer vision world, then you can actually plot the mask over the top of the photo. So here is a nice way to see all the masks on top of the photos for all of the cars in one group.</p><pre name="9454" id="9454" class="graf graf--pre graf-after--p">fig, axes = plt.subplots(4, 4, figsize=(9, 6))<br><strong class="markup--strong markup--pre-strong">for</strong> i,ax <strong class="markup--strong markup--pre-strong">in</strong> enumerate(axes.flat):<br>    ax = show_img(ims[i], ax=ax)<br>    show_img(im_masks[i][...,0], ax=ax, alpha=0.5)<br>plt.tight_layout(pad=0.1)</pre><figure name="a8ff" id="a8ff" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_KuD6ZEQEbZH8Ka3u8tP5Ig.png"></figure><p name="e562" id="e562" class="graf graf--p graf-after--figure">This is the same MatchedFilesDataset we’ve seen twice already. This is all the same code. Here is something important though. If we had something that was in the training set the one on the left, and then the validation had the image on the right, that would be kind of cheating because it’s the same car.</p><figure name="3af9" id="3af9" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*vUDf60cZZxP3gezhcP36-w.png" data-width="260" data-height="99" src="../img/1_vUDf60cZZxP3gezhcP36-w.png"></figure><pre name="74e2" id="74e2" class="graf graf--pre graf-after--figure"><strong class="markup--strong markup--pre-strong">class</strong> <strong class="markup--strong markup--pre-strong">MatchedFilesDataset</strong>(FilesDataset):<br>    <strong class="markup--strong markup--pre-strong">def</strong> __init__(self, fnames, y, transform, path):<br>        self.y=y<br>        <strong class="markup--strong markup--pre-strong">assert</strong>(len(fnames)==len(y))<br>        super().__init__(fnames, transform, path)<br>    <strong class="markup--strong markup--pre-strong">def</strong> get_y(self, i): <br>        <strong class="markup--strong markup--pre-strong">return</strong> open_image(os.path.join(self.path, self.y[i]))<br>    <strong class="markup--strong markup--pre-strong">def</strong> get_c(self): <strong class="markup--strong markup--pre-strong">return</strong> 0</pre><pre name="882e" id="882e" class="graf graf--pre graf-after--pre">x_names = np.array([Path(TRAIN_DN)/o <strong class="markup--strong markup--pre-strong">for</strong> o <strong class="markup--strong markup--pre-strong">in</strong> masks_csv['img']])<br>y_names = np.array([Path(MASKS_DN)/f'<strong class="markup--strong markup--pre-strong">{o[:-4]}</strong>_mask.png' <br>                       <strong class="markup--strong markup--pre-strong">for</strong> o <strong class="markup--strong markup--pre-strong">in</strong> masks_csv['img']])</pre><pre name="4b02" id="4b02" class="graf graf--pre graf-after--pre">len(x_names)//16//5*16</pre><pre name="4e18" id="4e18" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">1008</em></pre><p name="1159" id="1159" class="graf graf--p graf-after--pre">So we use a continuous set of car IDs and since each set is a set of 16, we make sure that’s evenly divisible by 16. So we make sure that our validation set contains different car IDs to our training set. This is the kind of stuff which you’ve got to be careful of. On Kaggle, it’s not so bad — you’ll know about it because you’ll submit your result and you’ll get a very different result on your leaderboard compared to your validation set. But in the real world. you won’t know until you put it in production and send your company bankrupt and lose your job. So you might want to think carefully about your validation set in that case.</p><pre name="c79e" id="c79e" class="graf graf--pre graf-after--p">val_idxs = list(range(1008))<br>((val_x,trn_x),(val_y,trn_y)) = split_by_idx(val_idxs, x_names, <br>                                              y_names)<br>len(val_x),len(trn_x)</pre><pre name="45fc" id="45fc" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">(1008, 4080)</em></pre><p name="ed3d" id="ed3d" class="graf graf--p graf-after--pre">Here we are going to use transform type classification (<code class="markup--code markup--p-code">TfmType.CLASS</code>) [<a href="https://youtu.be/nG3tT31nPmQ?t=1h37m3s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h37m3s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:37:03</a>]. It’s basically the same as transform type pixel (<code class="markup--code markup--p-code">TfmType.PIXEL</code>) but if you think about it, with a pixel version if we rotate a little bit then we probably want to average the pixels in between the two, but the classification, obviously we don’t. We use nearest neighbor. So there’s slight difference there. Also for classification, lighting doesn’t kick in, normalization doesn’t kick in to the dependent variable.</p><pre name="42cd" id="42cd" class="graf graf--pre graf-after--p">aug_tfms = [RandomRotate(4, tfm_y=TfmType.CLASS),<br>            RandomFlip(tfm_y=TfmType.CLASS),<br>            RandomLighting(0.05, 0.05)]<br><em class="markup--em markup--pre-em"># aug_tfms = []</em></pre><p name="14f9" id="14f9" class="graf graf--p graf-after--pre">They are already square images, so we don’t have to do any cropping.</p><pre name="6e78" id="6e78" class="graf graf--pre graf-after--p">tfms = tfms_from_model(resnet34, sz, crop_type=CropType.NO, tfm_y=TfmType.CLASS, aug_tfms=aug_tfms)<br>datasets = ImageData.get_ds(MatchedFilesDataset, (trn_x,trn_y), (val_x,val_y), tfms, path=PATH)<br>md = ImageData(PATH, datasets, bs, num_workers=8, classes=<strong class="markup--strong markup--pre-strong">None</strong>)</pre><pre name="f384" id="f384" class="graf graf--pre graf-after--pre">denorm = md.trn_ds.denorm<br>x,y = next(iter(md.aug_dl))<br>x = denorm(x)</pre><p name="8f3d" id="8f3d" class="graf graf--p graf-after--pre">So here you can see different versions of the augmented images — they are moving around a bit, and they are rotating a bit, and so forth.</p><pre name="6cf7" id="6cf7" class="graf graf--pre graf-after--p">fig, axes = plt.subplots(5, 6, figsize=(12, 10))<br><strong class="markup--strong markup--pre-strong">for</strong> i,ax <strong class="markup--strong markup--pre-strong">in</strong> enumerate(axes.flat):<br>    ax=show_img(x[i], ax=ax)<br>    show_img(y[i], ax=ax, alpha=0.5)<br>plt.tight_layout(pad=0.1)</pre><figure name="0886" id="0886" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_ak5NPATO_ayUjsc7UGfEdQ.png"></figure><p name="d0df" id="d0df" class="graf graf--p graf-after--figure">I get a lot of questions during our study group about how do I debug things and fix things that aren’t working. I never have a great answer other than every time I fix a problem is because of stuff like this that I do all the time. I just always print out everything as I go and then the one thing that I screw up always turns out to be the one thing that I forgot to check along the way. The more of this kind of thing you can do the better. If you are not looking at all of your intermediate results, you are going to have troubles.</p><h4 name="e7bd" id="e7bd" class="graf graf--h4 graf-after--p">Model [<a href="https://youtu.be/nG3tT31nPmQ?t=1h38m30s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h38m30s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">1:38:30</a>]</h4><pre name="c864" id="c864" class="graf graf--pre graf-after--h4"><strong class="markup--strong markup--pre-strong">class</strong> <strong class="markup--strong markup--pre-strong">Empty</strong>(nn.Module): <br>    <strong class="markup--strong markup--pre-strong">def</strong> forward(self,x): <strong class="markup--strong markup--pre-strong">return</strong> x<br><br>models = ConvnetBuilder(resnet34, 0, 0, 0, custom_head=Empty())<br>learn = ConvLearner(md, models)<br>learn.summary()</pre><pre name="7b45" id="7b45" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">class</strong> <strong class="markup--strong markup--pre-strong">StdUpsample</strong>(nn.Module):<br>    <strong class="markup--strong markup--pre-strong">def</strong> __init__(self, nin, nout):<br>        super().__init__()<br>        self.conv = nn.ConvTranspose2d(nin, nout, 2, stride=2)<br>        self.bn = nn.BatchNorm2d(nout)<br>        <br>    <strong class="markup--strong markup--pre-strong">def</strong> forward(self, x): <strong class="markup--strong markup--pre-strong">return</strong> self.bn(F.relu(self.conv(x)))</pre><pre name="93cc" id="93cc" class="graf graf--pre graf-after--pre">flatten_channel = Lambda(<strong class="markup--strong markup--pre-strong">lambda</strong> x: x[:,0])</pre><pre name="913a" id="913a" class="graf graf--pre graf-after--pre">simple_up = nn.Sequential(<br>    nn.ReLU(),<br>    StdUpsample(512,256),<br>    StdUpsample(256,256),<br>    StdUpsample(256,256),<br>    StdUpsample(256,256),<br>    nn.ConvTranspose2d(256, 1, 2, stride=2),<br>    flatten_channel<br>)</pre><p name="1815" id="1815" class="graf graf--p graf-after--pre">Given that we want something that knows what cars look like, we probably want to start with a pre-trained ImageNet network. So we are going to start with ResNet34. With <code class="markup--code markup--p-code">ConvnetBuilder</code>, we can grab our ResNet34 and we can add a custom head. The custom head is going to be something that upsamples a bunch of times and we are going to do things really dumb for now which is we’re just going to do a ConvTranspose2d, batch norm, ReLU.</p><p name="6fbe" id="6fbe" class="graf graf--p graf-after--p">This is what I am saying — any of you could have built this without looking at any of this notebook or at least you have the information from previous classes. There is nothing new at all. So at the very end, we have a single filter. Now that’s going to give us something which is batch size by 1 by 128 by 128. But we want something which is batch size by 128 by 128. So we have to remove that unit axis so I’ve got a lambda layer here. Lambda layers are incredibly helpful because without the lambda layer here, which is simply removing that unit axis by just indexing it with a 0, without a lambda layer, I would have to have created a custom class with a custom forward method and so forth. But by creating a lambda layer that does the one custom bit, I can now just chuck it in the Sequential and so that makes life easier.</p><p name="e580" id="e580" class="graf graf--p graf-after--p">PyTorch people are kind of snooty about this approach. Lambda layer is actually something that’s a part of the fastai library not part of the PyTorch library. And literally people on PyTorch discussion board say “yes, we could give people this”, “yes it is only a single line of code” but they never encourage them to use sequential too often. So there you go.</p><p name="8d82" id="8d82" class="graf graf--p graf-after--p">So this is our custom head [<a href="https://youtu.be/nG3tT31nPmQ?t=1h40m36s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h40m36s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:40:36</a>]. So we are going to have a ResNet 34 that goes downsample and then a really simple custom head that very quickly upsamples, and that hopefully will do something. And we are going to use accuracy with a threshold of 0.5 and print out metrics.</p><pre name="6a44" id="6a44" class="graf graf--pre graf-after--p">models = ConvnetBuilder(resnet34, 0, 0, 0, custom_head=simple_up)<br>learn = ConvLearner(md, models)<br>learn.opt_fn=optim.Adam<br>learn.crit=nn.BCEWithLogitsLoss()<br>learn.metrics=[accuracy_thresh(0.5)]</pre><pre name="71c6" id="71c6" class="graf graf--pre graf-after--pre">learn.lr_find()<br>learn.sched.plot()</pre><pre name="774d" id="774d" class="graf graf--pre graf-after--pre">94%|█████████▍| 30/32 [00:05&lt;00:00,  5.48it/s, loss=10.6]</pre><figure name="04ea" id="04ea" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_0RoKSchCdIyFHGVjb7PXHA.png"></figure><pre name="dba8" id="dba8" class="graf graf--pre graf-after--figure">lr=4e-2</pre><pre name="3d50" id="3d50" class="graf graf--pre graf-after--pre">learn.fit(lr,1,cycle_len=5,use_clr=(20,5))</pre><pre name="e8fb" id="e8fb" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">epoch      trn_loss   val_loss   &lt;lambda&gt;                  <br>    0      0.124078   0.133566   0.945951  <br>    1      0.111241   0.112318   0.954912                  <br>    2      0.099743   0.09817    0.957507                   <br>    3      0.090651   0.092375   0.958117                   <br>    4      0.084031   0.086026   0.963243</em></pre><pre name="b542" id="b542" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">[0.086025625, 0.96324310824275017]</em></pre><p name="1fbe" id="1fbe" class="graf graf--p graf-after--pre">After a few epochs, we’ve got 96 percent accurate. Is that good [<a href="https://youtu.be/nG3tT31nPmQ?t=1h40m56s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h40m56s" class="markup--anchor markup--p-anchor" rel="noopener nofollow" target="_blank">1:40:56</a>]? Is 96% accurate good? And hopefully the answer to that question is it depends. What’s it for? The answer is Carvana wanted this because they wanted to be able to take their car image and cut them out and paste them on exotic Monte Carlo backgrounds or whatever (that’s Monte Carlo the place and not the simulation). To do that, you you need a really good mask. You don’t want to leave the rearview mirrors behind, have one wheel missing, or include a little bit of background or something. That would look stupid. So you would need something very good. So only having 96% of the pixels correct doesn’t sound great. But we won’t really know until we look at it. So let’s look at it.</p><pre name="e43b" id="e43b" class="graf graf--pre graf-after--p">learn.save('tmp')</pre><pre name="8a62" id="8a62" class="graf graf--pre graf-after--pre">learn.load('tmp')</pre><pre name="9fd7" id="9fd7" class="graf graf--pre graf-after--pre">py,ay = learn.predict_with_targs()</pre><pre name="bae3" id="bae3" class="graf graf--pre graf-after--pre">ay.shape</pre><pre name="ec1b" id="ec1b" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">(1008, 128, 128)</em></pre><p name="cd51" id="cd51" class="graf graf--p graf-after--pre">So there is the correct version that we want to cut out [<a href="https://youtu.be/nG3tT31nPmQ?t=1h41m54s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h41m54s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:41:54</a>]</p><pre name="0abd" id="0abd" class="graf graf--pre graf-after--p">show_img(ay[0]);</pre><figure name="1711" id="1711" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_ZuW4s04Ubneh3fFjQuQ3rQ.png"></figure><p name="6fbf" id="6fbf" class="graf graf--p graf-after--figure">That’s the 96% accurate version. So when you look at it you realize “oh yeah, getting 96% of the pixel accurate is actually easy because all the outside bit is not car, and all the inside bit is a car, and really interesting bit is the edge. So we need to do better.</p><pre name="5078" id="5078" class="graf graf--pre graf-after--p">show_img(py[0]&gt;0);</pre><figure name="3117" id="3117" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_cp-SvDXQPGdN6k-8JL2CMw.png"></figure><p name="11f5" id="11f5" class="graf graf--p graf-after--figure">Let’s unfreeze because all we’ve done so far is train the custom head. Let’s do more.</p><pre name="3d63" id="3d63" class="graf graf--pre graf-after--p">learn.unfreeze()</pre><pre name="d43c" id="d43c" class="graf graf--pre graf-after--pre">learn.bn_freeze(<strong class="markup--strong markup--pre-strong">True</strong>)</pre><pre name="3e0b" id="3e0b" class="graf graf--pre graf-after--pre">lrs = np.array([lr/100,lr/10,lr])/4</pre><pre name="4cf0" id="4cf0" class="graf graf--pre graf-after--pre">learn.fit(lrs,1,cycle_len=20,use_clr=(20,10))</pre><pre name="09a7" id="09a7" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">epoch      trn_loss   val_loss   &lt;lambda&gt;                   <br>    0      0.06577    0.053292   0.972977  <br>    1      0.049475   0.043025   0.982559                   <br>    2      0.039146   0.035927   0.98337                    <br>    3      0.03405    0.031903   0.986982                   <br>    4      0.029788   0.029065   0.987944                   <br>    5      0.027374   0.027752   0.988029                   <br>    6      0.026041   0.026718   0.988226                   <br>    7      0.024302   0.025927   0.989512                   <br>    8      0.022921   0.026102   0.988276                   <br>    9      0.021944   0.024714   0.989537                   <br>    10     0.021135   0.0241     0.990628                   <br>    11     0.020494   0.023367   0.990652                   <br>    12     0.01988    0.022961   0.990989                   <br>    13     0.019241   0.022498   0.991014                   <br>    14     0.018697   0.022492   0.990571                   <br>    15     0.01812    0.021771   0.99105                    <br>    16     0.017597   0.02183    0.991365                   <br>    17     0.017192   0.021434   0.991364                   <br>    18     0.016768   0.021383   0.991643                   <br>    19     0.016418   0.021114   0.99173</em></pre><pre name="7898" id="7898" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">[0.021113895, 0.99172959849238396]</em></pre><p name="62e3" id="62e3" class="graf graf--p graf-after--pre">After a bit more, we’ve got 99.1%. Is that good? I don’t know. Let’s take a look.</p><pre name="c1cd" id="c1cd" class="graf graf--pre graf-after--p">learn.save('0')</pre><pre name="a8c0" id="a8c0" class="graf graf--pre graf-after--pre">x,y = next(iter(md.val_dl))<br>py = to_np(learn.model(V(x)))</pre><p name="49a7" id="49a7" class="graf graf--p graf-after--pre">Actually no. It’s totally missed the rearview vision mirror on the left and missed a lot of it on the right. And it’s clearly got an edge wrong on the bottom. And these things are totally going to matter when we try to cut it out, so it’s still not good enough.</p><pre name="a270" id="a270" class="graf graf--pre graf-after--p">ax = show_img(denorm(x)[0])<br>show_img(py[0]&gt;0, ax=ax, alpha=0.5);</pre><figure name="db2a" id="db2a" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_b4NbyzWojBS_6peHalw3tQ.png"></figure><pre name="5221" id="5221" class="graf graf--pre graf-after--figure">ax = show_img(denorm(x)[0])<br>show_img(y[0], ax=ax, alpha=0.5);</pre><figure name="b23b" id="b23b" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_nh7F97XxSE1ZOcleTfoPeA.png"></figure><h4 name="3fed" id="3fed" class="graf graf--h4 graf-after--figure">512x512 [<a href="https://youtu.be/nG3tT31nPmQ?t=1h42m50s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h42m50s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">1:42:50</a>]</h4><p name="c002" id="c002" class="graf graf--p graf-after--h4">Let’s try upscaling. And the nice thing is that when we upscale to 512 by 512, (make sure you decrease the batch size because you’ll run out of memory), it’s quite a lot more information there for it to go on so our accuracy increases to 99.4% and things keep getting better.</p><pre name="406f" id="406f" class="graf graf--pre graf-after--p">TRAIN_DN = 'train'<br>MASKS_DN = 'train_masks_png'<br>sz = 512<br>bs = 16</pre><pre name="bae2" id="bae2" class="graf graf--pre graf-after--pre">x_names = np.array([Path(TRAIN_DN)/o <strong class="markup--strong markup--pre-strong">for</strong> o <strong class="markup--strong markup--pre-strong">in</strong> masks_csv['img']])<br>y_names = np.array([Path(MASKS_DN)/f'<strong class="markup--strong markup--pre-strong">{o[:-4]}</strong>_mask.png' <br>                      <strong class="markup--strong markup--pre-strong">for</strong> o <strong class="markup--strong markup--pre-strong">in</strong> masks_csv['img']])</pre><pre name="821b" id="821b" class="graf graf--pre graf-after--pre">((val_x,trn_x),(val_y,trn_y)) = split_by_idx(val_idxs, x_names, <br>                                      y_names)<br>len(val_x),len(trn_x)</pre><pre name="7772" id="7772" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">(1008, 4080)</em></pre><pre name="25db" id="25db" class="graf graf--pre graf-after--pre">tfms = tfms_from_model(resnet34, sz, crop_type=CropType.NO,<br>                         tfm_y=TfmType.CLASS, aug_tfms=aug_tfms)<br>datasets = ImageData.get_ds(MatchedFilesDataset, (trn_x,trn_y),<br>                      (val_x,val_y), tfms, path=PATH)<br>md = ImageData(PATH, datasets, bs, num_workers=8, classes=<strong class="markup--strong markup--pre-strong">None</strong>)</pre><pre name="859d" id="859d" class="graf graf--pre graf-after--pre">denorm = md.trn_ds.denorm<br>x,y = next(iter(md.aug_dl))<br>x = denorm(x)</pre><p name="9176" id="9176" class="graf graf--p graf-after--pre">Here is the true ones.</p><pre name="6fee" id="6fee" class="graf graf--pre graf-after--p">fig, axes = plt.subplots(4, 4, figsize=(10, 10))<br><strong class="markup--strong markup--pre-strong">for</strong> i,ax <strong class="markup--strong markup--pre-strong">in</strong> enumerate(axes.flat):<br>    ax=show_img(x[i], ax=ax)<br>    show_img(y[i], ax=ax, alpha=0.5)<br>plt.tight_layout(pad=0.1)</pre><figure name="45ad" id="45ad" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_viBgn7WA9biBQ6BkzSEEnw.png"></figure><pre name="afad" id="afad" class="graf graf--pre graf-after--figure">simple_up = nn.Sequential(<br>    nn.ReLU(),<br>    StdUpsample(512,256),<br>    StdUpsample(256,256),<br>    StdUpsample(256,256),<br>    StdUpsample(256,256),<br>    nn.ConvTranspose2d(256, 1, 2, stride=2),<br>    flatten_channel<br>)</pre><pre name="d90a" id="d90a" class="graf graf--pre graf-after--pre">models = ConvnetBuilder(resnet34, 0, 0, 0, custom_head=simple_up)<br>learn = ConvLearner(md, models)<br>learn.opt_fn=optim.Adam<br>learn.crit=nn.BCEWithLogitsLoss()<br>learn.metrics=[accuracy_thresh(0.5)]</pre><pre name="8f27" id="8f27" class="graf graf--pre graf-after--pre">learn.load('0')</pre><pre name="a3e0" id="a3e0" class="graf graf--pre graf-after--pre">learn.lr_find()<br>learn.sched.plot()</pre><pre name="9973" id="9973" class="graf graf--pre graf-after--pre">85%|████████▌ | 218/255 [02:12&lt;00:22,  1.64it/s, loss=8.91]</pre><figure name="4133" id="4133" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_hjhVP2TyYd8FZMvyGevPgA.png"></figure><pre name="4148" id="4148" class="graf graf--pre graf-after--figure">lr=4e-2</pre><pre name="b2b4" id="b2b4" class="graf graf--pre graf-after--pre">learn.fit(lr,1,cycle_len=5,use_clr=(20,5))</pre><pre name="655f" id="655f" class="graf graf--pre graf-after--pre">epoch      trn_loss   val_loss   &lt;lambda&gt;                     <br>    0      0.02178    0.020653   0.991708  <br>    1      0.017927   0.020653   0.990241                     <br>    2      0.015958   0.016115   0.993394                     <br>    3      0.015172   0.015143   0.993696                     <br>    4      0.014315   0.014679   0.99388</pre><pre name="4064" id="4064" class="graf graf--pre graf-after--pre">[0.014679321, 0.99388032489352751]</pre><pre name="53e2" id="53e2" class="graf graf--pre graf-after--pre">learn.save('tmp')</pre><pre name="6543" id="6543" class="graf graf--pre graf-after--pre">learn.load('tmp')</pre><pre name="3a85" id="3a85" class="graf graf--pre graf-after--pre">learn.unfreeze()<br>learn.bn_freeze(<strong class="markup--strong markup--pre-strong">True</strong>)</pre><pre name="15e9" id="15e9" class="graf graf--pre graf-after--pre">lrs = np.array([lr/100,lr/10,lr])/4</pre><pre name="660f" id="660f" class="graf graf--pre graf-after--pre">learn.fit(lrs,1,cycle_len=8,use_clr=(20,8))</pre><pre name="1a7e" id="1a7e" class="graf graf--pre graf-after--pre">epoch      trn_loss   val_loss   mask_acc                     <br>    0      0.038687   0.018685   0.992782  <br>    1      0.024906   0.014355   0.994933                     <br>    2      0.025055   0.014737   0.995526                     <br>    3      0.024155   0.014083   0.995708                     <br>    4      0.013446   0.010564   0.996166                     <br>    5      0.01607    0.010555   0.996096                     <br>    6      0.019197   0.010883   0.99621                      <br>    7      0.016157   0.00998    0.996393</pre><pre name="1ccb" id="1ccb" class="graf graf--pre graf-after--pre">[0.0099797687, 0.99639255659920833]</pre><pre name="a070" id="a070" class="graf graf--pre graf-after--pre">learn.save('512')</pre><pre name="9ed6" id="9ed6" class="graf graf--pre graf-after--pre">x,y = next(iter(md.val_dl))<br>py = to_np(learn.model(V(x)))</pre><pre name="e57e" id="e57e" class="graf graf--pre graf-after--pre">ax = show_img(denorm(x)[0])<br>show_img(py[0]&gt;0, ax=ax, alpha=0.5);</pre><figure name="03dc" id="03dc" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1__nnK8pvyBueihmtg6JhqPA.png"></figure><pre name="c120" id="c120" class="graf graf--pre graf-after--figure">ax = show_img(denorm(x)[0])<br>show_img(y[0], ax=ax, alpha=0.5);</pre><figure name="fd4b" id="fd4b" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_G5zNxkOplWvUIbGlSPs86Q.png"></figure><p name="81d1" id="81d1" class="graf graf--p graf-after--figure">Things keep getting better but we’ve still got quite a few little black blocky bits. so let’s go to 1024 by 1024.</p><h4 name="d0a6" id="d0a6" class="graf graf--h4 graf-after--p">1024x1024 [<a href="https://youtu.be/nG3tT31nPmQ?t=1h43m17s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h43m17s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">1:43:17</a>]</h4><p name="5b87" id="5b87" class="graf graf--p graf-after--h4">So let’s go to 1024 by 1024, batch size down to 4. This is pretty high res now, and train a bit more, 99.6, 99.8%!</p><pre name="87d3" id="87d3" class="graf graf--pre graf-after--p">sz = 1024<br>bs = 4</pre><pre name="cffb" id="cffb" class="graf graf--pre graf-after--pre">tfms = tfms_from_model(resnet34, sz, crop_type=CropType.NO,<br>                         tfm_y=TfmType.CLASS, aug_tfms=aug_tfms)<br>datasets = ImageData.get_ds(MatchedFilesDataset, (trn_x,trn_y), <br>                            (val_x,val_y), tfms, path=PATH)<br>md = ImageData(PATH, datasets, bs, num_workers=8, classes=<strong class="markup--strong markup--pre-strong">None</strong>)</pre><pre name="8c28" id="8c28" class="graf graf--pre graf-after--pre">denorm = md.trn_ds.denorm<br>x,y = next(iter(md.aug_dl))<br>x = denorm(x)<br>y = to_np(y)</pre><pre name="b915" id="b915" class="graf graf--pre graf-after--pre">fig, axes = plt.subplots(2, 2, figsize=(8, 8))<br><strong class="markup--strong markup--pre-strong">for</strong> i,ax <strong class="markup--strong markup--pre-strong">in</strong> enumerate(axes.flat):<br>    show_img(x[i], ax=ax)<br>    show_img(y[i], ax=ax, alpha=0.5)<br>plt.tight_layout(pad=0.1)</pre><figure name="a61e" id="a61e" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_4PrOwKZEYtXv7xdf9rPkhg.png"></figure><pre name="bb11" id="bb11" class="graf graf--pre graf-after--figure">simple_up = nn.Sequential(<br>    nn.ReLU(),<br>    StdUpsample(512,256),<br>    StdUpsample(256,256),<br>    StdUpsample(256,256),<br>    StdUpsample(256,256),<br>    nn.ConvTranspose2d(256, 1, 2, stride=2),<br>    flatten_channel,<br>)</pre><pre name="09d6" id="09d6" class="graf graf--pre graf-after--pre">models = ConvnetBuilder(resnet34, 0, 0, 0, custom_head=simple_up)<br>learn = ConvLearner(md, models)<br>learn.opt_fn=optim.Adam<br>learn.crit=nn.BCEWithLogitsLoss()<br>learn.metrics=[accuracy_thresh(0.5)]</pre><pre name="15e5" id="15e5" class="graf graf--pre graf-after--pre">learn.load('512')</pre><pre name="16bb" id="16bb" class="graf graf--pre graf-after--pre">learn.lr_find()<br>learn.sched.plot()</pre><pre name="652c" id="652c" class="graf graf--pre graf-after--pre">85%|████████▌ | 218/255 [02:12&lt;00:22,  1.64it/s, loss=8.91]</pre><figure name="511e" id="511e" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_hjhVP2TyYd8FZMvyGevPgA.png"></figure><pre name="ed98" id="ed98" class="graf graf--pre graf-after--figure">lr=4e-2</pre><pre name="9540" id="9540" class="graf graf--pre graf-after--pre">learn.fit(lr,1,cycle_len=2,use_clr=(20,4))</pre><pre name="6b85" id="6b85" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">epoch      trn_loss   val_loss   &lt;lambda&gt;                       <br>    0      0.01066    0.011119   0.996227  <br>    1      0.009357   0.009696   0.996553</em></pre><pre name="65c0" id="65c0" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">[0.0096957013, 0.99655332546385511]</em></pre><pre name="dfde" id="dfde" class="graf graf--pre graf-after--pre">learn.save('tmp')</pre><pre name="a038" id="a038" class="graf graf--pre graf-after--pre">learn.load('tmp')</pre><pre name="d025" id="d025" class="graf graf--pre graf-after--pre">learn.unfreeze()<br>learn.bn_freeze(<strong class="markup--strong markup--pre-strong">True</strong>)</pre><pre name="de3d" id="de3d" class="graf graf--pre graf-after--pre">lrs = np.array([lr/100,lr/10,lr])/8</pre><pre name="16cb" id="16cb" class="graf graf--pre graf-after--pre">learn.fit(lrs,1,cycle_len=40,use_clr=(20,10))</pre><pre name="0c6c" id="0c6c" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">epoch      trn_loss   val_loss   mask_acc                       <br>    0      0.015565   0.007449   0.997661  <br>    1      0.01979    0.008376   0.997542                       <br>    2      0.014874   0.007826   0.997736                       <br>    3      0.016104   0.007854   0.997347                       <br>    4      0.023386   0.009745   0.997218                       <br>    5      0.018972   0.008453   0.997588                       <br>    6      0.013184   0.007612   0.997588                       <br>    7      0.010686   0.006775   0.997688                       <br>    8      0.0293     0.015299   0.995782                       <br>    9      0.018713   0.00763    0.997638                       <br>    10     0.015432   0.006575   0.9978                         <br>    11     0.110205   0.060062   0.979043                      <br>    12     0.014374   0.007753   0.997451                       <br>    13     0.022286   0.010282   0.997587                       <br>    14     0.015645   0.00739    0.997776                       <br>    15     0.013821   0.00692    0.997869                       <br>    16     0.022389   0.008632   0.997696                       <br>    17     0.014607   0.00677    0.997837                       <br>    18     0.018748   0.008194   0.997657                       <br>    19     0.016447   0.007237   0.997899                       <br>    20     0.023596   0.008211   0.997918                       <br>    21     0.015721   0.00674    0.997848                       <br>    22     0.01572    0.006415   0.998006                       <br>    23     0.019519   0.007591   0.997876                       <br>    24     0.011159   0.005998   0.998053                       <br>    25     0.010291   0.005806   0.998012                       <br>    26     0.010893   0.005755   0.998046                       <br>    27     0.014534   0.006313   0.997901                       <br>    28     0.020971   0.006855   0.998018                       <br>    29     0.014074   0.006107   0.998053                       <br>    30     0.01782    0.006561   0.998114                       <br>    31     0.01742    0.006414   0.997942                       <br>    32     0.016829   0.006514   0.9981                         <br>    33     0.013148   0.005819   0.998033                       <br>    34     0.023495   0.006261   0.997856                       <br>    35     0.010931   0.005516   0.99812                        <br>    36     0.015798   0.006176   0.998126                       <br>    37     0.021636   0.005931   0.998067                       <br>    38     0.012133   0.005496   0.998158                       <br>    39     0.012562   0.005678   0.998172</em></pre><pre name="9653" id="9653" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">[0.0056782686, 0.99817223208291195]</em></pre><pre name="8864" id="8864" class="graf graf--pre graf-after--pre">learn.save('1024')</pre><pre name="295a" id="295a" class="graf graf--pre graf-after--pre">x,y = next(iter(md.val_dl))<br>py = to_np(learn.model(V(x)))</pre><pre name="32e6" id="32e6" class="graf graf--pre graf-after--pre">ax = show_img(denorm(x)[0])<br>show_img(py[0][0]&gt;0, ax=ax, alpha=0.5);</pre><figure name="eb5e" id="eb5e" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_8kgJWpP6-nxlDfWT8N25_g.png"></figure><pre name="0d44" id="0d44" class="graf graf--pre graf-after--figure">ax = show_img(denorm(x)[0])<br>show_img(y[0,...,-1], ax=ax, alpha=0.5);</pre><figure name="31d6" id="31d6" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1__-Kx9dC5aTgBSf_aSrBrNQ.png"></figure><pre name="9662" id="9662" class="graf graf--pre graf-after--figure">show_img(py[0][0]&gt;0);</pre><figure name="e0e8" id="e0e8" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_G3C8DPyOB4BC3VLPGjbwcA.png"></figure><pre name="6f0f" id="6f0f" class="graf graf--pre graf-after--figure">show_img(y[0,...,-1]);</pre><figure name="3dcd" id="3dcd" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_fJrWvuzyX0cG5ATWvqaDPg.png"></figure><p name="5df3" id="5df3" class="graf graf--p graf-after--figure">Now if we look at the masks,&nbsp;, they are actually looking not bad. That’s looking pretty good. So can we do better? And the answer is yes, we can.</p><h3 name="0ffa" id="0ffa" class="graf graf--h3 graf-after--p">U-Net [<a href="https://youtu.be/nG3tT31nPmQ?t=1h43m45s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h43m45s" class="markup--anchor markup--h3-anchor" rel="nofollow noopener" target="_blank">1:43:45</a>]</h3><p name="e5cb" id="e5cb" class="graf graf--p graf-after--h3"><a href="https://github.com/fastai/fastai/blob/master/courses/dl2/carvana-unet.ipynb" data-href="https://github.com/fastai/fastai/blob/master/courses/dl2/carvana-unet.ipynb" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Notebook</a> / <a href="https://arxiv.org/abs/1505.04597" data-href="https://arxiv.org/abs/1505.04597" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Paper</a></p><p name="b5e6" id="b5e6" class="graf graf--p graf-after--p">U-Net network is quite magnificent. With that previous approach, our pre-trained ImageNet network was being squished down all the way down to 7x7 and then expand it out all the way back up to 224x224 (1024 gets squished down to quite a bit bigger than 7x7). And then expanded out again all this way which means it has to somehow store all the information about the much bigger version in the small version. And actually most of the information about the bigger version was really in the original picture anyway. So it doesn’t seem like a great approach — this squishing and un-squishing.</p><figure name="c410" id="c410" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_PvXW__XxRQIMoFoVFJq-Zw.png"></figure><p name="2d7d" id="2d7d" class="graf graf--p graf-after--figure">So the U-Net idea comes from this fantastic paper where it was literally invented in this very domain-specific area of biomedical image segmentation. But in fact, basically every Kaggle winner in anything even vaguely related to segmentation has end up using U-Net. It’s one of these things that everybody in Kaggle knows it is the best practice, but in more of academic circles, this has been around for a couple of years at least, a lot of people still don’t realize this is by far the best approach.</p><figure name="5547" id="5547" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_9nxe-lIVxXawNsLzItvqcg.png"></figure><p name="09c5" id="09c5" class="graf graf--p graf-after--figure">Here is the basic idea [<a href="https://youtu.be/nG3tT31nPmQ?t=1h45m10s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h45m10s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:45:10</a>]. On the left is the downward path where we start at 572x572 in this case then halve the grid size 4 times, then on the right is the upward path where we double the grid size 4 times. But the thing that we also do is, at every point where we halve the grid size, we actually copy those activations over to the upward path and concatenate them together.</p><p name="ba90" id="ba90" class="graf graf--p graf-after--p">You can see on the bottom right, these red arrows are max pooling operation, these green arrows are upward sampling, and then these gray arrows are copying. So we copy and concat. In other words, the input image after a couple of convs is copied over to the output, concatenated together, and so now we get to use all of the informations gone through all of the informations gone through all the down and all the up, plus also a slightly modified version of the input pixels. And slightly modified version of one thing down from the input pixels because they came up through here. So we have all of the richness of going all the way down and up, but also a slightly less coarse version and a slightly less coarse version and then the really simple version, and they can all be combined together. So that’s U-Net. It’s such a cool idea.</p><p name="0c3f" id="0c3f" class="graf graf--p graf-after--p">Here we are in the carvana-unet notebook. All this is the same code as before.</p><pre name="f105" id="f105" class="graf graf--pre graf-after--p">%matplotlib inline<br>%reload_ext autoreload<br>%autoreload 2</pre><pre name="b9dd" id="b9dd" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">from</strong> <strong class="markup--strong markup--pre-strong">fastai.conv_learner</strong> <strong class="markup--strong markup--pre-strong">import</strong> *<br><strong class="markup--strong markup--pre-strong">from</strong> <strong class="markup--strong markup--pre-strong">fastai.dataset</strong> <strong class="markup--strong markup--pre-strong">import</strong> *<br><strong class="markup--strong markup--pre-strong">from</strong> <strong class="markup--strong markup--pre-strong">fastai.models.resnet</strong> <strong class="markup--strong markup--pre-strong">import</strong> vgg_resnet50<br><br><strong class="markup--strong markup--pre-strong">import</strong> <strong class="markup--strong markup--pre-strong">json</strong></pre><pre name="c574" id="c574" class="graf graf--pre graf-after--pre">torch.backends.cudnn.benchmark=<strong class="markup--strong markup--pre-strong">True</strong></pre><h3 name="a68a" id="a68a" class="graf graf--h3 graf-after--pre">Data</h3><pre name="ac3e" id="ac3e" class="graf graf--pre graf-after--h3">PATH = Path('data/carvana')<br>MASKS_FN = 'train_masks.csv'<br>META_FN = 'metadata.csv'<br>masks_csv = pd.read_csv(PATH/MASKS_FN)<br>meta_csv = pd.read_csv(PATH/META_FN)</pre><pre name="4c94" id="4c94" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">def</strong> show_img(im, figsize=<strong class="markup--strong markup--pre-strong">None</strong>, ax=<strong class="markup--strong markup--pre-strong">None</strong>, alpha=<strong class="markup--strong markup--pre-strong">None</strong>):<br>    <strong class="markup--strong markup--pre-strong">if</strong> <strong class="markup--strong markup--pre-strong">not</strong> ax: fig,ax = plt.subplots(figsize=figsize)<br>    ax.imshow(im, alpha=alpha)<br>    ax.set_axis_off()<br>    <strong class="markup--strong markup--pre-strong">return</strong> ax</pre><pre name="1f89" id="1f89" class="graf graf--pre graf-after--pre">TRAIN_DN = 'train-128'<br>MASKS_DN = 'train_masks-128'<br>sz = 128<br>bs = 64<br>nw = 16</pre><pre name="9e98" id="9e98" class="graf graf--pre graf-after--pre">TRAIN_DN = 'train'<br>MASKS_DN = 'train_masks_png'<br>sz = 128<br>bs = 64<br>nw = 16</pre><pre name="6d6b" id="6d6b" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">class</strong> <strong class="markup--strong markup--pre-strong">MatchedFilesDataset</strong>(FilesDataset):<br>    <strong class="markup--strong markup--pre-strong">def</strong> __init__(self, fnames, y, transform, path):<br>        self.y=y<br>        <strong class="markup--strong markup--pre-strong">assert</strong>(len(fnames)==len(y))<br>        super().__init__(fnames, transform, path)<br>    <strong class="markup--strong markup--pre-strong">def</strong> get_y(self, i): <br>        <strong class="markup--strong markup--pre-strong">return</strong> open_image(os.path.join(self.path, self.y[i]))<br>    <strong class="markup--strong markup--pre-strong">def</strong> get_c(self): <strong class="markup--strong markup--pre-strong">return</strong> 0</pre><pre name="18ff" id="18ff" class="graf graf--pre graf-after--pre">x_names = np.array([Path(TRAIN_DN)/o <strong class="markup--strong markup--pre-strong">for</strong> o <strong class="markup--strong markup--pre-strong">in</strong> masks_csv['img']])<br>y_names = np.array([Path(MASKS_DN)/f'<strong class="markup--strong markup--pre-strong">{o[:-4]}</strong>_mask.png' <br>                        <strong class="markup--strong markup--pre-strong">for</strong> o <strong class="markup--strong markup--pre-strong">in</strong> masks_csv['img']])</pre><pre name="ca81" id="ca81" class="graf graf--pre graf-after--pre">val_idxs = list(range(1008))<br>((val_x,trn_x),(val_y,trn_y)) = split_by_idx(val_idxs, x_names, <br>                                             y_names)</pre><pre name="4f6d" id="4f6d" class="graf graf--pre graf-after--pre">aug_tfms = [RandomRotate(4, tfm_y=TfmType.CLASS),<br>            RandomFlip(tfm_y=TfmType.CLASS),<br>            RandomLighting(0.05, 0.05, tfm_y=TfmType.CLASS)]</pre><pre name="947a" id="947a" class="graf graf--pre graf-after--pre">tfms = tfms_from_model(resnet34, sz, crop_type=CropType.NO, <br>                        tfm_y=TfmType.CLASS, aug_tfms=aug_tfms)<br>datasets = ImageData.get_ds(MatchedFilesDataset, (trn_x,trn_y), <br>                             (val_x,val_y), tfms, path=PATH)<br>md = ImageData(PATH, datasets, bs, num_workers=16, classes=<strong class="markup--strong markup--pre-strong">None</strong>)<br>denorm = md.trn_ds.denorm</pre><pre name="d275" id="d275" class="graf graf--pre graf-after--pre">x,y = next(iter(md.trn_dl))</pre><pre name="c095" id="c095" class="graf graf--pre graf-after--pre">x.shape,y.shape</pre><pre name="91d0" id="91d0" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">(torch.Size([64, 3, 128, 128]), torch.Size([64, 128, 128]))</em></pre><h3 name="c5a9" id="c5a9" class="graf graf--h3 graf-after--pre">Simple upsample</h3><p name="6874" id="6874" class="graf graf--p graf-after--h3">And at the start, I’ve got a simple upsample version just to show you again the non U-net version. This time, I’m going to add in something called the dice metric. Dice is very similar, as you see, to Jaccard or I over U. It’s just a minor difference. It’s basically intersection over union with a minor tweak. The reason we are going to use dice is that’s the metric that Kaggle competition used and it’s a little bit harder to get a high dice score than a high accuracy because it’s really looking at what the overlap of the correct pixels are with your pixels. But it’s pretty similar.</p><p name="933f" id="933f" class="graf graf--p graf-after--p">So in the Kaggle competition, people that were doing okay were getting about 99.6 dice and the winners were about 99.7 dice.</p><pre name="62eb" id="62eb" class="graf graf--pre graf-after--p">f = resnet34<br>cut,lr_cut = model_meta[f]</pre><pre name="7461" id="7461" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">def</strong> get_base():<br>    layers = cut_model(f(<strong class="markup--strong markup--pre-strong">True</strong>), cut)<br>    <strong class="markup--strong markup--pre-strong">return</strong> nn.Sequential(*layers)</pre><pre name="dc8d" id="dc8d" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">def</strong> dice(pred, targs):<br>    pred = (pred&gt;0).float()<br>    <strong class="markup--strong markup--pre-strong">return</strong> 2. * (pred*targs).sum() / (pred+targs).sum()</pre><p name="8d29" id="8d29" class="graf graf--p graf-after--pre">Here is our standard upsample.</p><pre name="a159" id="a159" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">class</strong> <strong class="markup--strong markup--pre-strong">StdUpsample</strong>(nn.Module):<br>    <strong class="markup--strong markup--pre-strong">def</strong> __init__(self, nin, nout):<br>        super().__init__()<br>        self.conv = nn.ConvTranspose2d(nin, nout, 2, stride=2)<br>        self.bn = nn.BatchNorm2d(nout)<br>        <br>    <strong class="markup--strong markup--pre-strong">def</strong> forward(self, x): <strong class="markup--strong markup--pre-strong">return</strong> self.bn(F.relu(self.conv(x)))</pre><p name="27b2" id="27b2" class="graf graf--p graf-after--pre">This all as before.</p><pre name="4f5a" id="4f5a" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">class</strong> <strong class="markup--strong markup--pre-strong">Upsample34</strong>(nn.Module):<br>    <strong class="markup--strong markup--pre-strong">def</strong> __init__(self, rn):<br>        super().__init__()<br>        self.rn = rn<br>        self.features = nn.Sequential(<br>            rn, nn.ReLU(),<br>            StdUpsample(512,256),<br>            StdUpsample(256,256),<br>            StdUpsample(256,256),<br>            StdUpsample(256,256),<br>            nn.ConvTranspose2d(256, 1, 2, stride=2))<br>        <br>    <strong class="markup--strong markup--pre-strong">def</strong> forward(self,x): <strong class="markup--strong markup--pre-strong">return</strong> self.features(x)[:,0]</pre><pre name="32ac" id="32ac" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">class</strong> <strong class="markup--strong markup--pre-strong">UpsampleModel</strong>():<br>    <strong class="markup--strong markup--pre-strong">def</strong> __init__(self,model,name='upsample'):<br>        self.model,self.name = model,name<br><br>    <strong class="markup--strong markup--pre-strong">def</strong> get_layer_groups(self, precompute):<br>        lgs = list(split_by_idxs(children(self.model.rn), [lr_cut]))<br>        <strong class="markup--strong markup--pre-strong">return</strong> lgs + [children(self.model.features)[1:]]</pre><pre name="c218" id="c218" class="graf graf--pre graf-after--pre">m_base = get_base() </pre><pre name="b10e" id="b10e" class="graf graf--pre graf-after--pre">m = to_gpu(Upsample34(m_base))<br>models = UpsampleModel(m)</pre><pre name="bfc2" id="bfc2" class="graf graf--pre graf-after--pre">learn = ConvLearner(md, models)<br>learn.opt_fn=optim.Adam<br>learn.crit=nn.BCEWithLogitsLoss()<br>learn.metrics=[accuracy_thresh(0.5),dice]</pre><pre name="57f0" id="57f0" class="graf graf--pre graf-after--pre">learn.freeze_to(1)</pre><pre name="c11f" id="c11f" class="graf graf--pre graf-after--pre">learn.lr_find()<br>learn.sched.plot()</pre><pre name="ba37" id="ba37" class="graf graf--pre graf-after--pre">86%|█████████████████████████████████████████████████████████████          | 55/64 [00:22&lt;00:03,  2.46it/s, loss=3.21]</pre><figure name="40ce" id="40ce" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_X_dHSL-SZqkKw31hZgughg.png"></figure><pre name="deaa" id="deaa" class="graf graf--pre graf-after--figure">lr=4e-2<br>wd=1e-7<br>lrs = np.array([lr/100,lr/10,lr])/2</pre><pre name="66ec" id="66ec" class="graf graf--pre graf-after--pre">learn.fit(lr,1, wds=wd, cycle_len=4,use_clr=(20,8))</pre><pre name="b940" id="b940" class="graf graf--pre graf-after--pre">0%|          | 0/64 [00:00&lt;?, ?it/s]<br>epoch      trn_loss   val_loss   &lt;lambda&gt;   dice           <br>    0      0.216882   0.133512   0.938017   0.855221  <br>    1      0.169544   0.115158   0.946518   0.878381       <br>    2      0.153114   0.099104   0.957748   0.903353       <br>    3      0.144105   0.093337   0.964404   0.915084</pre><pre name="0723" id="0723" class="graf graf--pre graf-after--pre">[0.09333742126112893, 0.9644036065964472, 0.9150839788573129]</pre><pre name="8b4c" id="8b4c" class="graf graf--pre graf-after--pre">learn.save('tmp')</pre><pre name="cd9c" id="cd9c" class="graf graf--pre graf-after--pre">learn.load('tmp')</pre><pre name="3ffa" id="3ffa" class="graf graf--pre graf-after--pre">learn.unfreeze()<br>learn.bn_freeze(<strong class="markup--strong markup--pre-strong">True</strong>)</pre><pre name="9578" id="9578" class="graf graf--pre graf-after--pre">learn.fit(lrs,1,cycle_len=4,use_clr=(20,8))</pre><pre name="add2" id="add2" class="graf graf--pre graf-after--pre">epoch      trn_loss   val_loss   &lt;lambda&gt;   dice           <br>    0      0.174897   0.061603   0.976321   0.94382   <br>    1      0.122911   0.053625   0.982206   0.957624       <br>    2      0.106837   0.046653   0.985577   0.965792       <br>    3      0.099075   0.042291   0.986519   0.968925</pre><pre name="0294" id="0294" class="graf graf--pre graf-after--pre">[0.042291240323157536, 0.986519161670927, 0.9689251193924556]</pre><p name="f747" id="f747" class="graf graf--p graf-after--pre">Now we can check our dice metric [<a href="https://youtu.be/nG3tT31nPmQ?t=1h48m" data-href="https://youtu.be/nG3tT31nPmQ?t=1h48m" class="markup--anchor markup--p-anchor" rel="noopener nofollow" target="_blank">1:48:00</a>]. So you can see on dice metric, we are getting around 96.8 at 128x128. So that’s not great.</p><pre name="b497" id="b497" class="graf graf--pre graf-after--p">learn.save('128')</pre><pre name="55ee" id="55ee" class="graf graf--pre graf-after--pre">x,y = next(iter(md.val_dl))<br>py = to_np(learn.model(V(x)))</pre><pre name="508f" id="508f" class="graf graf--pre graf-after--pre">show_img(py[0]&gt;0);</pre><figure name="1980" id="1980" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_w6f-XvZMeLKt4Fc7O_S4EQ.png"></figure><pre name="a981" id="a981" class="graf graf--pre graf-after--figure">show_img(y[0]);</pre><figure name="8eda" id="8eda" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_SHntdwiyRvupP9SQO5BD5g.png"></figure><h4 name="5e27" id="5e27" class="graf graf--h4 graf-after--figure">U-net (ish) [<a href="https://youtu.be/nG3tT31nPmQ?t=1h48m16s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h48m16s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">1:48:16</a>]</h4><p name="340c" id="340c" class="graf graf--p graf-after--h4">So let’s try U-Net. I’m calling it U-net(ish) because as per usual I’m creating my own somewhat hacky version — trying to keep things as similar to what you’re used to as possible and doing things that I think makes sense. So there should be plenty of opportunity for you to at least make this more authentically U-net by looking at the exact grid sizes and see how here (the top left convs) the size is going down a little bit. So they are obviously not adding any padding and then there are some cropping going on — there’s a few differences. But one of the things is because I want to take advantage of transfer learning — that means I can’t quite use U-Net.</p><p name="e4c3" id="e4c3" class="graf graf--p graf-after--p">So here is another big opportunity is what if you create the U-Net down path and then add a classifier on the end and then train that on ImageNet. You’ve now got an ImageNet trained classifier which is specifically designed to be a good backbone for U-Net. Then you should be able to now come back and get pretty closed to winning this old competition (it’s actually not that old — it’s fairly recent competition). Because that pre-trained network didn’t exist before. But if you think about what YOLO v3 did, it’s basically that. They created a DarkNet, they pre-trained it on ImageNet, and then they used it as the basis for their bounding boxes. So again, this idea of pre-training things which are designed not just for classification but designed for other things — it’s just something that nobody has done yet. But as we’ve shown, you can train ImageNet for $25 in three hours now. And if people in the community are interested in doing this, hopefully I’ll have credits I can help you with as well so if you do, the work to get it set up and give me a script, I can probably run it for you. For now though, we don’t have that yet. So we are going to use ResNet.</p><pre name="6259" id="6259" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">class</strong> <strong class="markup--strong markup--pre-strong">SaveFeatures</strong>():<br>    features=<strong class="markup--strong markup--pre-strong">None</strong><br>    <strong class="markup--strong markup--pre-strong">def</strong> __init__(self, m):<br>        self.hook = m.register_forward_hook(self.hook_fn)<br>    <strong class="markup--strong markup--pre-strong">def</strong> hook_fn(self, module, input, output): self.features = output<br>    <strong class="markup--strong markup--pre-strong">def</strong> remove(self): self.hook.remove()</pre><p name="b8f8" id="b8f8" class="graf graf--p graf-after--pre">So we are basically going to start with <code class="markup--code markup--p-code">get_base</code> [<a href="https://youtu.be/nG3tT31nPmQ?t=1h50m37s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h50m37s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:50:37</a>]. Base is our base network and that was defined back up in the first section.</p><figure name="1288" id="1288" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_BDJmGsOK8kX9gHUyiQ3Xgw.png"></figure><p name="a160" id="a160" class="graf graf--p graf-after--figure">So get_base is going to be something that calls whatever f is and <code class="markup--code markup--p-code">f</code> is <code class="markup--code markup--p-code">resnet34</code>. So we are going to grab our ResNet34 and cut_model is the first thing that our convnet builder does. It basically removes everything from the adaptive pooling onwards, so that gives us back the backbone of ResNet34. So <code class="markup--code markup--p-code">get_base</code> is going to give us back the ResNet34 backbone.</p><pre name="dfdb" id="dfdb" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">class</strong> <strong class="markup--strong markup--pre-strong">UnetBlock</strong>(nn.Module):<br>    <strong class="markup--strong markup--pre-strong">def</strong> __init__(self, up_in, x_in, n_out):<br>        super().__init__()<br>        up_out = x_out = n_out//2<br>        self.x_conv  = nn.Conv2d(x_in,  x_out,  1)<br>        self.tr_conv = nn.ConvTranspose2d(up_in, up_out, 2, <br>                                          stride=2)<br>        self.bn = nn.BatchNorm2d(n_out)<br>        <br>    <strong class="markup--strong markup--pre-strong">def</strong> forward(self, up_p, x_p):<br>        up_p = self.tr_conv(up_p)<br>        x_p = self.x_conv(x_p)<br>        cat_p = torch.cat([up_p,x_p], dim=1)<br>        <strong class="markup--strong markup--pre-strong">return</strong> self.bn(F.relu(cat_p))</pre><pre name="b098" id="b098" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">class</strong> <strong class="markup--strong markup--pre-strong">Unet34</strong>(nn.Module):<br>    <strong class="markup--strong markup--pre-strong">def</strong> __init__(self, rn):<br>        super().__init__()<br>        self.rn = rn<br>        self.sfs = [SaveFeatures(rn[i]) <strong class="markup--strong markup--pre-strong">for</strong> i <strong class="markup--strong markup--pre-strong">in</strong> [2,4,5,6]]<br>        self.up1 = UnetBlock(512,256,256)<br>        self.up2 = UnetBlock(256,128,256)<br>        self.up3 = UnetBlock(256,64,256)<br>        self.up4 = UnetBlock(256,64,256)<br>        self.up5 = nn.ConvTranspose2d(256, 1, 2, stride=2)<br>        <br>    <strong class="markup--strong markup--pre-strong">def</strong> forward(self,x):<br>        x = F.relu(self.rn(x))<br>        x = self.up1(x, self.sfs[3].features)<br>        x = self.up2(x, self.sfs[2].features)<br>        x = self.up3(x, self.sfs[1].features)<br>        x = self.up4(x, self.sfs[0].features)<br>        x = self.up5(x)<br>        <strong class="markup--strong markup--pre-strong">return</strong> x[:,0]<br>    <br>    <strong class="markup--strong markup--pre-strong">def</strong> close(self):<br>        <strong class="markup--strong markup--pre-strong">for</strong> sf <strong class="markup--strong markup--pre-strong">in</strong> self.sfs: sf.remove()</pre><pre name="1a9f" id="1a9f" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">class</strong> <strong class="markup--strong markup--pre-strong">UnetModel</strong>():<br>    <strong class="markup--strong markup--pre-strong">def</strong> __init__(self,model,name='unet'):<br>        self.model,self.name = model,name<br><br>    <strong class="markup--strong markup--pre-strong">def</strong> get_layer_groups(self, precompute):<br>        lgs = list(split_by_idxs(children(self.model.rn), [lr_cut]))<br>        <strong class="markup--strong markup--pre-strong">return</strong> lgs + [children(self.model)[1:]]</pre><p name="0992" id="0992" class="graf graf--p graf-after--pre">Then we are going to take that ResNet34 backbone and turn it into a, I call it a, Unet34 [<a href="https://youtu.be/nG3tT31nPmQ?t=1h51m17s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h51m17s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:51:17</a>]. So what that’s going to do is it’s going to save that ResNet that we passed in and then we are going to use a forward hook just like before to save the results at the 2nd, 4th, 5th, and 6th blocks which as before is the layers before each stride 2 convolution. Then we are going to create a bunch of these things we are calling <code class="markup--code markup--p-code">UnetBlock</code>. We need to tell <code class="markup--code markup--p-code">UnetBlock</code> how many things are coming from the previous layer we are upsampling, how many are coming across, and then how many do we want to come out. The amount coming across is entirely defined by whatever the base network was — whatever the downward path was, we need that many layers. So this is a little bit awkward. Actually one of our master’s students here, Kerem, has actually created something called DynamicUnet that you’ll find in <a href="https://github.com/fastai/fastai/blob/d3ef60a96cddf5b503361ed4c95d68dda4a873fc/fastai/models/unet.py#L53" data-href="https://github.com/fastai/fastai/blob/d3ef60a96cddf5b503361ed4c95d68dda4a873fc/fastai/models/unet.py#L53" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">fastai.model.DynamicUnet</a> and it actually calculates this all for you and automatically creates the whole Unet from your base model. It’s got some minor quirks still that I want to fix. By the time the video is out, it’ll definitely be working and I will at least have a notebook showing how to use it and possibly an additional video. But for now you’ll just have to go through and do it yourself. You can easily see it just by, once you’ve got a ResNet, you can just type in its name and it’ll print out the layers. And you can see how many many activations there are in each block. Or you can have it printed out for you for each block automatically. Anyway, I just did this manually.</p><figure name="cfb4" id="cfb4" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_uJ4edTfPiSXfCXkFQ82Svg.png"></figure><p name="673e" id="673e" class="graf graf--p graf-after--figure">So the UnetBlock works like this [<a href="https://youtu.be/nG3tT31nPmQ?t=1h53m29s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h53m29s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:53:29</a>]:</p><ul class="postList"><li name="f390" id="f390" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">up_in</code>&nbsp;: This many are coming up from the previous layer</li><li name="9340" id="9340" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">x_in</code>&nbsp;: This many are coming across (hence <code class="markup--code markup--li-code">x</code>) from the downward path</li><li name="cb92" id="cb92" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">n_out</code>&nbsp;: The amount we want coming out</li></ul><p name="3d2e" id="3d2e" class="graf graf--p graf-after--li">Now what I do is&nbsp;, I then say, okay we’re going to create a certain amount of convolutions from the upward path and a certain amount from the cross path, and so I’m going to be concatenating them together so let’s divide the number we want out by 2. And so we are going to have our cross convolution take our cross path and create number out divided by 2 (<code class="markup--code markup--p-code">n_out//2</code>). And then the upward path is going to be a <code class="markup--code markup--p-code">ConvTranspose2d</code> because we want to increase/upsample. Again here, we’ve got the number out divided by 2 (<code class="markup--code markup--p-code">up_out</code>), then at the end, I just concatenate those together.</p><p name="7b32" id="7b32" class="graf graf--p graf-after--p">So I’ve got an upward sample, I’ve got a cross convolution, I can concatenate the two together. That’s all a UnetBlock is. So that’s actually a pretty easy module to create.</p><figure name="263d" id="263d" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_cXPJlacjby171FsaalyHcQ.png"></figure><p name="e27e" id="e27e" class="graf graf--p graf-after--figure">Then in my forward path, I need to pass to the forward of the UnetBlock the upward path and the cross path [<a href="https://youtu.be/nG3tT31nPmQ?t=1h54m40s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h54m40s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:54:40</a>]. The upward path is just whatever I am up to so far. But then the cross path is whatever the activations are that I stored on the way down. So as I come up, it’s the last set of saved features that I need first. And as I gradually keep going up farther and farther, eventually it’s the first set of features.</p><p name="7037" id="7037" class="graf graf--p graf-after--p">There are some more tricks we can do to make this a little bit better, but this is a good stuff. So the simple upsampling approach looked horrible and had a dice of&nbsp;.968. A Unet with everything else identical except we’ve now got these UnetBlocks has a dice of&nbsp;…</p><pre name="93b4" id="93b4" class="graf graf--pre graf-after--p">m_base = get_base()<br>m = to_gpu(Unet34(m_base))<br>models = UnetModel(m)</pre><pre name="baf5" id="baf5" class="graf graf--pre graf-after--pre">learn = ConvLearner(md, models)<br>learn.opt_fn=optim.Adam<br>learn.crit=nn.BCEWithLogitsLoss()<br>learn.metrics=[accuracy_thresh(0.5),dice]</pre><pre name="daf1" id="daf1" class="graf graf--pre graf-after--pre">learn.summary()</pre><pre name="8032" id="8032" class="graf graf--pre graf-after--pre">OrderedDict([('Conv2d-1',<br>              OrderedDict([('input_shape', [-1, 3, 128, 128]),<br>                           ('output_shape', [-1, 64, 64, 64]),<br>                           ('trainable', False),<br>                           ('nb_params', 9408)])),<br>             ('BatchNorm2d-2',<br>              OrderedDict([('input_shape', [-1, 64, 64, 64]),<br>                           ('output_shape', [-1, 64, 64, 64]),<br>                           ('trainable', False),<br>                           ('nb_params', 128)])),<br>             ('ReLU-3',<br>              OrderedDict([('input_shape', [-1, 64, 64, 64]),<br>                           ('output_shape', [-1, 64, 64, 64]),<br>                           ('nb_params', 0)])),<br>             ('MaxPool2d-4',<br>              OrderedDict([('input_shape', [-1, 64, 64, 64]),<br>                           ('output_shape', [-1, 64, 32, 32]),<br>                           ('nb_params', 0)])),<br>             ('Conv2d-5',<br>              OrderedDict([('input_shape', [-1, 64, 32, 32]),<br>                           ('output_shape', [-1, 64, 32, 32]),<br>                           ('trainable', False),<br>                           ('nb_params', 36864)])),<br>             ('BatchNorm2d-6',<br>              OrderedDict([('input_shape', [-1, 64, 32, 32]),<br>                           ('output_shape', [-1, 64, 32, 32]),<br>                           ('trainable', False),<br>                           ('nb_params', 128)])),<br>             ('ReLU-7',<br>              OrderedDict([('input_shape', [-1, 64, 32, 32]),<br>                           ('output_shape', [-1, 64, 32, 32]),<br>                           ('nb_params', 0)])),<br>             ('Conv2d-8',<br>              OrderedDict([('input_shape', [-1, 64, 32, 32]),<br>                           ('output_shape', [-1, 64, 32, 32]),<br>                           ('trainable', False),<br>                           ('nb_params', 36864)])),<br>             ('BatchNorm2d-9',<br>              OrderedDict([('input_shape', [-1, 64, 32, 32]),<br>                           ('output_shape', [-1, 64, 32, 32]),<br>                           ('trainable', False),<br>                           ('nb_params', 128)])),<br>             ('ReLU-10',<br>              OrderedDict([('input_shape', [-1, 64, 32, 32]),<br>                           ('output_shape', [-1, 64, 32, 32]),<br>                           ('nb_params', 0)])),<br>             ('BasicBlock-11',<br>              OrderedDict([('input_shape', [-1, 64, 32, 32]),<br>                           ('output_shape', [-1, 64, 32, 32]),<br>                           ('nb_params', 0)])),<br>             ('Conv2d-12',<br>              OrderedDict([('input_shape', [-1, 64, 32, 32]),<br>                           ('output_shape', [-1, 64, 32, 32]),<br>                           ('trainable', False),<br>                           ('nb_params', 36864)])),<br>             ('BatchNorm2d-13',<br>              OrderedDict([('input_shape', [-1, 64, 32, 32]),<br>                           ('output_shape', [-1, 64, 32, 32]),<br>                           ('trainable', False),<br>                           ('nb_params', 128)])),<br>             ('ReLU-14',<br>              OrderedDict([('input_shape', [-1, 64, 32, 32]),<br>                           ('output_shape', [-1, 64, 32, 32]),<br>                           ('nb_params', 0)])),<br>             ('Conv2d-15',<br>              OrderedDict([('input_shape', [-1, 64, 32, 32]),<br>                           ('output_shape', [-1, 64, 32, 32]),<br>                           ('trainable', False),<br>                           ('nb_params', 36864)])),<br>             ('BatchNorm2d-16',<br>              OrderedDict([('input_shape', [-1, 64, 32, 32]),<br>                           ('output_shape', [-1, 64, 32, 32]),<br>                           ('trainable', False),<br>                           ('nb_params', 128)])),<br>             ('ReLU-17',<br>              OrderedDict([('input_shape', [-1, 64, 32, 32]),<br>                           ('output_shape', [-1, 64, 32, 32]),<br>                           ('nb_params', 0)])),<br>             ('BasicBlock-18',<br>              OrderedDict([('input_shape', [-1, 64, 32, 32]),<br>                           ('output_shape', [-1, 64, 32, 32]),<br>                           ('nb_params', 0)])),<br>             ('Conv2d-19',<br>              OrderedDict([('input_shape', [-1, 64, 32, 32]),<br>                           ('output_shape', [-1, 64, 32, 32]),<br>                           ('trainable', False),<br>                           ('nb_params', 36864)])),<br>             ('BatchNorm2d-20',<br>              OrderedDict([('input_shape', [-1, 64, 32, 32]),<br>                           ('output_shape', [-1, 64, 32, 32]),<br>                           ('trainable', False),<br>                           ('nb_params', 128)])),<br>             ('ReLU-21',<br>              OrderedDict([('input_shape', [-1, 64, 32, 32]),<br>                           ('output_shape', [-1, 64, 32, 32]),<br>                           ('nb_params', 0)])),<br>             ('Conv2d-22',<br>              OrderedDict([('input_shape', [-1, 64, 32, 32]),<br>                           ('output_shape', [-1, 64, 32, 32]),<br>                           ('trainable', False),<br>                           ('nb_params', 36864)])),<br>             ('BatchNorm2d-23',<br>              OrderedDict([('input_shape', [-1, 64, 32, 32]),<br>                           ('output_shape', [-1, 64, 32, 32]),<br>                           ('trainable', False),<br>                           ('nb_params', 128)])),<br>             ('ReLU-24',<br>              OrderedDict([('input_shape', [-1, 64, 32, 32]),<br>                           ('output_shape', [-1, 64, 32, 32]),<br>                           ('nb_params', 0)])),<br>             ('BasicBlock-25',<br>              OrderedDict([('input_shape', [-1, 64, 32, 32]),<br>                           ('output_shape', [-1, 64, 32, 32]),<br>                           ('nb_params', 0)])),<br>             ('Conv2d-26',<br>              OrderedDict([('input_shape', [-1, 64, 32, 32]),<br>                           ('output_shape', [-1, 128, 16, 16]),<br>                           ('trainable', False),<br>                           ('nb_params', 73728)])),<br>             ('BatchNorm2d-27',<br>              OrderedDict([('input_shape', [-1, 128, 16, 16]),<br>                           ('output_shape', [-1, 128, 16, 16]),<br>                           ('trainable', False),<br>                           ('nb_params', 256)])),<br>             ('ReLU-28',<br>              OrderedDict([('input_shape', [-1, 128, 16, 16]),<br>                           ('output_shape', [-1, 128, 16, 16]),<br>                           ('nb_params', 0)])),<br>             ('Conv2d-29',<br>              OrderedDict([('input_shape', [-1, 128, 16, 16]),<br>                           ('output_shape', [-1, 128, 16, 16]),<br>                           ('trainable', False),<br>                           ('nb_params', 147456)])),<br>             ('BatchNorm2d-30',<br>              OrderedDict([('input_shape', [-1, 128, 16, 16]),<br>                           ('output_shape', [-1, 128, 16, 16]),<br>                           ('trainable', False),<br>                           ('nb_params', 256)])),<br>             ('Conv2d-31',<br>              OrderedDict([('input_shape', [-1, 64, 32, 32]),<br>                           ('output_shape', [-1, 128, 16, 16]),<br>                           ('trainable', False),<br>                           ('nb_params', 8192)])),<br>             ('BatchNorm2d-32',<br>              OrderedDict([('input_shape', [-1, 128, 16, 16]),<br>                           ('output_shape', [-1, 128, 16, 16]),<br>                           ('trainable', False),<br>                           ('nb_params', 256)])),<br>             ('ReLU-33',<br>              OrderedDict([('input_shape', [-1, 128, 16, 16]),<br>                           ('output_shape', [-1, 128, 16, 16]),<br>                           ('nb_params', 0)])),<br>             ('BasicBlock-34',<br>              OrderedDict([('input_shape', [-1, 64, 32, 32]),<br>                           ('output_shape', [-1, 128, 16, 16]),<br>                           ('nb_params', 0)])),<br>             ('Conv2d-35',<br>              OrderedDict([('input_shape', [-1, 128, 16, 16]),<br>                           ('output_shape', [-1, 128, 16, 16]),<br>                           ('trainable', False),<br>                           ('nb_params', 147456)])),<br>             ('BatchNorm2d-36',<br>              OrderedDict([('input_shape', [-1, 128, 16, 16]),<br>                           ('output_shape', [-1, 128, 16, 16]),<br>                           ('trainable', False),<br>                           ('nb_params', 256)])),<br>             ('ReLU-37',<br>              OrderedDict([('input_shape', [-1, 128, 16, 16]),<br>                           ('output_shape', [-1, 128, 16, 16]),<br>                           ('nb_params', 0)])),<br>             ('Conv2d-38',<br>              OrderedDict([('input_shape', [-1, 128, 16, 16]),<br>                           ('output_shape', [-1, 128, 16, 16]),<br>                           ('trainable', False),<br>                           ('nb_params', 147456)])),<br>             ('BatchNorm2d-39',<br>              OrderedDict([('input_shape', [-1, 128, 16, 16]),<br>                           ('output_shape', [-1, 128, 16, 16]),<br>                           ('trainable', False),<br>                           ('nb_params', 256)])),<br>             ('ReLU-40',<br>              OrderedDict([('input_shape', [-1, 128, 16, 16]),<br>                           ('output_shape', [-1, 128, 16, 16]),<br>                           ('nb_params', 0)])),<br>             ('BasicBlock-41',<br>              OrderedDict([('input_shape', [-1, 128, 16, 16]),<br>                           ('output_shape', [-1, 128, 16, 16]),<br>                           ('nb_params', 0)])),<br>             ('Conv2d-42',<br>              OrderedDict([('input_shape', [-1, 128, 16, 16]),<br>                           ('output_shape', [-1, 128, 16, 16]),<br>                           ('trainable', False),<br>                           ('nb_params', 147456)])),<br>             ('BatchNorm2d-43',<br>              OrderedDict([('input_shape', [-1, 128, 16, 16]),<br>                           ('output_shape', [-1, 128, 16, 16]),<br>                           ('trainable', False),<br>                           ('nb_params', 256)])),<br>             ('ReLU-44',<br>              OrderedDict([('input_shape', [-1, 128, 16, 16]),<br>                           ('output_shape', [-1, 128, 16, 16]),<br>                           ('nb_params', 0)])),<br>             ('Conv2d-45',<br>              OrderedDict([('input_shape', [-1, 128, 16, 16]),<br>                           ('output_shape', [-1, 128, 16, 16]),<br>                           ('trainable', False),<br>                           ('nb_params', 147456)])),<br>             ('BatchNorm2d-46',<br>              OrderedDict([('input_shape', [-1, 128, 16, 16]),<br>                           ('output_shape', [-1, 128, 16, 16]),<br>                           ('trainable', False),<br>                           ('nb_params', 256)])),<br>             ('ReLU-47',<br>              OrderedDict([('input_shape', [-1, 128, 16, 16]),<br>                           ('output_shape', [-1, 128, 16, 16]),<br>                           ('nb_params', 0)])),<br>             ('BasicBlock-48',<br>              OrderedDict([('input_shape', [-1, 128, 16, 16]),<br>                           ('output_shape', [-1, 128, 16, 16]),<br>                           ('nb_params', 0)])),<br>             ('Conv2d-49',<br>              OrderedDict([('input_shape', [-1, 128, 16, 16]),<br>                           ('output_shape', [-1, 128, 16, 16]),<br>                           ('trainable', False),<br>                           ('nb_params', 147456)])),<br>             ('BatchNorm2d-50',<br>              OrderedDict([('input_shape', [-1, 128, 16, 16]),<br>                           ('output_shape', [-1, 128, 16, 16]),<br>                           ('trainable', False),<br>                           ('nb_params', 256)])),<br>             ('ReLU-51',<br>              OrderedDict([('input_shape', [-1, 128, 16, 16]),<br>                           ('output_shape', [-1, 128, 16, 16]),<br>                           ('nb_params', 0)])),<br>             ('Conv2d-52',<br>              OrderedDict([('input_shape', [-1, 128, 16, 16]),<br>                           ('output_shape', [-1, 128, 16, 16]),<br>                           ('trainable', False),<br>                           ('nb_params', 147456)])),<br>             ('BatchNorm2d-53',<br>              OrderedDict([('input_shape', [-1, 128, 16, 16]),<br>                           ('output_shape', [-1, 128, 16, 16]),<br>                           ('trainable', False),<br>                           ('nb_params', 256)])),<br>             ('ReLU-54',<br>              OrderedDict([('input_shape', [-1, 128, 16, 16]),<br>                           ('output_shape', [-1, 128, 16, 16]),<br>                           ('nb_params', 0)])),<br>             ('BasicBlock-55',<br>              OrderedDict([('input_shape', [-1, 128, 16, 16]),<br>                           ('output_shape', [-1, 128, 16, 16]),<br>                           ('nb_params', 0)])),<br>             ('Conv2d-56',<br>              OrderedDict([('input_shape', [-1, 128, 16, 16]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('trainable', False),<br>                           ('nb_params', 294912)])),<br>             ('BatchNorm2d-57',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('trainable', False),<br>                           ('nb_params', 512)])),<br>             ('ReLU-58',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('nb_params', 0)])),<br>             ('Conv2d-59',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('trainable', False),<br>                           ('nb_params', 589824)])),<br>             ('BatchNorm2d-60',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('trainable', False),<br>                           ('nb_params', 512)])),<br>             ('Conv2d-61',<br>              OrderedDict([('input_shape', [-1, 128, 16, 16]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('trainable', False),<br>                           ('nb_params', 32768)])),<br>             ('BatchNorm2d-62',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('trainable', False),<br>                           ('nb_params', 512)])),<br>             ('ReLU-63',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('nb_params', 0)])),<br>             ('BasicBlock-64',<br>              OrderedDict([('input_shape', [-1, 128, 16, 16]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('nb_params', 0)])),<br>             ('Conv2d-65',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('trainable', False),<br>                           ('nb_params', 589824)])),<br>             ('BatchNorm2d-66',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('trainable', False),<br>                           ('nb_params', 512)])),<br>             ('ReLU-67',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('nb_params', 0)])),<br>             ('Conv2d-68',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('trainable', False),<br>                           ('nb_params', 589824)])),<br>             ('BatchNorm2d-69',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('trainable', False),<br>                           ('nb_params', 512)])),<br>             ('ReLU-70',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('nb_params', 0)])),<br>             ('BasicBlock-71',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('nb_params', 0)])),<br>             ('Conv2d-72',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('trainable', False),<br>                           ('nb_params', 589824)])),<br>             ('BatchNorm2d-73',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('trainable', False),<br>                           ('nb_params', 512)])),<br>             ('ReLU-74',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('nb_params', 0)])),<br>             ('Conv2d-75',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('trainable', False),<br>                           ('nb_params', 589824)])),<br>             ('BatchNorm2d-76',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('trainable', False),<br>                           ('nb_params', 512)])),<br>             ('ReLU-77',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('nb_params', 0)])),<br>             ('BasicBlock-78',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('nb_params', 0)])),<br>             ('Conv2d-79',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('trainable', False),<br>                           ('nb_params', 589824)])),<br>             ('BatchNorm2d-80',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('trainable', False),<br>                           ('nb_params', 512)])),<br>             ('ReLU-81',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('nb_params', 0)])),<br>             ('Conv2d-82',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('trainable', False),<br>                           ('nb_params', 589824)])),<br>             ('BatchNorm2d-83',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('trainable', False),<br>                           ('nb_params', 512)])),<br>             ('ReLU-84',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('nb_params', 0)])),<br>             ('BasicBlock-85',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('nb_params', 0)])),<br>             ('Conv2d-86',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('trainable', False),<br>                           ('nb_params', 589824)])),<br>             ('BatchNorm2d-87',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('trainable', False),<br>                           ('nb_params', 512)])),<br>             ('ReLU-88',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('nb_params', 0)])),<br>             ('Conv2d-89',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('trainable', False),<br>                           ('nb_params', 589824)])),<br>             ('BatchNorm2d-90',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('trainable', False),<br>                           ('nb_params', 512)])),<br>             ('ReLU-91',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('nb_params', 0)])),<br>             ('BasicBlock-92',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('nb_params', 0)])),<br>             ('Conv2d-93',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('trainable', False),<br>                           ('nb_params', 589824)])),<br>             ('BatchNorm2d-94',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('trainable', False),<br>                           ('nb_params', 512)])),<br>             ('ReLU-95',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('nb_params', 0)])),<br>             ('Conv2d-96',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('trainable', False),<br>                           ('nb_params', 589824)])),<br>             ('BatchNorm2d-97',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('trainable', False),<br>                           ('nb_params', 512)])),<br>             ('ReLU-98',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('nb_params', 0)])),<br>             ('BasicBlock-99',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('nb_params', 0)])),<br>             ('Conv2d-100',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 512, 4, 4]),<br>                           ('trainable', False),<br>                           ('nb_params', 1179648)])),<br>             ('BatchNorm2d-101',<br>              OrderedDict([('input_shape', [-1, 512, 4, 4]),<br>                           ('output_shape', [-1, 512, 4, 4]),<br>                           ('trainable', False),<br>                           ('nb_params', 1024)])),<br>             ('ReLU-102',<br>              OrderedDict([('input_shape', [-1, 512, 4, 4]),<br>                           ('output_shape', [-1, 512, 4, 4]),<br>                           ('nb_params', 0)])),<br>             ('Conv2d-103',<br>              OrderedDict([('input_shape', [-1, 512, 4, 4]),<br>                           ('output_shape', [-1, 512, 4, 4]),<br>                           ('trainable', False),<br>                           ('nb_params', 2359296)])),<br>             ('BatchNorm2d-104',<br>              OrderedDict([('input_shape', [-1, 512, 4, 4]),<br>                           ('output_shape', [-1, 512, 4, 4]),<br>                           ('trainable', False),<br>                           ('nb_params', 1024)])),<br>             ('Conv2d-105',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 512, 4, 4]),<br>                           ('trainable', False),<br>                           ('nb_params', 131072)])),<br>             ('BatchNorm2d-106',<br>              OrderedDict([('input_shape', [-1, 512, 4, 4]),<br>                           ('output_shape', [-1, 512, 4, 4]),<br>                           ('trainable', False),<br>                           ('nb_params', 1024)])),<br>             ('ReLU-107',<br>              OrderedDict([('input_shape', [-1, 512, 4, 4]),<br>                           ('output_shape', [-1, 512, 4, 4]),<br>                           ('nb_params', 0)])),<br>             ('BasicBlock-108',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 512, 4, 4]),<br>                           ('nb_params', 0)])),<br>             ('Conv2d-109',<br>              OrderedDict([('input_shape', [-1, 512, 4, 4]),<br>                           ('output_shape', [-1, 512, 4, 4]),<br>                           ('trainable', False),<br>                           ('nb_params', 2359296)])),<br>             ('BatchNorm2d-110',<br>              OrderedDict([('input_shape', [-1, 512, 4, 4]),<br>                           ('output_shape', [-1, 512, 4, 4]),<br>                           ('trainable', False),<br>                           ('nb_params', 1024)])),<br>             ('ReLU-111',<br>              OrderedDict([('input_shape', [-1, 512, 4, 4]),<br>                           ('output_shape', [-1, 512, 4, 4]),<br>                           ('nb_params', 0)])),<br>             ('Conv2d-112',<br>              OrderedDict([('input_shape', [-1, 512, 4, 4]),<br>                           ('output_shape', [-1, 512, 4, 4]),<br>                           ('trainable', False),<br>                           ('nb_params', 2359296)])),<br>             ('BatchNorm2d-113',<br>              OrderedDict([('input_shape', [-1, 512, 4, 4]),<br>                           ('output_shape', [-1, 512, 4, 4]),<br>                           ('trainable', False),<br>                           ('nb_params', 1024)])),<br>             ('ReLU-114',<br>              OrderedDict([('input_shape', [-1, 512, 4, 4]),<br>                           ('output_shape', [-1, 512, 4, 4]),<br>                           ('nb_params', 0)])),<br>             ('BasicBlock-115',<br>              OrderedDict([('input_shape', [-1, 512, 4, 4]),<br>                           ('output_shape', [-1, 512, 4, 4]),<br>                           ('nb_params', 0)])),<br>             ('Conv2d-116',<br>              OrderedDict([('input_shape', [-1, 512, 4, 4]),<br>                           ('output_shape', [-1, 512, 4, 4]),<br>                           ('trainable', False),<br>                           ('nb_params', 2359296)])),<br>             ('BatchNorm2d-117',<br>              OrderedDict([('input_shape', [-1, 512, 4, 4]),<br>                           ('output_shape', [-1, 512, 4, 4]),<br>                           ('trainable', False),<br>                           ('nb_params', 1024)])),<br>             ('ReLU-118',<br>              OrderedDict([('input_shape', [-1, 512, 4, 4]),<br>                           ('output_shape', [-1, 512, 4, 4]),<br>                           ('nb_params', 0)])),<br>             ('Conv2d-119',<br>              OrderedDict([('input_shape', [-1, 512, 4, 4]),<br>                           ('output_shape', [-1, 512, 4, 4]),<br>                           ('trainable', False),<br>                           ('nb_params', 2359296)])),<br>             ('BatchNorm2d-120',<br>              OrderedDict([('input_shape', [-1, 512, 4, 4]),<br>                           ('output_shape', [-1, 512, 4, 4]),<br>                           ('trainable', False),<br>                           ('nb_params', 1024)])),<br>             ('ReLU-121',<br>              OrderedDict([('input_shape', [-1, 512, 4, 4]),<br>                           ('output_shape', [-1, 512, 4, 4]),<br>                           ('nb_params', 0)])),<br>             ('BasicBlock-122',<br>              OrderedDict([('input_shape', [-1, 512, 4, 4]),<br>                           ('output_shape', [-1, 512, 4, 4]),<br>                           ('nb_params', 0)])),<br>             ('ConvTranspose2d-123',<br>              OrderedDict([('input_shape', [-1, 512, 4, 4]),<br>                           ('output_shape', [-1, 128, 8, 8]),<br>                           ('trainable', True),<br>                           ('nb_params', 262272)])),<br>             ('Conv2d-124',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 128, 8, 8]),<br>                           ('trainable', True),<br>                           ('nb_params', 32896)])),<br>             ('BatchNorm2d-125',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('trainable', True),<br>                           ('nb_params', 512)])),<br>             ('UnetBlock-126',<br>              OrderedDict([('input_shape', [-1, 512, 4, 4]),<br>                           ('output_shape', [-1, 256, 8, 8]),<br>                           ('nb_params', 0)])),<br>             ('ConvTranspose2d-127',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 128, 16, 16]),<br>                           ('trainable', True),<br>                           ('nb_params', 131200)])),<br>             ('Conv2d-128',<br>              OrderedDict([('input_shape', [-1, 128, 16, 16]),<br>                           ('output_shape', [-1, 128, 16, 16]),<br>                           ('trainable', True),<br>                           ('nb_params', 16512)])),<br>             ('BatchNorm2d-129',<br>              OrderedDict([('input_shape', [-1, 256, 16, 16]),<br>                           ('output_shape', [-1, 256, 16, 16]),<br>                           ('trainable', True),<br>                           ('nb_params', 512)])),<br>             ('UnetBlock-130',<br>              OrderedDict([('input_shape', [-1, 256, 8, 8]),<br>                           ('output_shape', [-1, 256, 16, 16]),<br>                           ('nb_params', 0)])),<br>             ('ConvTranspose2d-131',<br>              OrderedDict([('input_shape', [-1, 256, 16, 16]),<br>                           ('output_shape', [-1, 128, 32, 32]),<br>                           ('trainable', True),<br>                           ('nb_params', 131200)])),<br>             ('Conv2d-132',<br>              OrderedDict([('input_shape', [-1, 64, 32, 32]),<br>                           ('output_shape', [-1, 128, 32, 32]),<br>                           ('trainable', True),<br>                           ('nb_params', 8320)])),<br>             ('BatchNorm2d-133',<br>              OrderedDict([('input_shape', [-1, 256, 32, 32]),<br>                           ('output_shape', [-1, 256, 32, 32]),<br>                           ('trainable', True),<br>                           ('nb_params', 512)])),<br>             ('UnetBlock-134',<br>              OrderedDict([('input_shape', [-1, 256, 16, 16]),<br>                           ('output_shape', [-1, 256, 32, 32]),<br>                           ('nb_params', 0)])),<br>             ('ConvTranspose2d-135',<br>              OrderedDict([('input_shape', [-1, 256, 32, 32]),<br>                           ('output_shape', [-1, 128, 64, 64]),<br>                           ('trainable', True),<br>                           ('nb_params', 131200)])),<br>             ('Conv2d-136',<br>              OrderedDict([('input_shape', [-1, 64, 64, 64]),<br>                           ('output_shape', [-1, 128, 64, 64]),<br>                           ('trainable', True),<br>                           ('nb_params', 8320)])),<br>             ('BatchNorm2d-137',<br>              OrderedDict([('input_shape', [-1, 256, 64, 64]),<br>                           ('output_shape', [-1, 256, 64, 64]),<br>                           ('trainable', True),<br>                           ('nb_params', 512)])),<br>             ('UnetBlock-138',<br>              OrderedDict([('input_shape', [-1, 256, 32, 32]),<br>                           ('output_shape', [-1, 256, 64, 64]),<br>                           ('nb_params', 0)])),<br>             ('ConvTranspose2d-139',<br>              OrderedDict([('input_shape', [-1, 256, 64, 64]),<br>                           ('output_shape', [-1, 1, 128, 128]),<br>                           ('trainable', True),<br>                           ('nb_params', 1025)]))])</pre><pre name="35de" id="35de" class="graf graf--pre graf-after--pre">[o.features.size() <strong class="markup--strong markup--pre-strong">for</strong> o <strong class="markup--strong markup--pre-strong">in</strong> m.sfs]</pre><pre name="9db4" id="9db4" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">[torch.Size([3, 64, 64, 64]),<br> torch.Size([3, 64, 32, 32]),<br> torch.Size([3, 128, 16, 16]),<br> torch.Size([3, 256, 8, 8])]</em></pre><pre name="26ea" id="26ea" class="graf graf--pre graf-after--pre">learn.freeze_to(1)</pre><pre name="ff8d" id="ff8d" class="graf graf--pre graf-after--pre">learn.lr_find()<br>learn.sched.plot()</pre><pre name="93a7" id="93a7" class="graf graf--pre graf-after--pre"> 0%|                                                                                           | 0/64 [00:00&lt;?, ?it/s]</pre><pre name="597f" id="597f" class="graf graf--pre graf-after--pre">92%|█████████████████████████████████████████████████████████████████▍     | 59/64 [00:22&lt;00:01,  2.68it/s, loss=2.45]</pre><figure name="ed74" id="ed74" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_kSXmrtfSNjvDnBoLEAiUaw.png"></figure><pre name="b1ac" id="b1ac" class="graf graf--pre graf-after--figure">lr=4e-2<br>wd=1e-7<br><br>lrs = np.array([lr/100,lr/10,lr])</pre><pre name="f56f" id="f56f" class="graf graf--pre graf-after--pre">learn.fit(lr,1,wds=wd,cycle_len=8,use_clr=(5,8))</pre><pre name="1e40" id="1e40" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">epoch      trn_loss   val_loss   &lt;lambda&gt;   dice           <br>    0      0.12936    0.03934    0.988571   0.971385  <br>    1      0.098401   0.039252   0.990438   0.974921        <br>    2      0.087789   0.02539    0.990961   0.978927        <br>    3      0.082625   0.027984   0.988483   0.975948        <br>    4      0.079509   0.025003   0.99171    0.981221        <br>    5      0.076984   0.022514   0.992462   0.981881        <br>    6      0.076822   0.023203   0.992484   0.982321        <br>    7      0.075488   0.021956   0.992327   0.982704</em></pre><pre name="a505" id="a505" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">[0.021955982234979434, 0.9923273126284281, 0.9827044502137199]</em></pre><pre name="f074" id="f074" class="graf graf--pre graf-after--pre">learn.save('128urn-tmp')</pre><pre name="0b41" id="0b41" class="graf graf--pre graf-after--pre">learn.load('128urn-tmp')</pre><pre name="b057" id="b057" class="graf graf--pre graf-after--pre">learn.unfreeze()<br>learn.bn_freeze(<strong class="markup--strong markup--pre-strong">True</strong>)</pre><pre name="0ee9" id="0ee9" class="graf graf--pre graf-after--pre">learn.fit(lrs/4, 1, wds=wd, cycle_len=20,use_clr=(20,10))</pre><pre name="c6bd" id="c6bd" class="graf graf--pre graf-after--pre">0%|          | 0/64 [00:00&lt;?, ?it/s]<br>epoch      trn_loss   val_loss   &lt;lambda&gt;   dice            <br>    0      0.073786   0.023418   0.99297    0.98283   <br>    1      0.073561   0.020853   0.992142   0.982725        <br>    2      0.075227   0.023357   0.991076   0.980879        <br>    3      0.074245   0.02352    0.993108   0.983659        <br>    4      0.073434   0.021508   0.993024   0.983609        <br>    5      0.073092   0.020956   0.993188   0.983333        <br>    6      0.073617   0.019666   0.993035   0.984102        <br>    7      0.072786   0.019844   0.993196   0.98435         <br>    8      0.072256   0.018479   0.993282   0.984277        <br>    9      0.072052   0.019479   0.993164   0.984147        <br>    10     0.071361   0.019402   0.993344   0.984541        <br>    11     0.070969   0.018904   0.993139   0.984499        <br>    12     0.071588   0.018027   0.9935     0.984543        <br>    13     0.070709   0.018345   0.993491   0.98489         <br>    14     0.072238   0.019096   0.993594   0.984825        <br>    15     0.071407   0.018967   0.993446   0.984919        <br>    16     0.071047   0.01966    0.993366   0.984952        <br>    17     0.072024   0.018133   0.993505   0.98497         <br>    18     0.071517   0.018464   0.993602   0.985192        <br>    19     0.070109   0.018337   0.993614   0.9852</pre><pre name="aabb" id="aabb" class="graf graf--pre graf-after--pre">[0.018336569653853538, 0.9936137114252362, 0.9852004420189631]</pre><p name="df93" id="df93" class="graf graf--p graf-after--pre">.985! That’s like we halved the error with everything else exactly the same [<a href="https://youtu.be/nG3tT31nPmQ?t=1h55m42s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h55m42s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:55:42</a>]. And more the point, you can look at it.</p><pre name="f648" id="f648" class="graf graf--pre graf-after--p">learn.save('128urn-0')</pre><pre name="a362" id="a362" class="graf graf--pre graf-after--pre">learn.load('128urn-0')</pre><pre name="2295" id="2295" class="graf graf--pre graf-after--pre">x,y = next(iter(md.val_dl))<br>py = to_np(learn.model(V(x)))</pre><p name="c62d" id="c62d" class="graf graf--p graf-after--pre">This is actually looking somewhat car-like compared to our non-Unet equivalent which is just a blob. Because trying to do this through down and up paths — it’s just asking too much. Where else, when we actually provide the downward path pixels at every point, it can actually start to create something car-ish.</p><pre name="8a8b" id="8a8b" class="graf graf--pre graf-after--p">show_img(py[0]&gt;0);</pre><figure name="5bae" id="5bae" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_AuMRaTQP4gCUW0iHHvf2uQ.png"></figure><pre name="c36b" id="c36b" class="graf graf--pre graf-after--figure">show_img(y[0]);</pre><figure name="2dba" id="2dba" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_SHntdwiyRvupP9SQO5BD5g.png"></figure><p name="e9a3" id="e9a3" class="graf graf--p graf-after--figure">At the end of that, we’ll do m.close to remove those <code class="markup--code markup--p-code">sfs.features</code> taking up GPU memory.</p><pre name="426d" id="426d" class="graf graf--pre graf-after--p">m.close()</pre><h4 name="f39c" id="f39c" class="graf graf--h4 graf-after--pre">512x512 [<a href="https://youtu.be/nG3tT31nPmQ?t=1h56m26s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h56m26s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">1:56:26</a>]</h4><p name="09ca" id="09ca" class="graf graf--p graf-after--h4">Go to a smaller batch size, higher size</p><pre name="9e81" id="9e81" class="graf graf--pre graf-after--p">sz=512<br>bs=16</pre><pre name="6b68" id="6b68" class="graf graf--pre graf-after--pre">tfms = tfms_from_model(resnet34, sz, crop_type=CropType.NO, <br>                       tfm_y=TfmType.CLASS, aug_tfms=aug_tfms)<br>datasets = ImageData.get_ds(MatchedFilesDataset, (trn_x,trn_y), <br>                            (val_x,val_y), tfms, path=PATH)<br>md = ImageData(PATH, datasets, bs, num_workers=4, classes=<strong class="markup--strong markup--pre-strong">None</strong>)<br>denorm = md.trn_ds.denorm</pre><pre name="134a" id="134a" class="graf graf--pre graf-after--pre">m_base = get_base()<br>m = to_gpu(Unet34(m_base))<br>models = UnetModel(m)</pre><pre name="2824" id="2824" class="graf graf--pre graf-after--pre">learn = ConvLearner(md, models)<br>learn.opt_fn=optim.Adam<br>learn.crit=nn.BCEWithLogitsLoss()<br>learn.metrics=[accuracy_thresh(0.5),dice]</pre><pre name="3395" id="3395" class="graf graf--pre graf-after--pre">learn.freeze_to(1)</pre><pre name="653f" id="653f" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">learn.load('128urn-0')</strong></pre><pre name="397d" id="397d" class="graf graf--pre graf-after--pre">learn.fit(lr,1,wds=wd, cycle_len=5,use_clr=(5,5))</pre><pre name="6be3" id="6be3" class="graf graf--pre graf-after--pre">epoch      trn_loss   val_loss   &lt;lambda&gt;   dice              <br>    0      0.071421   0.02362    0.996459   0.991772  <br>    1      0.070373   0.014013   0.996558   0.992602          <br>    2      0.067895   0.011482   0.996705   0.992883          <br>    3      0.070653   0.014256   0.996695   0.992771          <br>    4      0.068621   0.013195   0.996993   0.993359</pre><pre name="1bbb" id="1bbb" class="graf graf--pre graf-after--pre">[0.013194938530288046, 0.996993034604996, 0.993358936574724]</pre><p name="eda9" id="eda9" class="graf graf--p graf-after--pre">You can see the dice coefficients really going up [<a href="https://youtu.be/nG3tT31nPmQ?t=1h56m30s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h56m30s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:56:30</a>]. So notice above, I’m loading in the 128x128 version of the network. We are doing this progressive resizing trick again, so that gets us&nbsp;.993.</p><pre name="e673" id="e673" class="graf graf--pre graf-after--p">learn.save('512urn-tmp')</pre><pre name="81f0" id="81f0" class="graf graf--pre graf-after--pre">learn.unfreeze()<br>learn.bn_freeze(<strong class="markup--strong markup--pre-strong">True</strong>)</pre><pre name="c937" id="c937" class="graf graf--pre graf-after--pre">learn.load('512urn-tmp')</pre><pre name="a246" id="a246" class="graf graf--pre graf-after--pre">learn.fit(lrs/4,1,wds=wd, cycle_len=8,use_clr=(20,8))</pre><pre name="ad71" id="ad71" class="graf graf--pre graf-after--pre">epoch      trn_loss   val_loss   &lt;lambda&gt;   dice              <br>    0      0.06605    0.013602   0.997      0.993014  <br>    1      0.066885   0.011252   0.997248   0.993563          <br>    2      0.065796   0.009802   0.997223   0.993817          <br>    3      0.065089   0.009668   0.997296   0.993744          <br>    4      0.064552   0.011683   0.997269   0.993835          <br>    5      0.065089   0.010553   0.997415   0.993827          <br>    6      0.064303   0.009472   0.997431   0.994046          <br>    7      0.062506   0.009623   0.997441   0.994118</pre><pre name="c98d" id="c98d" class="graf graf--pre graf-after--pre">[0.009623114736602894, 0.9974409020136273, 0.9941179137381296]</pre><p name="41d2" id="41d2" class="graf graf--p graf-after--pre">Then unfreeze to get to&nbsp;.994.</p><pre name="57bc" id="57bc" class="graf graf--pre graf-after--p">learn.save('512urn')</pre><pre name="eaeb" id="eaeb" class="graf graf--pre graf-after--pre">learn.load('512urn')</pre><pre name="2914" id="2914" class="graf graf--pre graf-after--pre">x,y = next(iter(md.val_dl))<br>py = to_np(learn.model(V(x)))</pre><p name="052f" id="052f" class="graf graf--p graf-after--pre">And you can see, it’s now looking pretty good.</p><pre name="dda0" id="dda0" class="graf graf--pre graf-after--p">show_img(py[0]&gt;0);</pre><figure name="2e85" id="2e85" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_lW-LsQorUM1UUwRDJiiMKg.png"></figure><pre name="41e9" id="41e9" class="graf graf--pre graf-after--figure">show_img(y[0]);</pre><figure name="4180" id="4180" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_EdCvr3nZIJf6mhwgQActnQ.png"></figure><pre name="f319" id="f319" class="graf graf--pre graf-after--figure">m.close()</pre><h4 name="f028" id="f028" class="graf graf--h4 graf-after--pre">1024x1024 [<a href="https://youtu.be/nG3tT31nPmQ?t=1h56m53s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h56m53s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">1:56:53</a>]</h4><p name="0df2" id="0df2" class="graf graf--p graf-after--h4">Go down to a batch size of 4, size of 1024.</p><pre name="8416" id="8416" class="graf graf--pre graf-after--p">sz=1024<br>bs=4</pre><pre name="0ece" id="0ece" class="graf graf--pre graf-after--pre">tfms = tfms_from_model(resnet34, sz, crop_type=CropType.NO, <br>                         tfm_y=TfmType.CLASS)<br>datasets = ImageData.get_ds(MatchedFilesDataset, (trn_x,trn_y), <br>                            (val_x,val_y), tfms, path=PATH)<br>md = ImageData(PATH, datasets, bs, num_workers=16, classes=<strong class="markup--strong markup--pre-strong">None</strong>)<br>denorm = md.trn_ds.denorm</pre><pre name="5a4a" id="5a4a" class="graf graf--pre graf-after--pre">m_base = get_base()<br>m = to_gpu(Unet34(m_base))<br>models = UnetModel(m)</pre><pre name="22d8" id="22d8" class="graf graf--pre graf-after--pre">learn = ConvLearner(md, models)<br>learn.opt_fn=optim.Adam<br>learn.crit=nn.BCEWithLogitsLoss()<br>learn.metrics=[accuracy_thresh(0.5),dice]</pre><p name="e9fe" id="e9fe" class="graf graf--p graf-after--pre">Load in what we just saved with the 512.</p><pre name="01bf" id="01bf" class="graf graf--pre graf-after--p">learn.load('512urn')</pre><pre name="813b" id="813b" class="graf graf--pre graf-after--pre">learn.freeze_to(1)</pre><pre name="a020" id="a020" class="graf graf--pre graf-after--pre">learn.fit(lr,1, wds=wd, cycle_len=2,use_clr=(5,4))</pre><pre name="78fc" id="78fc" class="graf graf--pre graf-after--pre">epoch      trn_loss   val_loss   &lt;lambda&gt;   dice                 <br>    0      0.007656   0.008155   0.997247   0.99353   <br>    1      0.004706   0.00509    0.998039   0.995437</pre><pre name="c979" id="c979" class="graf graf--pre graf-after--pre">[0.005090427414942828, 0.9980387706605215, 0.995437301104031]</pre><p name="f808" id="f808" class="graf graf--p graf-after--pre">That gets us to&nbsp;.995.</p><pre name="2f50" id="2f50" class="graf graf--pre graf-after--p">learn.save('1024urn-tmp')</pre><pre name="04c2" id="04c2" class="graf graf--pre graf-after--pre">learn.load('1024urn-tmp')</pre><pre name="9025" id="9025" class="graf graf--pre graf-after--pre">learn.unfreeze()<br>learn.bn_freeze(<strong class="markup--strong markup--pre-strong">True</strong>)</pre><pre name="b82a" id="b82a" class="graf graf--pre graf-after--pre">lrs = np.array([lr/200,lr/30,lr])</pre><pre name="4237" id="4237" class="graf graf--pre graf-after--pre">learn.fit(lrs/10,1, wds=wd,cycle_len=4,use_clr=(20,8))</pre><pre name="1db5" id="1db5" class="graf graf--pre graf-after--pre">epoch      trn_loss   val_loss   &lt;lambda&gt;   dice                 <br>    0      0.005688   0.006135   0.997616   0.994616  <br>    1      0.004412   0.005223   0.997983   0.995349             <br>    2      0.004186   0.004975   0.99806    0.99554              <br>    3      0.004016   0.004899   0.99812    0.995627</pre><pre name="e86a" id="e86a" class="graf graf--pre graf-after--pre">[0.004898778487196458, 0.9981196409180051, 0.9956271404784823]</pre><pre name="ca01" id="ca01" class="graf graf--pre graf-after--pre">learn.fit(lrs/10,1, wds=wd,cycle_len=4,use_clr=(20,8))</pre><pre name="218c" id="218c" class="graf graf--pre graf-after--pre">epoch      trn_loss   val_loss   &lt;lambda&gt;   dice                 <br>    0      0.004169   0.004962   0.998049   0.995517  <br>    1      0.004022   0.004595   0.99823    0.995818             <br>    2      0.003772   0.004497   0.998215   0.995916             <br>    3      0.003618   0.004435   0.998291   0.995991</pre><pre name="ce73" id="ce73" class="graf graf--pre graf-after--pre">[0.004434524739663753, 0.9982911745707194, 0.9959913929776539]</pre><p name="0c5e" id="0c5e" class="graf graf--p graf-after--pre">Unfreeze takes us to… we’ll call that&nbsp;.996.</p><pre name="4fb8" id="4fb8" class="graf graf--pre graf-after--p">learn.sched.plot_loss()</pre><figure name="b088" id="b088" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_b7J9qrMQ0OxTQgj0QebeFw.png"></figure><pre name="9f1f" id="9f1f" class="graf graf--pre graf-after--figure">learn.save('1024urn')</pre><pre name="fc36" id="fc36" class="graf graf--pre graf-after--pre">learn.load('1024urn')</pre><pre name="a16e" id="a16e" class="graf graf--pre graf-after--pre">x,y = next(iter(md.val_dl))<br>py = to_np(learn.model(V(x)))</pre><p name="1907" id="1907" class="graf graf--p graf-after--pre">As you can see, that actually looks good [<a href="https://youtu.be/nG3tT31nPmQ?t=1h57m17s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h57m17s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:57:17</a>]. In accuracy terms, 99.82%. You can see this is looking like something you could just about use to cut out. I think, at this point, there’s a couple of minor tweaks we can do to get up to&nbsp;.997 but really the key thing then, I think, is just maybe to do a few bit of smoothing maybe or a little bit of post-processing. You can go and have a look at the Carvana winners’ blogs and see some of these tricks, but as I say, the difference between where we are at&nbsp;.996 and what the winners got of&nbsp;.997, it’s not heaps. So really that just the Unet on its own pretty much solves that problem.</p><pre name="5f52" id="5f52" class="graf graf--pre graf-after--p">show_img(py[0]&gt;0);</pre><figure name="4412" id="4412" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_A6ghUxP4m0OMKyUZWnv3xQ.png"></figure><pre name="0b0d" id="0b0d" class="graf graf--pre graf-after--figure">show_img(y[0]);</pre><figure name="04ec" id="04ec" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_1eNTc9dNtmuxTryHf1XGpA.png"></figure><h3 name="2ea9" id="2ea9" class="graf graf--h3 graf-after--figure">Back to Bounding Box [<a href="https://youtu.be/nG3tT31nPmQ?t=1h58m15s" data-href="https://youtu.be/nG3tT31nPmQ?t=1h58m15s" class="markup--anchor markup--h3-anchor" rel="nofollow noopener" target="_blank">1:58:15</a>]</h3><p name="8276" id="8276" class="graf graf--p graf-after--h3">Okay, so that’s it. The last thing I wanted to mention is now to come all the way back to bounding boxes because you might remember, I said our bounding box model was still not doing very well on small objects. So hopefully you might be able to guess where I’m going to go with this which is that for the bounding box model, remember how we had at different grid cells we spat out outputs of the model. And it was those earlier ones with the small grid sizes that weren’t very good. How do we fix it? U-Net it! Let’s have an upward path with cross connections. So then we are just going to do a U-Net and then spit them out of that. Because now those finer grid cells have all of the information of that path, and that path, and that path, and that path for leverage. Now of course, this is deep learning so that means you can’t write a paper saying we just used U-Net for bounding boxes. You have to invent a new word so this is called feature pyramid networks or FPNs. And this was used in RetinaNet paper, it was created in an earlier paper specifically about FPNs. And if memory serves correctly, they did briefly cite the U-Net paper but they kind of made it sound like it was this vaguely slightly connected thing that maybe some people could consider slightly useful. But really, FPNs are U-Nets.</p><p name="7521" id="7521" class="graf graf--p graf-after--p">I don’t have an implementation of it to show you but it will be a fun thing, maybe for some of us to try and I know some of the students have been trying to get it working well on the forums. So yeah, interesting thing to try. So I think a couple of things to look at after this class as well as the other things I mentioned would be playing around with FPNs and also maybe trying Kerem’s DynamicUnet. They would both be interesting things to look at.</p><p name="bdf8" id="bdf8" class="graf graf--p graf-after--p graf--trailing">So you guys have all been through 14 lessons of me talking at you now. So I’m sorry about that. Thanks for putting up with me. I think you’re going to find it hard to find people who actually know them as much about training neural networks and practice as you do. It’ll be really easy for you to overestimate how capable all these other people are and underestimate how capable you are. So the main thing I’d say is, please practice, please. Just because you don’t have this constant thing getting you to come back here every Monday night now. It’s very easy to kind of lose that momentum. So find ways to keep it. Organize a study group, a book reading group, or get together with some friends and work on a project, or do something more than just deciding I want to keep working on X. Unless you are kind of person who’s super motivated and whenever you decide to do something, it happens. That’s not me. It’s like I know, for something to happen, I have to say “yes, David. In October, I will absolutely teach that course” and then it’s like okay I better actually write some material. That’s the only way I can get stuff to happen. So we’ve got a great community there on the forums. If people have ideas for ways to make it better, please tell me. If you think you can help with, if you want to create some new forum or moderated in some different way or whatever, just let me know. You can always PM me and there’s a lot of projects going on through GitHub as well — lots of stuff. So I hope to see you all back here at something else and thanks so much for joining me on this journey.</p><hr class="section-divider"><p name="dcdd" id="dcdd" class="graf graf--p graf--leading graf--trailing">Lessons: <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-1-602f73869197" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-1-602f73869197" class="markup--anchor markup--p-anchor" target="_blank">1</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-2-eeae2edd2be4" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-2-eeae2edd2be4" class="markup--anchor markup--p-anchor" target="_blank">2</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-3-74b0ef79e56" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-3-74b0ef79e56" class="markup--anchor markup--p-anchor" target="_blank">3</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-4-2048a26d58aa" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-4-2048a26d58aa" class="markup--anchor markup--p-anchor" target="_blank">4</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-5-dd904506bee8" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-5-dd904506bee8" class="markup--anchor markup--p-anchor" target="_blank">5</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-6-de70d626976c" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-6-de70d626976c" class="markup--anchor markup--p-anchor" target="_blank">6</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-7-1b9503aff0c" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-7-1b9503aff0c" class="markup--anchor markup--p-anchor" target="_blank">7</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-8-5ae195c49493" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-8-5ae195c49493" class="markup--anchor markup--p-anchor" target="_blank">8</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-9-5f0cf9e4bb5b" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-9-5f0cf9e4bb5b" class="markup--anchor markup--p-anchor" target="_blank">9</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-10-422d87c3340c" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-10-422d87c3340c" class="markup--anchor markup--p-anchor" target="_blank">10</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-11-61477d24dc34" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-11-61477d24dc34" class="markup--anchor markup--p-anchor" target="_blank">11</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-12-215dfbf04a94" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-12-215dfbf04a94" class="markup--anchor markup--p-anchor" target="_blank">12</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-13-43454b21a5d0" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-13-43454b21a5d0" class="markup--anchor markup--p-anchor" target="_blank">13</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-14-e0d23c7a0add" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-14-e0d23c7a0add" class="markup--anchor markup--p-anchor" target="_blank"><strong class="markup--strong markup--p-strong">14</strong></a></p></body></html>