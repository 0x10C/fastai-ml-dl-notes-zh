
<!-- saved from url=(0063)file:///C:/Users/asus/Desktop/fastai-ml-dl-notes-zh/en/dl9.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></head><body><hr class="section-divider"><h1 name="2be5" id="2be5" class="graf graf--h3 graf--leading graf--title">Deep Learning 2: Part 2 Lesson&nbsp;9</h1><p name="2560" id="2560" class="graf graf--p graf-after--h3"><em class="markup--em markup--p-em">My personal notes from </em><a href="http://www.fast.ai/" data-href="http://www.fast.ai/" class="markup--anchor markup--p-anchor" rel="noopener nofollow nofollow noopener noopener noopener nofollow noopener nofollow noopener" target="_blank"><em class="markup--em markup--p-em">fast.ai course</em></a><em class="markup--em markup--p-em">. These notes will continue to be updated and improved as I continue to review the course to “really” understand it. Much appreciation to </em><a href="https://twitter.com/jeremyphoward" data-href="https://twitter.com/jeremyphoward" class="markup--anchor markup--p-anchor" rel="noopener nofollow nofollow noopener noopener noopener nofollow noopener nofollow noopener" target="_blank"><em class="markup--em markup--p-em">Jeremy</em></a><em class="markup--em markup--p-em"> and </em><a href="https://twitter.com/math_rachel" data-href="https://twitter.com/math_rachel" class="markup--anchor markup--p-anchor" rel="noopener nofollow nofollow noopener noopener noopener nofollow noopener nofollow noopener" target="_blank"><em class="markup--em markup--p-em">Rachel</em></a><em class="markup--em markup--p-em"> who gave me this opportunity to learn.</em></p><p name="929c" id="929c" class="graf graf--p graf-after--p graf--trailing">Lessons: <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-1-602f73869197" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-1-602f73869197" class="markup--anchor markup--p-anchor" target="_blank">1</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-2-eeae2edd2be4" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-2-eeae2edd2be4" class="markup--anchor markup--p-anchor" target="_blank">2</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-3-74b0ef79e56" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-3-74b0ef79e56" class="markup--anchor markup--p-anchor" target="_blank">3</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-4-2048a26d58aa" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-4-2048a26d58aa" class="markup--anchor markup--p-anchor" target="_blank">4</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-5-dd904506bee8" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-5-dd904506bee8" class="markup--anchor markup--p-anchor" target="_blank">5</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-6-de70d626976c" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-6-de70d626976c" class="markup--anchor markup--p-anchor" target="_blank">6</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-7-1b9503aff0c" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-7-1b9503aff0c" class="markup--anchor markup--p-anchor" target="_blank">7</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-8-5ae195c49493" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-8-5ae195c49493" class="markup--anchor markup--p-anchor" target="_blank">8</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-9-5f0cf9e4bb5b" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-9-5f0cf9e4bb5b" class="markup--anchor markup--p-anchor" target="_blank"><strong class="markup--strong markup--p-strong">9</strong></a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-10-422d87c3340c" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-10-422d87c3340c" class="markup--anchor markup--p-anchor" target="_blank">10</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-11-61477d24dc34" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-11-61477d24dc34" class="markup--anchor markup--p-anchor" target="_blank">11</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-12-215dfbf04a94" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-12-215dfbf04a94" class="markup--anchor markup--p-anchor" target="_blank">12</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-13-43454b21a5d0" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-13-43454b21a5d0" class="markup--anchor markup--p-anchor" target="_blank">13</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-14-e0d23c7a0add" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-14-e0d23c7a0add" class="markup--anchor markup--p-anchor" target="_blank">14</a></p><hr class="section-divider"><h3 name="b0c6" id="b0c6" class="graf graf--h3 graf--leading">Links</h3><p name="32c6" id="32c6" class="graf graf--p graf-after--h3"><a href="http://forums.fast.ai/t/part-2-lesson-9-in-class/14028/1" data-href="http://forums.fast.ai/t/part-2-lesson-9-in-class/14028/1" class="markup--anchor markup--p-anchor" rel="noopener nofollow" target="_blank"><strong class="markup--strong markup--p-strong">Forum</strong></a><strong class="markup--strong markup--p-strong"> / </strong><a href="https://youtu.be/0frKXR-2PBY" data-href="https://youtu.be/0frKXR-2PBY" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank"><strong class="markup--strong markup--p-strong">Video</strong></a></p><h3 name="8cda" id="8cda" class="graf graf--h3 graf-after--p">Review</h3><h4 name="3167" id="3167" class="graf graf--h4 graf-after--h3">From Last&nbsp;week:</h4><ul class="postList"><li name="13b8" id="13b8" class="graf graf--li graf-after--h4">Pathlib; JSON</li><li name="8f79" id="8f79" class="graf graf--li graf-after--li">Dictionary comprehensions</li><li name="c475" id="c475" class="graf graf--li graf-after--li">Defaultdict</li><li name="5c7b" id="5c7b" class="graf graf--li graf-after--li">How to jump around fastai source</li><li name="2b0e" id="2b0e" class="graf graf--li graf-after--li">matplotlib OO API</li><li name="a56b" id="a56b" class="graf graf--li graf-after--li">Lambda functions</li><li name="35f7" id="35f7" class="graf graf--li graf-after--li">Bounding box coordinates</li><li name="474a" id="474a" class="graf graf--li graf-after--li">Custom head; bounding box regression</li></ul><figure name="da49" id="da49" class="graf graf--figure graf-after--li"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_2nxK3zuKRnDCu_3qVhSMnw.png"></figure><figure name="67d3" id="67d3" class="graf graf--figure graf-after--figure"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_9G88jQ42l5RdwFi2Yr_h_Q.png"></figure><h4 name="6247" id="6247" class="graf graf--h4 graf-after--figure">From Part&nbsp;1:</h4><ul class="postList"><li name="5e8a" id="5e8a" class="graf graf--li graf-after--h4">How to view model inputs from a DataLoader</li><li name="648e" id="648e" class="graf graf--li graf-after--li">How to view model outputs</li></ul><figure name="1296" id="1296" class="graf graf--figure graf-after--li"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_E3Z5vKnp6ZkfuLR83979RA.png"></figure><h3 name="5492" id="5492" class="graf graf--h3 graf-after--figure">Data Augmentation and Bounding Box&nbsp;[<a href="https://youtu.be/0frKXR-2PBY?t=2m58s" data-href="https://youtu.be/0frKXR-2PBY?t=2m58s" class="markup--anchor markup--h3-anchor" rel="nofollow noopener" target="_blank">2:58</a>]</h3><p name="e3ff" id="e3ff" class="graf graf--p graf-after--h3"><a href="https://github.com/fastai/fastai/blob/master/courses/dl2/pascal.ipynb" data-href="https://github.com/fastai/fastai/blob/master/courses/dl2/pascal.ipynb" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Notebook</a></p><p name="be1e" id="be1e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Awkward rough edges of fastai:</strong><br>A <em class="markup--em markup--p-em">classifier</em> is anything with dependent variable is categorical or binomial. As opposed to <em class="markup--em markup--p-em">regression</em> which is anything with dependent variable is continuous. Naming is a little confusing but will be sorted out in future. Here, <code class="markup--code markup--p-code">continuous</code> is <code class="markup--code markup--p-code">True</code> because our dependent variable is the coordinates of bounding box — hence this is actually a regressor data.</p><pre name="67ba" id="67ba" class="graf graf--pre graf-after--p">tfms = tfms_from_model(f_model, sz, crop_type=CropType.NO, <br>                       aug_tfms=augs)<br>md = Image<strong class="markup--strong markup--pre-strong">Classifier</strong>Data.from_csv(PATH, JPEGS, BB_CSV, tfms=tfms,<br>                                  <strong class="markup--strong markup--pre-strong">continuous=True</strong>, bs=4)</pre><h4 name="f768" id="f768" class="graf graf--h4 graf-after--pre">Let’s create some data augmentation [<a href="https://youtu.be/0frKXR-2PBY?t=4m40s" data-href="https://youtu.be/0frKXR-2PBY?t=4m40s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">4:40</a>]</h4><pre name="92de" id="92de" class="graf graf--pre graf-after--h4">augs = [RandomFlip(), <br>        RandomRotate(30),<br>        RandomLighting(0.1,0.1)]</pre><p name="8b2e" id="8b2e" class="graf graf--p graf-after--pre">Normally, we use these shortcuts Jeremy created for us, but they are simply lists of random augmentations. But you can easily create your own (most if not all of them start with “Random”).</p><figure name="2e67" id="2e67" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*lAIQHKT0GbjY0fRZKmpFaA.png" data-width="524" data-height="52" src="../img/1_lAIQHKT0GbjY0fRZKmpFaA.png"></figure><pre name="544c" id="544c" class="graf graf--pre graf-after--figure">tfms = tfms_from_model(f_model, sz, crop_type=CropType.NO,<br>                       aug_tfms=augs)<br>md = ImageClassifierData.from_csv(PATH, JPEGS, BB_CSV, tfms=tfms,<br>                       continuous=True, bs=4)</pre><pre name="aac4" id="aac4" class="graf graf--pre graf-after--pre">idx=3<br>fig,axes = plt.subplots(3,3, figsize=(9,9))<br>for i,ax in enumerate(axes.flat):<br>    x,y=next(iter(md.aug_dl))<br>    ima=md.val_ds.denorm(to_np(x))[idx]<br>    b = bb_hw(to_np(y[idx]))<br>    print(b)<br>    show_img(ima, ax=ax)<br>    draw_rect(ax, b)</pre><pre name="97e9" id="97e9" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">[ 115.   63.  240.  311.]<br>[ 115.   63.  240.  311.]<br>[ 115.   63.  240.  311.]<br>[ 115.   63.  240.  311.]<br>[ 115.   63.  240.  311.]<br>[ 115.   63.  240.  311.]<br>[ 115.   63.  240.  311.]<br>[ 115.   63.  240.  311.]<br>[ 115.   63.  240.  311.]</em></pre><figure name="cd34" id="cd34" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_QMa_SUUVOypZHKaAuXDkSw.png"></figure><p name="f3bd" id="f3bd" class="graf graf--p graf-after--figure">As you can see, the image gets rotated and lighting varies, but bounding box is <em class="markup--em markup--p-em">not moving</em> and is <em class="markup--em markup--p-em">in a wrong spot</em> [<a href="https://youtu.be/0frKXR-2PBY?t=6m17s" data-href="https://youtu.be/0frKXR-2PBY?t=6m17s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">6:17</a>]. This is the problem with data augmentations when your dependent variable is pixel values or in some way connected to the independent variable — they need to be augmented together. As you can see in the bounding box coordinates <code class="markup--code markup--p-code">[ 115. 63. 240. 311.]</code>&nbsp;, our image is 224 by 224 — so it is neither scaled nor cropped. The dependent variable needs to go through all the geometric transformation as the independent variables.</p><p name="586a" id="586a" class="graf graf--p graf-after--p">To do this [<a href="https://youtu.be/0frKXR-2PBY?t=7m10s" data-href="https://youtu.be/0frKXR-2PBY?t=7m10s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">7:10</a>], every transformation has an optional <code class="markup--code markup--p-code">tfm_y</code> parameter:</p><pre name="8852" id="8852" class="graf graf--pre graf-after--p">augs = [RandomFlip(tfm_y=TfmType.COORD),<br>        RandomRotate(30, tfm_y=TfmType.COORD),<br>        RandomLighting(0.1,0.1, tfm_y=TfmType.COORD)]</pre><pre name="161c" id="161c" class="graf graf--pre graf-after--pre">tfms = tfms_from_model(f_model, sz, crop_type=CropType.NO,<br>                       tfm_y=TfmType.COORD, aug_tfms=augs)<br>md = ImageClassifierData.from_csv(PATH, JPEGS, BB_CSV, tfms=tfms, <br>                       continuous=True, bs=4)</pre><p name="e0d7" id="e0d7" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">TrmType.COORD</code> indicates that the <em class="markup--em markup--p-em">y</em> value represents coordinate. This needs to be added to all the augmentations as well as <code class="markup--code markup--p-code">tfms_from_model</code> which is responsible for cropping, zooming, resizing, padding, etc.</p><pre name="4f8e" id="4f8e" class="graf graf--pre graf-after--p">idx=3<br>fig,axes = plt.subplots(3,3, figsize=(9,9))<br>for i,ax in enumerate(axes.flat):<br>    x,y=next(iter(md.aug_dl))<br>    ima=md.val_ds.denorm(to_np(x))[idx]<br>    b = bb_hw(to_np(y[idx]))<br>    print(b)<br>    show_img(ima, ax=ax)<br>    draw_rect(ax, b)</pre><pre name="e2fc" id="e2fc" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">[  48.   34.  112.  188.]<br>[  65.   36.  107.  185.]<br>[  49.   27.  131.  195.]<br>[  24.   18.  147.  204.]<br>[  61.   34.  113.  188.]<br>[  55.   31.  121.  191.]<br>[  52.   19.  144.  203.]<br>[   7.    0.  193.  222.]<br>[  52.   38.  105.  182.]</em></pre><figure name="f82b" id="f82b" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1__ge-RyZpEIQ5fiSvo207rA.png"></figure><p name="dfa4" id="dfa4" class="graf graf--p graf-after--figure">Now, the bounding box moves with the image and is in the right spot. You may notice that sometimes it looks odd like the middle on in the bottom row. This is the constraint of the information we have. If the object occupied the corners of the original bounding box, your new bounding box needs to be bigger after the image rotates. So you must <strong class="markup--strong markup--p-strong">be careful of not doing too higher rotations with bounding boxes</strong> because there is not enough information for them to stay accurate. <span class="markup--quote markup--p-quote is-other" name="anon_ae3d5e1d2e6d" data-creator-ids="anon">If we were doing polygons or segmentations, we would not have this problem.</span></p><figure name="8d9f" id="8d9f" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_4V4sjFZxn-y2cU9tCJPEUw.png"><figcaption class="imageCaption">This why the box gets&nbsp;bigger</figcaption></figure><pre name="123b" id="123b" class="graf graf--pre graf-after--figure">tfm_y = TfmType.COORD<br>augs = [RandomFlip(tfm_y=tfm_y),<br>        RandomRotate(<strong class="markup--strong markup--pre-strong">3</strong>, <strong class="markup--strong markup--pre-strong">p=0.5</strong>, tfm_y=tfm_y),<br>        RandomLighting(0.05,0.05, tfm_y=tfm_y)]</pre><pre name="b051" id="b051" class="graf graf--pre graf-after--pre">tfms = tfms_from_model(f_model, sz, crop_type=CropType.NO, <br>                 tfm_y=tfm_y, aug_tfms=augs)<br>md = ImageClassifierData.from_csv(PATH, JPEGS, BB_CSV, tfms=tfms, <br>                 continuous=True)</pre><p name="76dc" id="76dc" class="graf graf--p graf-after--pre">So here, we do maximum of 3 degree rotation to avoid this problem [<a href="https://youtu.be/0frKXR-2PBY?t=9m14s" data-href="https://youtu.be/0frKXR-2PBY?t=9m14s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">9:14</a>]. It also only rotates half of the time (<code class="markup--code markup--p-code">p=0.5</code>).</p><h4 name="58b8" id="58b8" class="graf graf--h4 graf-after--p">custom_head [<a href="https://youtu.be/0frKXR-2PBY?t=9m34s" data-href="https://youtu.be/0frKXR-2PBY?t=9m34s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">9:34</a>]</h4><p name="e869" id="e869" class="graf graf--p graf-after--h4"><code class="markup--code markup--p-code">learn.summary()</code> will run a small batch of data through a model and prints out the size of tensors at every layer. As you can see, right before the <code class="markup--code markup--p-code">Flatten</code> layer, the tensor has the shape of 512 by 7 by 7. So if it were a rank 1 tensor (i.e. a single vector) its length will be 25088 (512 * 7 * 7)and that is why our custom header’s input size is 25088. Output size is 4 since it is the bounding box coordinates.</p><pre name="1987" id="1987" class="graf graf--pre graf-after--p">head_reg4 = nn.Sequential(Flatten(), nn.Linear(25088,4))<br>learn = ConvLearner.pretrained(f_model, md, custom_head=head_reg4)<br>learn.opt_fn = optim.Adam<br>learn.crit = nn.L1Loss()</pre><figure name="6c46" id="6c46" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_o9NFGVz1ua60kOpIafe5Hg.png"></figure><h4 name="f7f3" id="f7f3" class="graf graf--h4 graf-after--figure">Single object detection [<a href="https://youtu.be/0frKXR-2PBY?t=10m35s" data-href="https://youtu.be/0frKXR-2PBY?t=10m35s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">10:35</a>]</h4><p name="80a2" id="80a2" class="graf graf--p graf-after--h4">Let’s combine the two to create something that can classify and localize the largest object in each image.</p><p name="8a53" id="8a53" class="graf graf--p graf-after--p">There are 3 things that we need to do to train a neural network:</p><ol class="postList"><li name="bb44" id="bb44" class="graf graf--li graf-after--p">Data</li><li name="b33c" id="b33c" class="graf graf--li graf-after--li">Architecture</li><li name="62fa" id="62fa" class="graf graf--li graf-after--li">Loss Function</li></ol><h4 name="a6c0" id="a6c0" class="graf graf--h4 graf-after--li">1. Providing Data</h4><p name="e159" id="e159" class="graf graf--p graf-after--h4">We need a <code class="markup--code markup--p-code">ModelData</code> object whose independent variable is the images, and dependent variable is a tuple of bounding box coordinates and class label. There are several ways to do this, but here is a particularly lazy and convinient way Jeremy came up with is to create two <code class="markup--code markup--p-code">ModelData</code> objects representing the two different dependent variables we want (one with bounding boxes coordinates, one with classes).</p><pre name="b667" id="b667" class="graf graf--pre graf-after--p">f_model=resnet34<br>sz=224<br>bs=64</pre><pre name="65cf" id="65cf" class="graf graf--pre graf-after--pre">val_idxs = get_cv_idxs(len(trn_fns))<br>tfms = tfms_from_model(f_model, sz, crop_type=CropType.NO, <br>                       tfm_y=TfmType.COORD, aug_tfms=augs)</pre><pre name="3de6" id="3de6" class="graf graf--pre graf-after--pre">md = ImageClassifierData.from_csv(PATH, JPEGS, <strong class="markup--strong markup--pre-strong">BB_CSV</strong>, tfms=tfms, <br>                       continuous=True, val_idxs=val_idxs)</pre><pre name="e9fc" id="e9fc" class="graf graf--pre graf-after--pre">md2 = ImageClassifierData.from_csv(PATH, JPEGS, <strong class="markup--strong markup--pre-strong">CSV</strong>,<br>                       tfms=tfms_from_model(f_model, sz))</pre><p name="18c8" id="18c8" class="graf graf--p graf-after--pre">A dataset can be anything with <code class="markup--code markup--p-code">__len__</code> and <code class="markup--code markup--p-code">__getitem__</code>. Here's a dataset that adds a 2nd label to an existing dataset:</p><pre name="d395" id="d395" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">class</strong> <strong class="markup--strong markup--pre-strong">ConcatLblDataset</strong>(Dataset):<br>    <strong class="markup--strong markup--pre-strong">def</strong> __init__(self, ds, y2): self.ds,self.y2 = ds,y2<br>    <strong class="markup--strong markup--pre-strong">def</strong> __len__(self): <strong class="markup--strong markup--pre-strong">return</strong> len(self.ds)<br>    <br>    <strong class="markup--strong markup--pre-strong">def</strong> __getitem__(self, i):<br>        x,y = self.ds[i]<br>        <strong class="markup--strong markup--pre-strong">return</strong> (x, (y,self.y2[i]))</pre><ul class="postList"><li name="646c" id="646c" class="graf graf--li graf-after--pre"><code class="markup--code markup--li-code">ds</code>&nbsp;: contains both independent and dependent variables</li><li name="8dc3" id="8dc3" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">y2</code>&nbsp;: contains the additional dependent variables</li><li name="c9d3" id="c9d3" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">(x, (y,self.y2[i]))</code>&nbsp;: <code class="markup--code markup--li-code">__getitem___</code> returns an independent variable and the combination of two dependent variables.</li></ul><p name="8552" id="8552" class="graf graf--p graf-after--li">We’ll use it to add the classes to the bounding boxes labels.</p><pre name="36e4" id="36e4" class="graf graf--pre graf-after--p">trn_ds2 = ConcatLblDataset(md.trn_ds, md2.trn_y)<br>val_ds2 = ConcatLblDataset(md.val_ds, md2.val_y)</pre><p name="a83d" id="a83d" class="graf graf--p graf-after--pre">Here is an example dependent variable:</p><pre name="e61c" id="e61c" class="graf graf--pre graf-after--p">val_ds2[0][1]</pre><pre name="bb40" id="bb40" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">(array([   0.,   49.,  205.,  180.], dtype=float32), 14)</em></pre><p name="3916" id="3916" class="graf graf--p graf-after--pre">We can replace the dataloaders’ datasets with these new ones.</p><pre name="abd7" id="abd7" class="graf graf--pre graf-after--p">md.trn_dl.dataset = trn_ds2<br>md.val_dl.dataset = val_ds2</pre><p name="e63c" id="e63c" class="graf graf--p graf-after--pre">We have to <code class="markup--code markup--p-code">denorm</code>alize the images from the dataloader before they can be plotted.</p><pre name="bb3f" id="bb3f" class="graf graf--pre graf-after--p">x,y = next(iter(md.val_dl))<br>idx = 3<br>ima = md.val_ds.ds.denorm(to_np(x))[idx]<br>b = bb_hw(to_np(y[0][idx])); b</pre><pre name="7b26" id="7b26" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">array([  52.,   38.,  106.,  184.], dtype=float32)</em></pre><pre name="31ab" id="31ab" class="graf graf--pre graf-after--pre">ax = show_img(ima)<br>draw_rect(ax, b)<br>draw_text(ax, b[:2], md2.classes[y[1][idx]])</pre><figure name="442b" id="442b" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_6QqfOpqgyRogEiTCU8WZgQ.png"></figure><h4 name="2513" id="2513" class="graf graf--h4 graf-after--figure">2. Choosing Architecture [<a href="https://youtu.be/0frKXR-2PBY?t=13m54s" data-href="https://youtu.be/0frKXR-2PBY?t=13m54s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">13:54</a>]</h4><p name="18d6" id="18d6" class="graf graf--p graf-after--h4">The architecture will be the same as the one we used for the classifier and bounding box regression, but we will just combine them. In other words, if we have <code class="markup--code markup--p-code">c</code> classes, then the number of activations we need in the final layer is 4 plus <code class="markup--code markup--p-code">c</code>. 4 for bounding box coordinates and <code class="markup--code markup--p-code">c</code> probabilities (one per class).</p><p name="f053" id="f053" class="graf graf--p graf-after--p">We’ll use an extra linear layer this time, plus some dropout, to help us train a more flexible model. In general, we want our custom head to be capable of solving the problem on its own if the pre-trained backbone it is connected to is appropriate. So in this case, we are trying to do quite a bit — classifier and bounding box regression, so just the single linear layer does not seem enough. If you were wondering why there is no <code class="markup--code markup--p-code">BatchNorm1d</code> after the first <code class="markup--code markup--p-code">ReLU</code>&nbsp;, ResNet backbone already has <code class="markup--code markup--p-code">BatchNorm1d</code> as its final layer.</p><pre name="eb1b" id="eb1b" class="graf graf--pre graf-after--p">head_reg4 = nn.Sequential(<br>    Flatten(),<br>    nn.ReLU(),<br>    nn.Dropout(0.5),<br>    nn.Linear(25088,256),<br>    nn.ReLU(),<br>    nn.BatchNorm1d(256),<br>    nn.Dropout(0.5),<br>    nn.Linear(256,<strong class="markup--strong markup--pre-strong">4+len(cats)</strong>),<br>)<br>models = ConvnetBuilder(f_model, 0, 0, 0, custom_head=head_reg4)<br><br>learn = ConvLearner(md, models)<br>learn.opt_fn = optim.Adam</pre><h4 name="f6e9" id="f6e9" class="graf graf--h4 graf-after--pre">3. Loss Function&nbsp;[<a href="https://youtu.be/0frKXR-2PBY?t=15m46s" data-href="https://youtu.be/0frKXR-2PBY?t=15m46s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">15:46</a>]</h4><p name="95d7" id="95d7" class="graf graf--p graf-after--h4">The loss function needs to look at these <code class="markup--code markup--p-code">4 + len(cats)</code> activations and decide if they are good — whether these numbers accurately reflect the position and class of the largest object in the image. We know how to do this. For the first 4 activations, we will use L1Loss just like we did before (L1Loss is like a Mean Squared Error — instead of sum of squared errors, it uses sum of absolute values). For rest of the activations, we can use cross entropy loss.</p><pre name="7b18" id="7b18" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">def</strong> detn_loss(input, target):<br>    bb_t,c_t = target<br>    bb_i,c_i = input[:, :4], input[:, 4:]<br>    bb_i = F.sigmoid(bb_i)*224<br><em class="markup--em markup--pre-em">    # I looked at these quantities separately first then picked a <br>    # multiplier to make them approximately equal</em><br>    <strong class="markup--strong markup--pre-strong">return</strong> F.l1_loss(bb_i, bb_t) + F.cross_entropy(c_i, c_t)*20</pre><pre name="16e0" id="16e0" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">def</strong> detn_l1(input, target):<br>    bb_t,_ = target<br>    bb_i = input[:, :4]<br>    bb_i = F.sigmoid(bb_i)*224<br>    <strong class="markup--strong markup--pre-strong">return</strong> F.l1_loss(V(bb_i),V(bb_t)).data</pre><pre name="f829" id="f829" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">def</strong> detn_acc(input, target):<br>    _,c_t = target<br>    c_i = input[:, 4:]<br>    <strong class="markup--strong markup--pre-strong">return</strong> accuracy(c_i, c_t)</pre><pre name="4eaa" id="4eaa" class="graf graf--pre graf-after--pre">learn.crit = detn_loss<br>learn.metrics = [detn_acc, detn_l1]</pre><ul class="postList"><li name="f337" id="f337" class="graf graf--li graf-after--pre"><code class="markup--code markup--li-code">input</code>&nbsp;: activations</li><li name="5cb2" id="5cb2" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">target</code>&nbsp;: ground truth</li><li name="9b1e" id="9b1e" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">bb_t,c_t = target</code>&nbsp;: Our custom dataset returns a tuple containing bounding box coordinates and classes. This assignment will destructure them.</li><li name="8867" id="8867" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">bb_i,c_i = input[:,&nbsp;:4], input[:, 4:]</code>&nbsp;: the first&nbsp;<code class="markup--code markup--li-code">:</code> is for the batch dimension.</li><li name="e6c0" id="e6c0" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">b_i = F.sigmoid(bb_i)*224</code>&nbsp;: we know our image is 224 by 224. <code class="markup--code markup--li-code">Sigmoid</code> will force it to be between 0 and 1, and multiply it by 224 to help our neural net to be in the range of what it has to be.</li></ul><p name="ab55" id="ab55" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Question:</strong> As a general rule, is it better to put BatchNorm before or after ReLU [<a href="https://youtu.be/0frKXR-2PBY?t=18m2s" data-href="https://youtu.be/0frKXR-2PBY?t=18m2s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">18:02</a>]? Jeremy would suggest to put it after a ReLU because BathNorm is meant to move towards zero-mean one-standard deviation. So if you put ReLU right after it, you are truncating it at zero so there is no way to create negative numbers. But if you put ReLU then BatchNorm, it does have that ability and gives slightly better results. Having said that, it is not too big of a deal either way. You see during this part of the course, most of the time, Jeremy does ReLU then BatchNorm but sometimes does the opposite when he wants to be consistent with the paper.</p><p name="f68d" id="f68d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Question</strong>: What is the intuition behind using dropout after a BatchNorm? Doesn’t BatchNorm already do a good job of regularizing [<a href="https://youtu.be/0frKXR-2PBY?t=19m12s" data-href="https://youtu.be/0frKXR-2PBY?t=19m12s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">19:12</a>]? BatchNorm does an okay job of regularizing but if you think back to part 1 when we discussed a list of things we do to avoid overfitting and adding BatchNorm is one of them as is data augmentation. But it’s perfectly possible that you’ll still be overfitting. One nice thing about dropout is that is it has a parameter to say how much to drop out. Parameters are great specifically parameters that decide how much to regularize because it lets you build a nice big over parameterized model and then decide on how much to regularize it. Jeremy tends to always put in a drop out starting with <code class="markup--code markup--p-code">p=0</code> and then as he adds regularization, he can just change the dropout parameter without worrying about if he saved a model he want to be able to load it back, but if he had dropout layers in one but no in another, it will not load anymore. So this way, it stays consistent.</p><p name="c531" id="c531" class="graf graf--p graf-after--p">Now we have out inputs and targets, we can calculate the L1 loss and add the cross entropy [<a href="https://youtu.be/0frKXR-2PBY?t=20m39s" data-href="https://youtu.be/0frKXR-2PBY?t=20m39s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">20:39</a>]:</p><p name="95f1" id="95f1" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">F.l1_loss(bb_i, bb_t) + F.cross_entropy(c_i, c_t)*20</code></p><p name="d04f" id="d04f" class="graf graf--p graf-after--p">This is our loss function. Cross entropy and L1 loss may be of wildly different scales — in which case in the loss function, the larger one is going to dominate. In this case, Jeremy printed out the values and found out that if we multiply cross entropy by 20 that makes them about the same scale.</p><pre name="eb4a" id="eb4a" class="graf graf--pre graf-after--p">lr=1e-2<br>learn.fit(lr, 1, cycle_len=3, use_clr=(32,5))</pre><pre name="70ea" id="70ea" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">epoch      trn_loss   val_loss   detn_acc   detn_l1       <br>    0      72.036466  45.186367  0.802133   32.647586 <br>    1      51.037587  36.34964   0.828425   25.389733     <br>    2      41.4235    35.292709  0.835637   24.343577</em></pre><pre name="0564" id="0564" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">[35.292709, 0.83563701808452606, 24.343576669692993]</em></pre><p name="6180" id="6180" class="graf graf--p graf-after--pre">It is nice to print out information as you train, so we grabbed L1 loss and added it as metrics.</p><pre name="06fa" id="06fa" class="graf graf--pre graf-after--p">learn.save('reg1_0')<br>learn.freeze_to(-2)<br>lrs = np.array([lr/100, lr/10, lr])<br>learn.fit(lrs/5, 1, cycle_len=5, use_clr=(32,10))</pre><pre name="11fb" id="11fb" class="graf graf--pre graf-after--pre">epoch      trn_loss   val_loss   detn_acc   detn_l1       <br>    0      34.448113  35.972973  0.801683   22.918499 <br>    1      28.889909  33.010857  0.830379   21.689888     <br>    2      24.237017  30.977512  0.81881    20.817996     <br>    3      21.132993  30.60677   0.83143    20.138552     <br>    4      18.622983  30.54178   0.825571   19.832196</pre><pre name="0865" id="0865" class="graf graf--pre graf-after--pre">[30.54178, 0.82557091116905212, 19.832195997238159]</pre><pre name="c0fb" id="c0fb" class="graf graf--pre graf-after--pre">learn.unfreeze()<br>learn.fit(lrs/10, 1, cycle_len=10, use_clr=(32,10))</pre><pre name="6c87" id="6c87" class="graf graf--pre graf-after--pre">epoch      trn_loss   val_loss   detn_acc   detn_l1       <br>    0      15.957164  31.111507  0.811448   19.970753 <br>    1      15.955259  32.597153  0.81235    20.111022     <br>    2      15.648723  32.231941  0.804087   19.522853     <br>    3      14.876172  30.93821   0.815805   19.226574     <br>    4      14.113872  31.03952   0.808594   19.155093     <br>    5      13.293885  29.736671  0.826022   18.761728     <br>    6      12.562566  30.000023  0.827524   18.82006      <br>    7      11.885125  30.28841   0.82512    18.904158     <br>    8      11.498326  30.070133  0.819712   18.635296     <br>    9      11.015841  30.213772  0.815805   18.551489</pre><pre name="0591" id="0591" class="graf graf--pre graf-after--pre">[30.213772, 0.81580528616905212, 18.551488876342773]</pre><p name="2c47" id="2c47" class="graf graf--p graf-after--pre">A detection accuracy is in the low 80’s which is the same as what it was before. This is not surprising because ResNet was designed to do classification so we wouldn’t expect to be able to improve things in such a simple way. It certainly wasn’t designed to do bounding box regression. It was explicitly actually designed in such a way to not care about geometry — it takes the last 7 by 7 grid of activations and averages them all together throwing away all the information about where everything came from.</p><p name="684d" id="684d" class="graf graf--p graf-after--p">Interestingly, when we do accuracy (classification) and bounding box at the same time, the L1 seems a little bit better than when we just do bounding box regression [<a href="https://youtu.be/0frKXR-2PBY?t=22m46s" data-href="https://youtu.be/0frKXR-2PBY?t=22m46s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">22:46</a>]. If that is counterintuitive to you, then this would be one of the main things to think about after this lesson since it is a really important idea. The idea is this — figuring out what the main object in an image is, is kind of the hard part. Then figuring out exactly where the bounding box is and what class it is is the easy part in a way. So when you have a single network that’s both saying what is the object and where is the object, it’s going to share all the computation about finding the object. And all that shared computation is very efficient. When we back propagate the errors in the class and in the place, that’s all the information that is going to help the computation around finding the biggest object. So anytime you have multiple tasks which share some concept of what those tasks would need to do to complete their work, it is very likely they should share at least some layers of the network together. Later today, we will look at a model where most of the layers are shared except for the last one.</p><p name="acb4" id="acb4" class="graf graf--p graf-after--p">Here are the result [<a href="https://youtu.be/0frKXR-2PBY?t=24m34s" data-href="https://youtu.be/0frKXR-2PBY?t=24m34s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">24:34</a>]. As before, it does a good job when there is single major object in the image.</p><figure name="3d36" id="3d36" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_g4JAJgAcDNDikhgwtLTcwQ.png"></figure><h3 name="8223" id="8223" class="graf graf--h3 graf-after--figure">Multi label classification [<a href="https://youtu.be/0frKXR-2PBY?t=25m29s" data-href="https://youtu.be/0frKXR-2PBY?t=25m29s" class="markup--anchor markup--h3-anchor" rel="nofollow noopener" target="_blank">25:29</a>]</h3><p name="cf6b" id="cf6b" class="graf graf--p graf-after--h3"><a href="https://github.com/fastai/fastai/blob/master/courses/dl2/pascal-multi.ipynb" data-href="https://github.com/fastai/fastai/blob/master/courses/dl2/pascal-multi.ipynb" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Notebook</a></p><p name="5908" id="5908" class="graf graf--p graf-after--p">We want to keep building models that are slightly more complex than the last model so that if something stops working, we know exactly where it broke. Here are functions from the previous notebook:</p><pre name="52fd" id="52fd" class="graf graf--pre graf-after--p">%matplotlib inline<br>%reload_ext autoreload<br>%autoreload 2</pre><pre name="9b4a" id="9b4a" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">from</strong> <strong class="markup--strong markup--pre-strong">fastai.conv_learner</strong> <strong class="markup--strong markup--pre-strong">import</strong> *<br><strong class="markup--strong markup--pre-strong">from</strong> <strong class="markup--strong markup--pre-strong">fastai.dataset</strong> <strong class="markup--strong markup--pre-strong">import</strong> *<br><br><strong class="markup--strong markup--pre-strong">import</strong> <strong class="markup--strong markup--pre-strong">json</strong>, <strong class="markup--strong markup--pre-strong">pdb</strong><br><strong class="markup--strong markup--pre-strong">from</strong> <strong class="markup--strong markup--pre-strong">PIL</strong> <strong class="markup--strong markup--pre-strong">import</strong> ImageDraw, ImageFont<br><strong class="markup--strong markup--pre-strong">from</strong> <strong class="markup--strong markup--pre-strong">matplotlib</strong> <strong class="markup--strong markup--pre-strong">import</strong> patches, patheffects<br>torch.backends.cudnn.benchmark=<strong class="markup--strong markup--pre-strong">True</strong></pre><h4 name="197a" id="197a" class="graf graf--h4 graf-after--pre">Setup</h4><pre name="1c51" id="1c51" class="graf graf--pre graf-after--h4">PATH = Path('data/pascal')<br>trn_j = json.load((PATH / 'pascal_train2007.json').open())<br>IMAGES,ANNOTATIONS,CATEGORIES = ['images', 'annotations', <br>                                 'categories']<br>FILE_NAME,ID,IMG_ID,CAT_ID,BBOX = 'file_name','id','image_id', <br>                                  'category_id','bbox'<br><br>cats = dict((o[ID], o['name']) <strong class="markup--strong markup--pre-strong">for</strong> o <strong class="markup--strong markup--pre-strong">in</strong> trn_j[CATEGORIES])<br>trn_fns = dict((o[ID], o[FILE_NAME]) <strong class="markup--strong markup--pre-strong">for</strong> o <strong class="markup--strong markup--pre-strong">in</strong> trn_j[IMAGES])<br>trn_ids = [o[ID] <strong class="markup--strong markup--pre-strong">for</strong> o <strong class="markup--strong markup--pre-strong">in</strong> trn_j[IMAGES]]<br><br>JPEGS = 'VOCdevkit/VOC2007/JPEGImages'<br>IMG_PATH = PATH/JPEGS</pre><pre name="5736" id="5736" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">def</strong> get_trn_anno():<br>    trn_anno = collections.defaultdict(<strong class="markup--strong markup--pre-strong">lambda</strong>:[])<br>    <strong class="markup--strong markup--pre-strong">for</strong> o <strong class="markup--strong markup--pre-strong">in</strong> trn_j[ANNOTATIONS]:<br>        <strong class="markup--strong markup--pre-strong">if</strong> <strong class="markup--strong markup--pre-strong">not</strong> o['ignore']:<br>            bb = o[BBOX]<br>            bb = np.array([bb[1], bb[0], bb[3]+bb[1]-1, <br>                           bb[2]+bb[0]-1])<br>            trn_anno[o[IMG_ID]].append((bb,o[CAT_ID]))<br>    <strong class="markup--strong markup--pre-strong">return</strong> trn_anno<br><br>trn_anno = get_trn_anno()</pre><pre name="d612" id="d612" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">def</strong> show_img(im, figsize=<strong class="markup--strong markup--pre-strong">None</strong>, ax=<strong class="markup--strong markup--pre-strong">None</strong>):<br>    <strong class="markup--strong markup--pre-strong">if</strong> <strong class="markup--strong markup--pre-strong">not</strong> ax: fig,ax = plt.subplots(figsize=figsize)<br>    ax.imshow(im)<br>    ax.set_xticks(np.linspace(0, 224, 8))<br>    ax.set_yticks(np.linspace(0, 224, 8))<br>    ax.grid()<br>    ax.set_yticklabels([])<br>    ax.set_xticklabels([])<br>    <strong class="markup--strong markup--pre-strong">return</strong> ax<br><br><strong class="markup--strong markup--pre-strong">def</strong> draw_outline(o, lw):<br>    o.set_path_effects([patheffects.Stroke(<br>        linewidth=lw, foreground='black'), patheffects.Normal()])<br><br><strong class="markup--strong markup--pre-strong">def</strong> draw_rect(ax, b, color='white'):<br>    patch = ax.add_patch(patches.Rectangle(b[:2], *b[-2:], <br>                         fill=<strong class="markup--strong markup--pre-strong">False</strong>, edgecolor=color, lw=2))<br>    draw_outline(patch, 4)<br><br><strong class="markup--strong markup--pre-strong">def</strong> draw_text(ax, xy, txt, sz=14, color='white'):<br>    text = ax.text(*xy, txt,<br>        verticalalignment='top', color=color, fontsize=sz, <br>        weight='bold')<br>    draw_outline(text, 1)</pre><pre name="9675" id="9675" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">def</strong> bb_hw(a): <strong class="markup--strong markup--pre-strong">return</strong> np.array([a[1],a[0],a[3]-a[1],a[2]-a[0]])<br><br><strong class="markup--strong markup--pre-strong">def</strong> draw_im(im, ann):<br>    ax = show_img(im, figsize=(16,8))<br>    <strong class="markup--strong markup--pre-strong">for</strong> b,c <strong class="markup--strong markup--pre-strong">in</strong> ann:<br>        b = bb_hw(b)<br>        draw_rect(ax, b)<br>        draw_text(ax, b[:2], cats[c], sz=16)<br><br><strong class="markup--strong markup--pre-strong">def</strong> draw_idx(i):<br>    im_a = trn_anno[i]<br>    im = open_image(IMG_PATH/trn_fns[i])<br>    draw_im(im, im_a)</pre><h4 name="153a" id="153a" class="graf graf--h4 graf-after--pre">Multi class&nbsp;[<a href="https://youtu.be/0frKXR-2PBY?t=26m12s" data-href="https://youtu.be/0frKXR-2PBY?t=26m12s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">26:12</a>]</h4><pre name="189d" id="189d" class="graf graf--pre graf-after--h4">MC_CSV = PATH/'tmp/mc.csv'</pre><pre name="9a35" id="9a35" class="graf graf--pre graf-after--pre">trn_anno[12]</pre><pre name="a704" id="a704" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">[(array([ 96, 155, 269, 350]), 7)]</em></pre><pre name="2ebe" id="2ebe" class="graf graf--pre graf-after--pre">mc = [set([cats[p[1]] <strong class="markup--strong markup--pre-strong">for</strong> p <strong class="markup--strong markup--pre-strong">in</strong> trn_anno[o]]) <strong class="markup--strong markup--pre-strong">for</strong> o <strong class="markup--strong markup--pre-strong">in</strong> trn_ids]<br>mcs = [' '.join(str(p) <strong class="markup--strong markup--pre-strong">for</strong> p <strong class="markup--strong markup--pre-strong">in</strong> o) <strong class="markup--strong markup--pre-strong">for</strong> o <strong class="markup--strong markup--pre-strong">in</strong> mc]</pre><pre name="8c39" id="8c39" class="graf graf--pre graf-after--pre">df = pd.DataFrame({'fn': [trn_fns[o] <strong class="markup--strong markup--pre-strong">for</strong> o <strong class="markup--strong markup--pre-strong">in</strong> trn_ids], <br>                   'clas': mcs}, columns=['fn','clas'])<br>df.to_csv(MC_CSV, index=<strong class="markup--strong markup--pre-strong">False</strong>)</pre><p name="512b" id="512b" class="graf graf--p graf-after--pre">One of the students pointed out that by using Pandas, we can do things much simpler than using <code class="markup--code markup--p-code">collections.defaultdict</code> and shared <a href="https://gist.github.com/binga/1bc4ebe5e41f670f5954d2ffa9d6c0ed" data-href="https://gist.github.com/binga/1bc4ebe5e41f670f5954d2ffa9d6c0ed" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">this gist</a>. The more you get to know Pandas, the more often you realize it is a good way to solve lots of different problems.</p><p name="2dc8" id="2dc8" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Question</strong>: When you are incrementally building on top of smaller models, do you reuse them as pre-trained weights? or do you toss it away then retrain from scratch [<a href="https://youtu.be/0frKXR-2PBY?t=27m11s" data-href="https://youtu.be/0frKXR-2PBY?t=27m11s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">27:11</a>]? When Jeremy is figuring stuff out as he goes like this, he would generally lean towards tossing away because reusing pre-trained weights introduces unnecessary complexities. However, if he is trying to get to a point where he can train on really big images, he will generally start on much smaller and often re-use these weights.</p><pre name="5b68" id="5b68" class="graf graf--pre graf-after--p">f_model=resnet34<br>sz=224<br>bs=64</pre><pre name="a183" id="a183" class="graf graf--pre graf-after--pre">tfms = tfms_from_model(f_model, sz, crop_type=CropType.NO)<br>md = ImageClassifierData.from_csv(PATH, JPEGS, MC_CSV, tfms=tfms)</pre><pre name="99ad" id="99ad" class="graf graf--pre graf-after--pre">learn = ConvLearner.pretrained(f_model, md)<br>learn.opt_fn = optim.Adam</pre><pre name="cc2f" id="cc2f" class="graf graf--pre graf-after--pre">lr = 2e-2</pre><pre name="17d6" id="17d6" class="graf graf--pre graf-after--pre">learn.fit(lr, 1, cycle_len=3, use_clr=(32,5))</pre><pre name="560a" id="560a" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">epoch      trn_loss   val_loss   &lt;lambda&gt;                  <br>    0      0.104836   0.085015   0.972356  <br>    1      0.088193   0.079739   0.972461                   <br>    2      0.072346   0.077259   0.974114</em></pre><pre name="60c4" id="60c4" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">[0.077258907, 0.9741135761141777]</em></pre><pre name="a327" id="a327" class="graf graf--pre graf-after--pre">lrs = np.array([lr/100, lr/10, lr])</pre><pre name="5faa" id="5faa" class="graf graf--pre graf-after--pre">learn.freeze_to(-2)</pre><pre name="d590" id="d590" class="graf graf--pre graf-after--pre">learn.fit(lrs/10, 1, cycle_len=5, use_clr=(32,5))</pre><pre name="fd47" id="fd47" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">epoch      trn_loss   val_loss   &lt;lambda&gt;                   <br>    0      0.063236   0.088847   0.970681  <br>    1      0.049675   0.079885   0.973723                   <br>    2      0.03693    0.076906   0.975601                   <br>    3      0.026645   0.075304   0.976187                   <br>    4      0.018805   0.074934   0.975165</em></pre><pre name="5ca7" id="5ca7" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">[0.074934497, 0.97516526281833649]</em></pre><pre name="e973" id="e973" class="graf graf--pre graf-after--pre">learn.save('mclas')</pre><pre name="2834" id="2834" class="graf graf--pre graf-after--pre">learn.load('mclas')</pre><pre name="8c3b" id="8c3b" class="graf graf--pre graf-after--pre">y = learn.predict()<br>x,_ = next(iter(md.val_dl))<br>x = to_np(x)</pre><pre name="5b1f" id="5b1f" class="graf graf--pre graf-after--pre">fig, axes = plt.subplots(3, 4, figsize=(12, 8))<br><strong class="markup--strong markup--pre-strong">for</strong> i,ax <strong class="markup--strong markup--pre-strong">in</strong> enumerate(axes.flat):<br>    ima=md.val_ds.denorm(x)[i]<br>    ya = np.nonzero(y[i]&gt;0.4)[0]<br>    b = '<strong class="markup--strong markup--pre-strong">\n</strong>'.join(md.classes[o] <strong class="markup--strong markup--pre-strong">for</strong> o <strong class="markup--strong markup--pre-strong">in</strong> ya)<br>    ax = show_img(ima, ax=ax)<br>    draw_text(ax, (0,0), b)<br>plt.tight_layout()</pre><figure name="76a2" id="76a2" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_2m1Qoq3NhsqdYBd4hUTR6A.png"></figure><p name="4bec" id="4bec" class="graf graf--p graf-after--figure">Multi-class classification is pretty straight forward [<a href="https://youtu.be/0frKXR-2PBY?t=28m28s" data-href="https://youtu.be/0frKXR-2PBY?t=28m28s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">28:28</a>]. One minor tweak is the use of <code class="markup--code markup--p-code">set</code> in this line so that each object type appear once.:</p><pre name="de81" id="de81" class="graf graf--pre graf-after--p">mc = [<strong class="markup--strong markup--pre-strong">set</strong>([cats[p[1]] <strong class="markup--strong markup--pre-strong">for</strong> p <strong class="markup--strong markup--pre-strong">in</strong> trn_anno[o]]) <strong class="markup--strong markup--pre-strong">for</strong> o <strong class="markup--strong markup--pre-strong">in</strong> trn_ids]</pre><h4 name="f2f7" id="f2f7" class="graf graf--h4 graf-after--pre">SSD and YOLO&nbsp;[<a href="https://youtu.be/0frKXR-2PBY?t=29m10s" data-href="https://youtu.be/0frKXR-2PBY?t=29m10s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">29:10</a>]</h4><p name="4997" id="4997" class="graf graf--p graf-after--h4">We have an input image that goes through a conv net which outputs a vector of size <code class="markup--code markup--p-code">4+c</code> where <code class="markup--code markup--p-code">c=len(cats)</code>&nbsp;. This gives us an object detector for a single largest object. Let’s now create one that finds 16 objects. The obvious way to do this would be to take the last linear layer and rather than having <code class="markup--code markup--p-code">4+c</code> outputs, we could have <code class="markup--code markup--p-code">16x(4+c)</code> outputs. This gives us 16 sets of class probabilities and 16 sets of bounding box coordinates. Then we would just need a loss function that will check whether those 16 sets of bounding boxes correctly represented the up to 16 objects in the image (we will go into the loss function later).</p><figure name="09c8" id="09c8" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_fPHmCosDHcrHmtKvWFK9Mg.png"></figure><p name="8cbc" id="8cbc" class="graf graf--p graf-after--figure">The second way to do this is rather than using <code class="markup--code markup--p-code">nn.linear</code>, what if instead, we took from our ResNet convolutional backbone and added an <code class="markup--code markup--p-code">nn.Conv2d</code> with stride 2 [<a href="https://youtu.be/0frKXR-2PBY?t=31m32s" data-href="https://youtu.be/0frKXR-2PBY?t=31m32s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">31:32</a>]? This will give us a <code class="markup--code markup--p-code">4x4x[# of filters]</code> tensor — here let’s make it <code class="markup--code markup--p-code">4x4x(4+c)</code> so that we get a tensor where the number of elements is exactly equal to the number of elements we wanted. Now if we created a loss function that took a <code class="markup--code markup--p-code">4x4x(4+c)</code> tensor and and mapped it to 16 objects in the image and checked whether each one was correctly represented by these <code class="markup--code markup--p-code">4+c</code> activations, this would work as well. It turns out, both of these approaches are actually used [<a href="https://youtu.be/0frKXR-2PBY?t=33m48s" data-href="https://youtu.be/0frKXR-2PBY?t=33m48s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">33:48</a>]. The approach where the output is one big long vector from a fully connected linear layer is used by a class of models known as <a href="https://arxiv.org/abs/1506.02640" data-href="https://arxiv.org/abs/1506.02640" class="markup--anchor markup--p-anchor" rel="noopener nofollow" target="_blank">YOLO (You Only Look Once)</a>, where else, the approach of the convolutional activations is used by models which started with something called <a href="https://arxiv.org/abs/1512.02325" data-href="https://arxiv.org/abs/1512.02325" class="markup--anchor markup--p-anchor" rel="noopener nofollow" target="_blank">SSD (Single Shot Detector)</a>. Since these things came out very similar times in late 2015, things are very much moved towards SSD. So the point where this morning, <a href="https://pjreddie.com/media/files/papers/YOLOv3.pdf" data-href="https://pjreddie.com/media/files/papers/YOLOv3.pdf" class="markup--anchor markup--p-anchor" rel="noopener nofollow" target="_blank">YOLO version 3</a> came out and is now doing SSD, so that’s what we are going to do. We will also learn about why this makes more sense as well.</p><h4 name="20e9" id="20e9" class="graf graf--h4 graf-after--p">Anchor boxes&nbsp;[<a href="https://youtu.be/0frKXR-2PBY?t=35m04s" data-href="https://youtu.be/0frKXR-2PBY?t=35m04s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">35:04</a>]</h4><figure name="42e6" id="42e6" class="graf graf--figure graf-after--h4"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_8kpDP3FZFxW99IUQE0C8Xw.png"></figure><p name="4bfa" id="4bfa" class="graf graf--p graf-after--figure">Let’s imagine that we had another <code class="markup--code markup--p-code">Conv2d(stride=2)</code> then we would have <code class="markup--code markup--p-code">2x2x(4+c)</code> tensor. Basically, it is creating a grid that looks something like this:</p><figure name="37fd" id="37fd" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_uA-oJok4-Rng6mnHOOPyNQ.png"></figure><p name="c44d" id="c44d" class="graf graf--p graf-after--figure">This is how the geometry of the activations of the second extra convolutional stride 2 layer are. Remember, stride 2 convolution does the same thing to the geometry of the activations as a stride 1 convolution followed by maxpooling assuming the padding is ok.</p><p name="fd03" id="fd03" class="graf graf--p graf-after--p">Let’s talk about what we might do here [<a href="https://youtu.be/0frKXR-2PBY?t=36m9s" data-href="https://youtu.be/0frKXR-2PBY?t=36m9s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">36:09</a>]. We want each of these grid cell to be responsible for finding the largest object in that part of the image.</p><h4 name="3bae" id="3bae" class="graf graf--h4 graf-after--p">Receptive Field&nbsp;[<a href="https://youtu.be/0frKXR-2PBY?t=37m20s" data-href="https://youtu.be/0frKXR-2PBY?t=37m20s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">37:20</a>]</h4><p name="daf5" id="daf5" class="graf graf--p graf-after--h4">Why do we care about the idea that we would like each convolutional grid cell to be responsible for finding things that are in the corresponding part of the image? The reason is because of something called the receptive field of that convolutional grid cell. The basic idea is that throughout your convolutional layers, every piece of those tensors has a receptive field which means which part of the input image was responsible for calculating that cell. Like all things in life, the easiest way to see this is with Excel [<a href="https://youtu.be/0frKXR-2PBY?t=38m1s" data-href="https://youtu.be/0frKXR-2PBY?t=38m1s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">38:01</a>].</p><figure name="4875" id="4875" class="graf graf--figure graf--layoutOutsetCenter graf-after--p" data-scroll="native"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_IgL2CMSit3Hh9N2Fq2Zlgg.png"></figure><p name="d0cd" id="d0cd" class="graf graf--p graf-after--figure">Take a single activation (in this case in the maxpool layer)and let’s see where it came from [<a href="https://youtu.be/0frKXR-2PBY?t=38m45s" data-href="https://youtu.be/0frKXR-2PBY?t=38m45s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">38:45</a>]. In excel you can do Formulas → Trace Precedents. Tracing all the way back to the input layer, you can see that it came from this 6 x 6 portion of the image (as well as filters). What is more, the middle portion has lots of weights coming out of where else cells in the outside only have one weight coming out. So we call this 6 x 6 cells the receptive field of the one activation we picked.</p><figure name="719f" id="719f" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_cCBVbJ2WjiPMlqX4nA2bwA.png"><figcaption class="imageCaption">3x3 convolution with opacity 15% — clearly the center of the box has more dependencies</figcaption></figure><p name="10e4" id="10e4" class="graf graf--p graf-after--figure">Note that the receptive field is not just saying it’s this box but also that the center of the box has more dependencies [<a href="https://youtu.be/0frKXR-2PBY?t=40m27s" data-href="https://youtu.be/0frKXR-2PBY?t=40m27s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">40:27</a>] This is a critically important concept when it comes to understanding architectures and understanding why conv nets work the way they do.</p><h4 name="f66c" id="f66c" class="graf graf--h4 graf-after--p">Architecture [<a href="https://youtu.be/0frKXR-2PBY?t=41m18s" data-href="https://youtu.be/0frKXR-2PBY?t=41m18s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">41:18</a>]</h4><p name="19c4" id="19c4" class="graf graf--p graf-after--h4">The architecture is, we will have a ResNet backbone followed by one or more 2D convolutions (one for now) which is going to give us a <code class="markup--code markup--p-code">4x4</code> grid.</p><pre name="ddb9" id="ddb9" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">class</strong> <strong class="markup--strong markup--pre-strong">StdConv</strong>(nn.Module):<br>    <strong class="markup--strong markup--pre-strong">def</strong> __init__(self, nin, nout, stride=2, drop=0.1):<br>        super().__init__()<br>        self.conv = nn.Conv2d(nin, nout, 3, stride=stride, <br>                              padding=1)<br>        self.bn = nn.BatchNorm2d(nout)<br>        self.drop = nn.Dropout(drop)<br>        <br>    <strong class="markup--strong markup--pre-strong">def</strong> forward(self, x): <br>        <strong class="markup--strong markup--pre-strong">return</strong> self.drop(self.bn(F.relu(self.conv(x))))<br>        <br><strong class="markup--strong markup--pre-strong">def</strong> flatten_conv(x,k):<br>    bs,nf,gx,gy = x.size()<br>    x = x.permute(0,2,3,1).contiguous()<br>    <strong class="markup--strong markup--pre-strong">return</strong> x.view(bs,-1,nf//k)</pre><pre name="fa2e" id="fa2e" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">class</strong> <strong class="markup--strong markup--pre-strong">OutConv</strong>(nn.Module):<br>    <strong class="markup--strong markup--pre-strong">def</strong> __init__(self, k, nin, bias):<br>        super().__init__()<br>        self.k = k<br>        self.oconv1 = nn.Conv2d(nin, (len(id2cat)+1)*k, 3, <br>                                padding=1)<br>        self.oconv2 = nn.Conv2d(nin, 4*k, 3, padding=1)<br>        self.oconv1.bias.data.zero_().add_(bias)<br>        <br>    <strong class="markup--strong markup--pre-strong">def</strong> forward(self, x):<br>        <strong class="markup--strong markup--pre-strong">return</strong> [flatten_conv(self.oconv1(x), self.k),<br>                flatten_conv(self.oconv2(x), self.k)]</pre><pre name="d08c" id="d08c" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">class</strong> <strong class="markup--strong markup--pre-strong">SSD_Head</strong>(nn.Module):<br>    <strong class="markup--strong markup--pre-strong">def</strong> __init__(self, k, bias):<br>        super().__init__()<br>        self.drop = nn.Dropout(0.25)<br>        self.sconv0 = StdConv(512,256, stride=1)<br>        self.sconv2 = StdConv(256,256)<br>        self.out = OutConv(k, 256, bias)<br>        <br>    <strong class="markup--strong markup--pre-strong">def</strong> forward(self, x):<br>        x = self.drop(F.relu(x))<br>        x = self.sconv0(x)<br>        x = self.sconv2(x)<br>        <strong class="markup--strong markup--pre-strong">return</strong> self.out(x)<br><br>head_reg4 = SSD_Head(k, -3.)<br>models = ConvnetBuilder(f_model, 0, 0, 0, custom_head=head_reg4)<br>learn = ConvLearner(md, models)<br>learn.opt_fn = optim.Adam</pre><p name="2589" id="2589" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">SSD_Head</strong></p><ol class="postList"><li name="62b3" id="62b3" class="graf graf--li graf-after--p">We start with ReLU and dropout</li><li name="dbc8" id="dbc8" class="graf graf--li graf-after--li">Then stride 1 convolution. The reason we start with a stride 1 convolution is because that does not change the geometry at all — it just lets us add an extra layer of calculation. It lets us create not just a linear layer but now we have a little mini neural network in our custom head. <code class="markup--code markup--li-code">StdConv</code> is defined above — it does convolution, ReLU, BatchNorm, and dropout. Most research code you see won’t define a class like this, instead they write the entire thing again and again. Don’t be like that. Duplicate code leads to errors and poor understanding.</li><li name="74ad" id="74ad" class="graf graf--li graf-after--li">Stride 2 convolution [<a href="https://youtu.be/0frKXR-2PBY?t=44m56s" data-href="https://youtu.be/0frKXR-2PBY?t=44m56s" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">44:56</a>]</li><li name="b4de" id="b4de" class="graf graf--li graf-after--li">At the end, the output of step 3 is <code class="markup--code markup--li-code">4x4</code> which gets passed to <code class="markup--code markup--li-code">OutConv</code>. <code class="markup--code markup--li-code">OutConv</code> has two separate convolutional layers each of which is stride 1 so it is not changing the geometry of the input. One of them is of length of the number of classes (ignore <code class="markup--code markup--li-code">k</code> for now and <code class="markup--code markup--li-code">+1</code> is for “background” — i.e. no object was detected), the other’s length is 4. Rather than having a single conv layer that outputs <code class="markup--code markup--li-code">4+c</code>, let’s have two conv layers and return their outputs in a list. This allows these layers to specialize just a little bit. We talked about this idea that when you have multiple tasks, they can share layers, but they do not have to share all the layers. In this case, our two tasks of creating a classifier and creating and creating bounding box regression share every single layers except the very last one.</li><li name="7bcd" id="7bcd" class="graf graf--li graf-after--li">At the end, we flatten out the convolution because Jeremy wrote the loss function to expect flattened out tensor, but we could totally rewrite it to not do that.</li></ol><h4 name="d6b4" id="d6b4" class="graf graf--h4 graf-after--li"><a href="https://github.com/fastai/fastai/blob/master/docs/style.md" data-href="https://github.com/fastai/fastai/blob/master/docs/style.md" class="markup--anchor markup--h4-anchor" rel="noopener nofollow" target="_blank">Fastai Coding Style</a>&nbsp;[<a href="https://youtu.be/0frKXR-2PBY?t=42m58s" data-href="https://youtu.be/0frKXR-2PBY?t=42m58s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">42:58</a>]</h4><p name="6d61" id="6d61" class="graf graf--p graf-after--h4">The first draft was released this week. It is very heavily orient towards the idea of expository programming which is the idea that programming code should be something that you can use to explain an idea, ideally as readily as mathematical notation, to somebody that understands your coding method. The idea goes back a very long way, but it was best described in the Turing Award lecture of 1979 by probably Jeremy’s greatest computer science hero Ken Iverson. He had been working on it since well before 1964 but 1964 was the first example of this approach of programming he released which is called APL and 25 years later, he won the Turing Award. He then passed on the baton to his son Eric Iverson. Fastai style guide is an attempt at taking some of these ideas.</p><h4 name="2d44" id="2d44" class="graf graf--h4 graf-after--p">Loss Function&nbsp;[<a href="https://youtu.be/0frKXR-2PBY?t=47m44s" data-href="https://youtu.be/0frKXR-2PBY?t=47m44s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">47:44</a>]</h4><p name="aad3" id="aad3" class="graf graf--p graf-after--h4">The loss function needs to look at each of these 16 sets of activations, each of which has four bounding box coordinates and <code class="markup--code markup--p-code">c+1</code> class probabilities and decide if those activations are close or far away from the object which is the closest to this grid cell in the image. If nothing is there, then whether it is predicting background correctly. That turns out to be very hard to do.</p><h4 name="339d" id="339d" class="graf graf--h4 graf-after--p">Matching Problem&nbsp;[<a href="https://youtu.be/0frKXR-2PBY?t=48m43s" data-href="https://youtu.be/0frKXR-2PBY?t=48m43s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">48:43</a>]</h4><figure name="b566" id="b566" class="graf graf--figure graf-after--h4"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_2dqj3hivcOF6ThoL-nhMyA.png"></figure><p name="6b0b" id="6b0b" class="graf graf--p graf-after--figure">The loss function needs to take each of the objects in the image and match them to one of these convolutional grid cells to say “this grid cell is responsible for this particular object” so then it can go ahead and say “okay, how close are the 4 coordinates and how close are the class probabilities.</p><p name="8e9f" id="8e9f" class="graf graf--p graf-after--p">Here is our goal [<a href="https://youtu.be/0frKXR-2PBY?t=49m56s" data-href="https://youtu.be/0frKXR-2PBY?t=49m56s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">49:56</a>]:</p><figure name="f181" id="f181" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_8M9x-WgHNasmuLSJNbKoaQ.png"></figure><p name="3bda" id="3bda" class="graf graf--p graf-after--figure">Our dependent variable looks like the one on the left, and our final convolutional layer is going to be <code class="markup--code markup--p-code">4x4x(c+1)</code> in this case <code class="markup--code markup--p-code">c=20</code>. We then flatten that out into a vector. Our goal is to come up with a function which takes in a dependent variable and also some particular set of activations that ended up coming out of the model and returns a higher number if these activations are not a good reflection of the ground truth bounding boxes; or a lower number if it is a good reflection.</p><h4 name="308c" id="308c" class="graf graf--h4 graf-after--p">Testing [<a href="https://youtu.be/0frKXR-2PBY?t=51m58s" data-href="https://youtu.be/0frKXR-2PBY?t=51m58s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">51:58</a>]</h4><pre name="986e" id="986e" class="graf graf--pre graf-after--h4">x,y = next(iter(md.val_dl))<br>x,y = V(x),V(y)<br>learn.model.eval()<br>batch = learn.model(x)<br>b_clas,b_bb = batch<br>b_clas.size(),b_bb.size()</pre><pre name="209c" id="209c" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">(torch.Size([64, 16, 21]), torch.Size([64, 16, 4]))</em></pre><p name="992c" id="992c" class="graf graf--p graf-after--pre">Make sure these shapes make sense. Let’s now look at the ground truth <code class="markup--code markup--p-code">y</code> [<a href="https://youtu.be/0frKXR-2PBY?t=53m24s" data-href="https://youtu.be/0frKXR-2PBY?t=53m24s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">53:24</a>]:</p><pre name="5514" id="5514" class="graf graf--pre graf-after--p">idx=7<br>b_clasi = b_clas[idx]<br>b_bboxi = b_bb[idx]<br>ima=md.val_ds.ds.denorm(to_np(x))[idx]<br>bbox,clas = get_y(y[0][idx], y[1][idx])<br>bbox,clas</pre><pre name="b746" id="b746" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">(Variable containing:<br>  0.6786  0.4866  0.9911  0.6250<br>  0.7098  0.0848  0.9911  0.5491<br>  0.5134  0.8304  0.6696  0.9063<br> [torch.cuda.FloatTensor of size 3x4 (GPU 0)], Variable containing:<br>   8<br>  10<br>  17<br> [torch.cuda.LongTensor of size 3 (GPU 0)])</em></pre><p name="a6a5" id="a6a5" class="graf graf--p graf-after--pre">Note that bounding box coordinates have been scaled to between 0 and 1 — basically we are treating the image as being 1x1, so they are relative to the size of the image.</p><p name="b788" id="b788" class="graf graf--p graf-after--p">We already have <code class="markup--code markup--p-code">show_ground_truth</code> function. This <code class="markup--code markup--p-code">torch_gt</code> (gt: ground truth) function simply converts tensors into numpy array.</p><pre name="d582" id="d582" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">def</strong> torch_gt(ax, ima, bbox, clas, prs=<strong class="markup--strong markup--pre-strong">None</strong>, thresh=0.4):<br>    <strong class="markup--strong markup--pre-strong">return</strong> show_ground_truth(ax, ima, to_np((bbox*224).long()),<br>         to_np(clas), <br>         to_np(prs) <strong class="markup--strong markup--pre-strong">if</strong> prs <strong class="markup--strong markup--pre-strong">is</strong> <strong class="markup--strong markup--pre-strong">not</strong> <strong class="markup--strong markup--pre-strong">None</strong> <strong class="markup--strong markup--pre-strong">else</strong> <strong class="markup--strong markup--pre-strong">None</strong>, thresh)</pre><pre name="4392" id="4392" class="graf graf--pre graf-after--pre">fig, ax = plt.subplots(figsize=(7,7))<br>torch_gt(ax, ima, bbox, clas)</pre><figure name="d862" id="d862" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_Q3ZtSRtk-a2OwKfE1wa5zw.png"></figure><p name="68a9" id="68a9" class="graf graf--p graf-after--figure">The above is a ground truth. Here is our <code class="markup--code markup--p-code">4x4</code> grid cells from our final convolutional layer [<a href="https://youtu.be/0frKXR-2PBY?t=54m44s" data-href="https://youtu.be/0frKXR-2PBY?t=54m44s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">54:44</a>]:</p><pre name="1592" id="1592" class="graf graf--pre graf-after--p">fig, ax = plt.subplots(figsize=(7,7))<br>torch_gt(ax, ima, anchor_cnr, b_clasi.max(1)[1])</pre><figure name="9b0b" id="9b0b" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_xjKmShqdLnD_JX4Aj7U80g.png"></figure><p name="930c" id="930c" class="graf graf--p graf-after--figure">Each of these square boxes, different papers call them different things. The three terms you’ll hear are: anchor boxes, prior boxes, or default boxes. We will stick with the term anchor boxes.</p><p name="e77b" id="e77b" class="graf graf--p graf-after--p">What we are going to do for this loss function is we are going to go through a matching problem where we are going to take every one of these 16 boxes and see which one of these three ground truth objects has the highest amount of overlap with a given square [<a href="https://youtu.be/0frKXR-2PBY?t=55m21s" data-href="https://youtu.be/0frKXR-2PBY?t=55m21s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">55:21</a>]. To do this, we have to have some way of measuring amount of overlap and a standard function for this is called <a href="https://en.wikipedia.org/wiki/Jaccard_index" data-href="https://en.wikipedia.org/wiki/Jaccard_index" class="markup--anchor markup--p-anchor" rel="noopener nofollow" target="_blank">Jaccard index</a> (IoU).</p><figure name="7378" id="7378" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_10ORjq4HuOc0umcnojiDPA.png"></figure><p name="3347" id="3347" class="graf graf--p graf-after--figure">We are going to go through and find the Jaccard overlap for each one of the three objects versus each of the 16 anchor boxes [<a href="https://youtu.be/0frKXR-2PBY?t=57m11s" data-href="https://youtu.be/0frKXR-2PBY?t=57m11s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">57:11</a>]. That is going to give us a <code class="markup--code markup--p-code">3x16</code> matrix.</p><p name="3634" id="3634" class="graf graf--p graf-after--p">Here are the <em class="markup--em markup--p-em">coordinates</em> of all of our anchor boxes (centers, height, width):</p><pre name="4953" id="4953" class="graf graf--pre graf-after--p">anchors</pre><pre name="2863" id="2863" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">Variable containing:<br> 0.1250  0.1250  0.2500  0.2500<br> 0.1250  0.3750  0.2500  0.2500<br> 0.1250  0.6250  0.2500  0.2500<br> 0.1250  0.8750  0.2500  0.2500<br> 0.3750  0.1250  0.2500  0.2500<br> 0.3750  0.3750  0.2500  0.2500<br> 0.3750  0.6250  0.2500  0.2500<br> 0.3750  0.8750  0.2500  0.2500<br> 0.6250  0.1250  0.2500  0.2500<br> 0.6250  0.3750  0.2500  0.2500<br> 0.6250  0.6250  0.2500  0.2500<br> 0.6250  0.8750  0.2500  0.2500<br> 0.8750  0.1250  0.2500  0.2500<br> 0.8750  0.3750  0.2500  0.2500<br> 0.8750  0.6250  0.2500  0.2500<br> 0.8750  0.8750  0.2500  0.2500<br>[torch.cuda.FloatTensor of size 16x4 (GPU 0)]</em></pre><p name="9f3a" id="9f3a" class="graf graf--p graf-after--pre">Here are the amount of overlap between 3 ground truth objects and 16 anchor boxes:</p><pre name="f523" id="f523" class="graf graf--pre graf-after--p">overlaps = jaccard(bbox.data, anchor_cnr.data)<br>overlaps</pre><pre name="09bc" id="09bc" class="graf graf--pre graf-after--pre">Columns 0 to 7   <br>0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000    0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000    0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000  0.0000      </pre><pre name="888b" id="888b" class="graf graf--pre graf-after--pre">Columns 8 to 15   <br>0.0000  0.0091 0.0922  0.0000  0.0000  0.0315  0.3985  0.0000  0.0356  0.0549 0.0103  0.0000  0.2598  0.4538  0.0653  0.0000  0.0000  0.0000 0.0000  0.1897  0.0000  0.0000  0.0000  0.0000 [torch.cuda.FloatTensor of size 3x16 (GPU 0)]</pre><p name="8142" id="8142" class="graf graf--p graf-after--pre">What we could do now is we could take the max of dimension 1 (row-wise) which will tell us for each ground truth object, what the maximum amount that overlaps with some grid cell as well as the index:</p><pre name="197d" id="197d" class="graf graf--pre graf-after--p">overlaps.max(1)</pre><pre name="5e49" id="5e49" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">(<br>  0.3985<br>  0.4538<br>  0.1897<br> [torch.cuda.FloatTensor of size 3 (GPU 0)], <br>  14<br>  13<br>  11<br> [torch.cuda.LongTensor of size 3 (GPU 0)])</em></pre><p name="fdce" id="fdce" class="graf graf--p graf-after--pre">We will also going to look at max over a dimension 0 (column-wise) which will tell us what is the maximum amount of overlap for each grid cell across all of the ground truth objects [<a href="https://youtu.be/0frKXR-2PBY?t=59m8s" data-href="https://youtu.be/0frKXR-2PBY?t=59m8s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">59:08</a>]:</p><pre name="df2e" id="df2e" class="graf graf--pre graf-after--p">overlaps.max(0)</pre><pre name="757d" id="757d" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">(<br>  0.0000<br>  0.0000<br>  0.0000<br>  0.0000<br>  0.0000<br>  0.0000<br>  0.0000<br>  0.0000<br>  0.0356<br>  0.0549<br>  0.0922<br>  0.1897<br>  0.2598<br>  0.4538<br>  0.3985<br>  0.0000<br> [torch.cuda.FloatTensor of size 16 (GPU 0)], <br>  0<br>  0<br>  0<br>  0<br>  0<br>  0<br>  0<br>  0<br>  1<br>  1<br>  0<br>  2<br>  1<br>  1<br>  0<br>  0<br> [torch.cuda.LongTensor of size 16 (GPU 0)])</em></pre><p name="5f19" id="5f19" class="graf graf--p graf-after--pre">What is particularly interesting here is that it tells us for every grid cell what is the index of the ground truth object which overlaps with it the most. Zero is a bit overloaded here — zero could either mean the amount of overlap was zero or its largest overlap is with object index zero. It is going to turn out not to matter but just FYI.</p><p name="d4fd" id="d4fd" class="graf graf--p graf-after--p">There is a function called <code class="markup--code markup--p-code">map_to_ground_truth</code> which we will not worry about for now [<a href="https://youtu.be/0frKXR-2PBY?t=59m57s" data-href="https://youtu.be/0frKXR-2PBY?t=59m57s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">59:57</a>]. It is super simple code but it is slightly awkward to think about. Basically what it does is it combines these two sets of overlaps in a way described in the SSD paper to assign every anchor box to a ground truth object. The way it assign that is each of the three (row-wise max) gets assigned as is. For the rest of the anchor boxes, they get assigned to anything which they have an overlap of at least 0.5 with (column-wise). If neither applies, it is considered to be a cell which contains background.</p><pre name="367d" id="367d" class="graf graf--pre graf-after--p">gt_overlap,gt_idx = map_to_ground_truth(overlaps)<br>gt_overlap,gt_idx</pre><pre name="31ef" id="31ef" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">(<br>  0.0000<br>  0.0000<br>  0.0000<br>  0.0000<br>  0.0000<br>  0.0000<br>  0.0000<br>  0.0000<br>  0.0356<br>  0.0549<br>  0.0922<br>  1.9900<br>  0.2598<br>  1.9900<br>  1.9900<br>  0.0000<br> [torch.cuda.FloatTensor of size 16 (GPU 0)], <br>  0<br>  0<br>  0<br>  0<br>  0<br>  0<br>  0<br>  0<br>  1<br>  1<br>  0<br>  2<br>  1<br>  1<br>  0<br>  0<br> [torch.cuda.LongTensor of size 16 (GPU 0)])</em></pre><p name="66c7" id="66c7" class="graf graf--p graf-after--pre">Now you can see a list of all the assignments [<a href="https://youtu.be/0frKXR-2PBY?t=1h1m5s" data-href="https://youtu.be/0frKXR-2PBY?t=1h1m5s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:01:05</a>]. Anywhere that has <code class="markup--code markup--p-code">gt_overlap &lt; 0.5</code> gets assigned background. The three row-wise max anchor box has high number to force the assignments. Now we can combine these values to classes:</p><pre name="313f" id="313f" class="graf graf--pre graf-after--p">gt_clas = clas[gt_idx]; gt_clas</pre><pre name="cfab" id="cfab" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">Variable containing:<br>  8<br>  8<br>  8<br>  8<br>  8<br>  8<br>  8<br>  8<br> 10<br> 10<br>  8<br> 17<br> 10<br> 10<br>  8<br>  8<br>[torch.cuda.LongTensor of size 16 (GPU 0)]</em></pre><p name="73df" id="73df" class="graf graf--p graf-after--pre">Then add a threshold and finally comes up with the three classes that are being predicted:</p><pre name="9817" id="9817" class="graf graf--pre graf-after--p">thresh = 0.5<br>pos = gt_overlap &gt; thresh<br>pos_idx = torch.nonzero(pos)[:,0]<br>neg_idx = torch.nonzero(1-pos)[:,0]<br>pos_idx</pre><pre name="0b8b" id="0b8b" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em"> 11<br> 13<br> 14<br>[torch.cuda.LongTensor of size 3 (GPU 0)]</em></pre><p name="3aa2" id="3aa2" class="graf graf--p graf-after--pre">And here are what each of these anchor boxes is meant to be predicting:</p><pre name="3a09" id="3a09" class="graf graf--pre graf-after--p">gt_clas[1-pos] = len(id2cat)<br>[id2cat[o] <strong class="markup--strong markup--pre-strong">if</strong> o&lt;len(id2cat) <strong class="markup--strong markup--pre-strong">else</strong> 'bg' <strong class="markup--strong markup--pre-strong">for</strong> o <strong class="markup--strong markup--pre-strong">in</strong> gt_clas.data]</pre><pre name="6a65" id="6a65" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">['bg',<br> 'bg',<br> 'bg',<br> 'bg',<br> 'bg',<br> 'bg',<br> 'bg',<br> 'bg',<br> 'bg',<br> 'bg',<br> 'bg',<br> 'sofa',<br> 'bg',<br> 'diningtable',<br> 'chair',<br> 'bg']</em></pre><p name="c233" id="c233" class="graf graf--p graf-after--pre">So that was the matching stage [<a href="https://youtu.be/0frKXR-2PBY?t=1h2m29s" data-href="https://youtu.be/0frKXR-2PBY?t=1h2m29s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:02:29</a>]. For L1 loss, we can:</p><ol class="postList"><li name="1dc4" id="1dc4" class="graf graf--li graf-after--p">take the activations which matched (<code class="markup--code markup--li-code">pos_idx = [11, 13, 14]</code>)</li><li name="9131" id="9131" class="graf graf--li graf-after--li">subtract from those the ground truth bounding boxes</li><li name="9713" id="9713" class="graf graf--li graf-after--li">take the absolute value of the difference</li><li name="7f64" id="7f64" class="graf graf--li graf-after--li">take the mean of that.</li></ol><p name="483c" id="483c" class="graf graf--p graf-after--li">For classifications, we can just do a cross entropy</p><pre name="4c9b" id="4c9b" class="graf graf--pre graf-after--p">gt_bbox = bbox[gt_idx]<br>loc_loss = ((a_ic[pos_idx] - gt_bbox[pos_idx]).abs()).mean()<br>clas_loss  = F.cross_entropy(b_clasi, gt_clas)<br>loc_loss,clas_loss</pre><pre name="0d14" id="0d14" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">(Variable containing:<br> 1.00000e-02 *<br>   6.5887<br> [torch.cuda.FloatTensor of size 1 (GPU 0)], Variable containing:<br>  1.0331<br> [torch.cuda.FloatTensor of size 1 (GPU 0)])</em></pre><p name="8150" id="8150" class="graf graf--p graf-after--pre">We will end up with 16 predicted bounding boxes, most of them will be background. If you are wondering what it predicts in terms of bounding box of background, the answer is it totally ignores it.</p><pre name="7536" id="7536" class="graf graf--pre graf-after--p">fig, axes = plt.subplots(3, 4, figsize=(16, 12))<br><strong class="markup--strong markup--pre-strong">for</strong> idx,ax <strong class="markup--strong markup--pre-strong">in</strong> enumerate(axes.flat):<br>    ima=md.val_ds.ds.denorm(to_np(x))[idx]<br>    bbox,clas = get_y(y[0][idx], y[1][idx])<br>    ima=md.val_ds.ds.denorm(to_np(x))[idx]<br>    bbox,clas = get_y(bbox,clas); bbox,clas<br>    a_ic = actn_to_bb(b_bb[idx], anchors)<br>    torch_gt(ax, ima, a_ic, b_clas[idx].max(1)[1], <br>             b_clas[idx].max(1)[0].sigmoid(), 0.01)<br>plt.tight_layout()</pre><figure name="bcf4" id="bcf4" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_8azTUd1Ujf3FQSMBwIXgAw.png"></figure><h4 name="558e" id="558e" class="graf graf--h4 graf-after--figure">Tweak 1. How do we interpret the activations [<a href="https://youtu.be/0frKXR-2PBY?t=1h4m16s" data-href="https://youtu.be/0frKXR-2PBY?t=1h4m16s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">1:04:16</a>]?</h4><p name="cc2a" id="cc2a" class="graf graf--p graf-after--h4">The way we interpret the activation is defined here:</p><pre name="b02b" id="b02b" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">def</strong> actn_to_bb(actn, anchors):<br>    actn_bbs = torch.tanh(actn)<br>    actn_centers = (actn_bbs[:,:2]/2 * grid_sizes) + anchors[:,:2]<br>    actn_hw = (actn_bbs[:,2:]/2+1) * anchors[:,2:]<br>    <strong class="markup--strong markup--pre-strong">return</strong> hw2corners(actn_centers, actn_hw)</pre><p name="2a9b" id="2a9b" class="graf graf--p graf-after--pre">We grab the activations, we stick them through <code class="markup--code markup--p-code">tanh</code> (remember <code class="markup--code markup--p-code">tanh</code> is the same shape as sigmoid except it is scaled to be between -1 and 1) which forces it to be within that range. We then grab the actual position of the anchor boxes, and we will move them around according to the value of the activations divided by two (<code class="markup--code markup--p-code">actn_bbs[:,:2]/2</code>). In other words, each predicted bounding box can be moved by up to 50% of a grid size from where its default position is. Ditto for its height and width — it can be up to twice as big or half as big as its default size.</p><h4 name="d59f" id="d59f" class="graf graf--h4 graf-after--p">Tweak 2. We actually use binary cross entropy loss instead of cross entropy [<a href="https://youtu.be/0frKXR-2PBY?t=1h5m36s" data-href="https://youtu.be/0frKXR-2PBY?t=1h5m36s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">1:05:36</a>]</h4><pre name="960e" id="960e" class="graf graf--pre graf-after--h4"><strong class="markup--strong markup--pre-strong">class</strong> <strong class="markup--strong markup--pre-strong">BCE_Loss</strong>(nn.Module):<br>    <strong class="markup--strong markup--pre-strong">def</strong> __init__(self, num_classes):<br>        super().__init__()<br>        self.num_classes = num_classes<br><br>    <strong class="markup--strong markup--pre-strong">def</strong> forward(self, pred, targ):<br>        t = one_hot_embedding(targ, self.num_classes+1)<br>        t = V(t[:,:-1].contiguous())<em class="markup--em markup--pre-em">#.cpu()</em><br>        x = pred[:,:-1]<br>        w = self.get_weight(x,t)<br>        <strong class="markup--strong markup--pre-strong">return</strong> F.binary_cross_entropy_with_logits(x, t, w, <br>                            size_average=<strong class="markup--strong markup--pre-strong">False</strong>)/self.num_classes<br>    <br>    <strong class="markup--strong markup--pre-strong">def</strong> get_weight(self,x,t): <strong class="markup--strong markup--pre-strong">return</strong> <strong class="markup--strong markup--pre-strong">None</strong></pre><p name="820e" id="820e" class="graf graf--p graf-after--pre">Binary cross entropy is what we normally use for multi-label classification. Like in the planet satellite competition, each satellite image could have multiple things. If it has multiple things in it, you cannot use softmax because softmax really encourages just one thing to have the high number. In our case, each anchor box can only have one object associated with it, so it is not for that reason that we are avoiding softmax. It is something else — which is it is possible for an anchor box to have nothing associated with it. There are two ways to handle this idea of “background”; one would be to say background is just a class, so let’s use softmax and just treat background as one of the classes that the softmax could predict. A lot of people have done it this way. But that is a really hard thing to ask neural network to do [<a href="https://youtu.be/0frKXR-2PBY?t=1h5m52s" data-href="https://youtu.be/0frKXR-2PBY?t=1h5m52s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:06:52</a>] — it is basically asking whether this grid cell does not have any of the 20 objects that I am interested with Jaccard overlap of more than 0.5. It is a really hard to thing to put into a single computation. On the other hand, what if we just asked for each class; “is it a motorbike?” “is it a bus?”, “ is it a person?” etc and if all the answer is no, consider that background. That is the way we do it here. It is not that we can have multiple true labels, but we can have zero.</p><p name="29b4" id="29b4" class="graf graf--p graf-after--p">In <code class="markup--code markup--p-code">forward</code>&nbsp;:</p><ol class="postList"><li name="482a" id="482a" class="graf graf--li graf-after--p">First we take the one hot embedding of the target (at this stage, we do have the idea of background)</li><li name="0e7c" id="0e7c" class="graf graf--li graf-after--li">Then we remove the background column (the last one) which results in a vector either of all zeros or one one.</li><li name="7ba1" id="7ba1" class="graf graf--li graf-after--li">Use binary cross-entropy predictions.</li></ol><p name="6a88" id="6a88" class="graf graf--p graf-after--li">This is a minor tweak, but it is the kind of minor tweak that Jeremy wants you to think about and understand because it makes a really big difference to your training and when there is some increment over a previous paper, it would be something like this [<a href="https://youtu.be/0frKXR-2PBY?t=1h8m25s" data-href="https://youtu.be/0frKXR-2PBY?t=1h8m25s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:08:25</a>]. It is important to understand what this is doing and more importantly why.</p><p name="9ad6" id="9ad6" class="graf graf--p graf-after--p">So now we have [<a href="https://youtu.be/0frKXR-2PBY?t=1h9m39s" data-href="https://youtu.be/0frKXR-2PBY?t=1h9m39s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:09:39</a>]:</p><ul class="postList"><li name="3ec1" id="3ec1" class="graf graf--li graf-after--p">A custom loss function</li><li name="d4bf" id="d4bf" class="graf graf--li graf-after--li">A way to calculate Jaccard index</li><li name="882e" id="882e" class="graf graf--li graf-after--li">A way to convert activations to bounding box</li><li name="71d6" id="71d6" class="graf graf--li graf-after--li">A way to map anchor boxes to ground truth</li></ul><p name="9d33" id="9d33" class="graf graf--p graf-after--li">Now all it’s left is SSD loss function.</p><h4 name="5fe0" id="5fe0" class="graf graf--h4 graf-after--p">SSD Loss Function [<a href="https://youtu.be/0frKXR-2PBY?t=1h9m55s" data-href="https://youtu.be/0frKXR-2PBY?t=1h9m55s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">1:09:55</a>]</h4><pre name="96a6" id="96a6" class="graf graf--pre graf-after--h4"><strong class="markup--strong markup--pre-strong">def</strong> ssd_1_loss(b_c,b_bb,bbox,clas,print_it=<strong class="markup--strong markup--pre-strong">False</strong>):<br>    bbox,clas = get_y(bbox,clas)<br>    a_ic = actn_to_bb(b_bb, anchors)<br>    overlaps = jaccard(bbox.data, anchor_cnr.data)<br>    gt_overlap,gt_idx = map_to_ground_truth(overlaps,print_it)<br>    gt_clas = clas[gt_idx]<br>    pos = gt_overlap &gt; 0.4<br>    pos_idx = torch.nonzero(pos)[:,0]<br>    gt_clas[1-pos] = len(id2cat)<br>    gt_bbox = bbox[gt_idx]<br>    loc_loss = ((a_ic[pos_idx] - gt_bbox[pos_idx]).abs()).mean()<br>    clas_loss  = loss_f(b_c, gt_clas)<br>    <strong class="markup--strong markup--pre-strong">return</strong> loc_loss, clas_loss<br><br><strong class="markup--strong markup--pre-strong">def</strong> ssd_loss(pred,targ,print_it=<strong class="markup--strong markup--pre-strong">False</strong>):<br>    lcs,lls = 0.,0.<br>    <strong class="markup--strong markup--pre-strong">for</strong> b_c,b_bb,bbox,clas <strong class="markup--strong markup--pre-strong">in</strong> zip(*pred,*targ):<br>        loc_loss,clas_loss = ssd_1_loss(b_c,b_bb,bbox,clas,print_it)<br>        lls += loc_loss<br>        lcs += clas_loss<br>    <strong class="markup--strong markup--pre-strong">if</strong> print_it: print(f'loc: <strong class="markup--strong markup--pre-strong">{lls.data[0]}</strong>, clas: <strong class="markup--strong markup--pre-strong">{lcs.data[0]}</strong>')<br>    <strong class="markup--strong markup--pre-strong">return</strong> lls+lcs</pre><p name="8c47" id="8c47" class="graf graf--p graf-after--pre">The <code class="markup--code markup--p-code">ssd_loss</code> function which is what we set as the criteria, it loops through each image in the mini-batch and call <code class="markup--code markup--p-code">ssd_1_loss</code> function (i.e. SSD loss for one image).</p><p name="98d0" id="98d0" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">ssd_1_loss</code> is where it is all happening. It begins by de-structuring <code class="markup--code markup--p-code">bbox</code> and <code class="markup--code markup--p-code">clas</code>. Let’s take a closer look at <code class="markup--code markup--p-code">get_y</code> [<a href="https://youtu.be/0frKXR-2PBY?t=1h10m38s" data-href="https://youtu.be/0frKXR-2PBY?t=1h10m38s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:10:38</a>]:</p><pre name="b8d2" id="b8d2" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">def</strong> get_y(bbox,clas):<br>    bbox = bbox.view(-1,4)/sz<br>    bb_keep = ((bbox[:,2]-bbox[:,0])&gt;0).nonzero()[:,0]<br>    <strong class="markup--strong markup--pre-strong">return</strong> bbox[bb_keep],clas[bb_keep]</pre><p name="d4b5" id="d4b5" class="graf graf--p graf-after--pre">A lot of code you find on the internet does not work with mini-batches. It only does one thing at a time which we don’t want. In this case, all these functions (<code class="markup--code markup--p-code">get_y</code>, <code class="markup--code markup--p-code">actn_to_bb</code>, <code class="markup--code markup--p-code">map_to_ground_truth</code>) is working on, not exactly a mini-batch at a time, but a whole bunch of ground truth objects at a time. The data loader is being fed a mini-batch at a time to do the convolutional layers. Because we can have <em class="markup--em markup--p-em">different numbers of ground truth objects in each image</em> but a tensor has to be the strict rectangular shape, fastai automatically pads it with zeros (any target values that are shorter) [<a href="https://youtu.be/0frKXR-2PBY?t=1h11m8s" data-href="https://youtu.be/0frKXR-2PBY?t=1h11m8s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:11:08</a>]. This was something that was added recently and super handy, but that does mean that you then have to make sure that you get rid of those zeros. So <code class="markup--code markup--p-code">get_y</code> gets rid of any of the bounding boxes that are just padding.</p><ol class="postList"><li name="f229" id="f229" class="graf graf--li graf-after--p">Get rid of the padding</li><li name="0e2d" id="0e2d" class="graf graf--li graf-after--li">Turn the activations to bounding boxes</li><li name="953a" id="953a" class="graf graf--li graf-after--li">Do the Jaccard</li><li name="fa65" id="fa65" class="graf graf--li graf-after--li">Do map_to_ground_truth</li><li name="26b9" id="26b9" class="graf graf--li graf-after--li">Check that there is an overlap greater than something around 0.4~0.5 (different papers use different values for this)</li><li name="aa5a" id="aa5a" class="graf graf--li graf-after--li">Find the indices of things that matched</li><li name="bad6" id="bad6" class="graf graf--li graf-after--li">Assign background class for the ones that did not match</li><li name="a55d" id="a55d" class="graf graf--li graf-after--li">Then finally get L1 loss for the localization, binary cross entropy loss for the classification, and return them which gets added in <code class="markup--code markup--li-code">ssd_loss</code></li></ol><h4 name="b35e" id="b35e" class="graf graf--h4 graf-after--li">Training [<a href="https://youtu.be/0frKXR-2PBY?t=1h12m47s" data-href="https://youtu.be/0frKXR-2PBY?t=1h12m47s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">1:12:47</a>]</h4><pre name="0f37" id="0f37" class="graf graf--pre graf-after--h4">learn.crit = ssd_loss<br>lr = 3e-3<br>lrs = np.array([lr/100,lr/10,lr])</pre><pre name="8eb3" id="8eb3" class="graf graf--pre graf-after--pre">learn.lr_find(lrs/1000,1.)<br>learn.sched.plot(1)</pre><pre name="5ef8" id="5ef8" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">epoch      trn_loss   val_loss                            <br>    0      44.232681  21476.816406</em></pre><figure name="9862" id="9862" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_V8J7FkreIVG7tKxGQQRV2Q.png"></figure><pre name="c8ad" id="c8ad" class="graf graf--pre graf-after--figure">learn.lr_find(lrs/1000,1.)<br>learn.sched.plot(1)</pre><pre name="6db9" id="6db9" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">epoch      trn_loss   val_loss                            <br>    0      86.852668  32587.789062</em></pre><figure name="939e" id="939e" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_-q583mkIy-e3k6dz5HmkYw.png"></figure><pre name="b198" id="b198" class="graf graf--pre graf-after--figure">learn.fit(lr, 1, cycle_len=5, use_clr=(20,10))</pre><pre name="e101" id="e101" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">epoch      trn_loss   val_loss                            <br>    0      45.570843  37.099854 <br>    1      37.165911  32.165031                           <br>    2      33.27844   30.990122                           <br>    3      31.12054   29.804482                           <br>    4      29.305789  28.943184</em></pre><pre name="3fb3" id="3fb3" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">[28.943184]</em></pre><pre name="f2a9" id="f2a9" class="graf graf--pre graf-after--pre">learn.fit(lr, 1, cycle_len=5, use_clr=(20,10))</pre><pre name="e4ee" id="e4ee" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">epoch      trn_loss   val_loss                            <br>    0      43.726979  33.803085 <br>    1      34.771754  29.012939                           <br>    2      30.591864  27.132868                           <br>    3      27.896905  26.151638                           <br>    4      25.907382  25.739273</em></pre><pre name="e44e" id="e44e" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">[25.739273]</em></pre><pre name="b505" id="b505" class="graf graf--pre graf-after--pre">learn.save('0')</pre><pre name="e878" id="e878" class="graf graf--pre graf-after--pre">learn.load('0')</pre><h4 name="6949" id="6949" class="graf graf--h4 graf-after--pre">Result [<a href="https://youtu.be/0frKXR-2PBY?t=1h13m16s" data-href="https://youtu.be/0frKXR-2PBY?t=1h13m16s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">1:13:16</a>]</h4><figure name="3657" id="3657" class="graf graf--figure graf-after--h4"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_8azTUd1Ujf3FQSMBwIXgAw.png"></figure><p name="efec" id="efec" class="graf graf--p graf-after--figure">In practice, we want to remove the background and also add some threshold for probabilities, but it is on the right track. The potted plant image, the result is not surprising as all of our anchor boxes were small (4x4 grid). To go from here to something that is going to be more accurate, all we are going to do is to create way more anchor boxes.</p><p name="c496" id="c496" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Question</strong>: For the multi-label classification, why aren’t we multiplying the categorical loss by a constant like we did before [<a href="https://youtu.be/0frKXR-2PBY?t=1h15m20s" data-href="https://youtu.be/0frKXR-2PBY?t=1h15m20s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:15:20</a>]? Great question. It is because later on it will turn out we do not need to.</p><h4 name="5ece" id="5ece" class="graf graf--h4 graf-after--p">More anchors! [<a href="https://youtu.be/0frKXR-2PBY?t=1h14m47s" data-href="https://youtu.be/0frKXR-2PBY?t=1h14m47s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">1:14:47</a>]</h4><p name="3906" id="3906" class="graf graf--p graf-after--h4">There are 3 ways to do this:</p><ol class="postList"><li name="9e13" id="9e13" class="graf graf--li graf-after--p">Create anchor boxes of different sizes (zoom):</li></ol><figure name="ce4b" id="ce4b" class="graf graf--figure graf--layoutOutsetRow is-partialWidth graf-after--li" style="width: 33.668%;" data-scroll="native"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_OtrTSJqBXyjeypKehik1CQ.png"></figure><figure name="b8d9" id="b8d9" class="graf graf--figure graf--layoutOutsetRowContinue is-partialWidth graf-after--figure" style="width: 33.133%;" data-scroll="native"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_YG5bCP3O-jVhaQX_wuiSSg.png"></figure><figure name="02ff" id="02ff" class="graf graf--figure graf--layoutOutsetRowContinue is-partialWidth graf-after--figure" style="width: 33.2%;" data-scroll="native"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_QCo0wOgJKXDBYNlmE7zUmA.png"><figcaption class="imageCaption" style="width: 301.205%; left: -201.205%;">From left (1x1, 2x2, 4x4 grids of anchor boxes). Notice that some of the anchor box is bigger than the original&nbsp;image.</figcaption></figure><p name="225d" id="225d" class="graf graf--p graf-after--figure">2. Create anchor boxes of different aspect ratios:</p><figure name="fdae" id="fdae" class="graf graf--figure graf--layoutOutsetRow is-partialWidth graf-after--p" style="width: 33.333%;" data-scroll="native"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_ko8vZK4RD8H2l4u1hXCQZQ.png"></figure><figure name="0b2d" id="0b2d" class="graf graf--figure graf--layoutOutsetRowContinue is-partialWidth graf-after--figure" style="width: 33.1%;" data-scroll="native"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_3rvuvY6Fu2S6eoN3nK1QWg.png"></figure><figure name="508b" id="508b" class="graf graf--figure graf--layoutOutsetRowContinue is-partialWidth graf-after--figure" style="width: 33.567%;" data-scroll="native"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_bWZwFqf2Bv-ZbW-KedNO0Q.png"></figure><p name="8881" id="8881" class="graf graf--p graf-after--figure">3. Use more convolutional layers as sources of anchor boxes (the boxes are randomly jittered so that we can see ones that are overlapping [<a href="https://youtu.be/0frKXR-2PBY?t=1h16m28s" data-href="https://youtu.be/0frKXR-2PBY?t=1h16m28s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:16:28</a>]):</p><figure name="f455" id="f455" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_LwFOFtmawmpqp6VDc56RmA.png"></figure><p name="305a" id="305a" class="graf graf--p graf-after--figure">Combining these approaches, you can create lots of anchor boxes (Jeremy said he wouldn’t print it, but here it is):</p><figure name="fd17" id="fd17" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_ymt8L0CCKMd9SG82SemdIA.png"></figure><pre name="14d2" id="14d2" class="graf graf--pre graf-after--figure">anc_grids = [4, 2, 1]<br>anc_zooms = [0.75, 1., 1.3]<br>anc_ratios = [(1., 1.), (1., 0.5), (0.5, 1.)]<br><br>anchor_scales = [(anz*i,anz*j) <strong class="markup--strong markup--pre-strong">for</strong> anz <strong class="markup--strong markup--pre-strong">in</strong> anc_zooms <br>                                    <strong class="markup--strong markup--pre-strong">for</strong> (i,j) <strong class="markup--strong markup--pre-strong">in</strong> anc_ratios]<br>k = len(anchor_scales)<br>anc_offsets = [1/(o*2) <strong class="markup--strong markup--pre-strong">for</strong> o <strong class="markup--strong markup--pre-strong">in</strong> anc_grids]</pre><pre name="2e8f" id="2e8f" class="graf graf--pre graf-after--pre">anc_x = np.concatenate([np.repeat(np.linspace(ao, 1-ao, ag), ag)<br>                        <strong class="markup--strong markup--pre-strong">for</strong> ao,ag <strong class="markup--strong markup--pre-strong">in</strong> zip(anc_offsets,anc_grids)])<br>anc_y = np.concatenate([np.tile(np.linspace(ao, 1-ao, ag), ag)<br>                        <strong class="markup--strong markup--pre-strong">for</strong> ao,ag <strong class="markup--strong markup--pre-strong">in</strong> zip(anc_offsets,anc_grids)])<br>anc_ctrs = np.repeat(np.stack([anc_x,anc_y], axis=1), k, axis=0)</pre><pre name="908b" id="908b" class="graf graf--pre graf-after--pre">anc_sizes = np.concatenate([np.array([[o/ag,p/ag] <br>              <strong class="markup--strong markup--pre-strong">for</strong> i <strong class="markup--strong markup--pre-strong">in</strong> range(ag*ag) <strong class="markup--strong markup--pre-strong">for</strong> o,p <strong class="markup--strong markup--pre-strong">in</strong> anchor_scales])<br>                 <strong class="markup--strong markup--pre-strong">for</strong> ag <strong class="markup--strong markup--pre-strong">in</strong> anc_grids])<br>grid_sizes = V(np.concatenate([np.array([ 1/ag <br>              <strong class="markup--strong markup--pre-strong">for</strong> i <strong class="markup--strong markup--pre-strong">in</strong> range(ag*ag) <strong class="markup--strong markup--pre-strong">for</strong> o,p <strong class="markup--strong markup--pre-strong">in</strong> anchor_scales])<br>                  <strong class="markup--strong markup--pre-strong">for</strong> ag <strong class="markup--strong markup--pre-strong">in</strong> anc_grids]), <br>                      requires_grad=<strong class="markup--strong markup--pre-strong">False</strong>).unsqueeze(1)<br>anchors = V(np.concatenate([anc_ctrs, anc_sizes], axis=1), <br>              requires_grad=<strong class="markup--strong markup--pre-strong">False</strong>).float()<br>anchor_cnr = hw2corners(anchors[:,:2], anchors[:,2:])</pre><p name="43cc" id="43cc" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">anchors</code>&nbsp;: middle and height, width</p><p name="1b94" id="1b94" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">anchor_cnr</code>&nbsp;: top left and bottom right corners</p><h4 name="ce3e" id="ce3e" class="graf graf--h4 graf-after--p">Review of key concept [<a href="https://youtu.be/0frKXR-2PBY?t=1h18m" data-href="https://youtu.be/0frKXR-2PBY?t=1h18m" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">1:18:00</a>]</h4><figure name="a3db" id="a3db" class="graf graf--figure graf-after--h4"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_C67J9RhTAiz9MCD-ebpp_w.png"></figure><ul class="postList"><li name="cdc9" id="cdc9" class="graf graf--li graf-after--figure">We have a vector of ground truth (sets of 4 bounding box coordinates and a class)</li><li name="eb81" id="eb81" class="graf graf--li graf-after--li">We have a neural net that takes some input and spits out some output activations</li><li name="1fb5" id="1fb5" class="graf graf--li graf-after--li">Compare the activations and the ground truth, calculate a loss, find the derivative of that, and adjust weights according to the derivative times a learning rate.</li><li name="90af" id="90af" class="graf graf--li graf-after--li">We need a loss function that can take ground truth and activation and spit out a number that says how good these activations are. To do this, we need to take each one of <code class="markup--code markup--li-code">m</code> ground truth objects and decide which set of <code class="markup--code markup--li-code">(4+c)</code> activations is responsible for that object [<a href="https://youtu.be/0frKXR-2PBY?t=1h21m58s" data-href="https://youtu.be/0frKXR-2PBY?t=1h21m58s" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">1:21:58</a>] — which one we should be comparing to decide whether the class is correct and bounding box is close or not (matching problem).</li><li name="48c8" id="48c8" class="graf graf--li graf-after--li">Since we are using SSD approach, so it is not arbitrary which ones we match up [<a href="https://youtu.be/0frKXR-2PBY?t=1h23m18s" data-href="https://youtu.be/0frKXR-2PBY?t=1h23m18s" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">1:23:18</a>]. We want to match up the set of activations whose receptive field has the maximum density from where the real object is.</li><li name="c1a1" id="c1a1" class="graf graf--li graf-after--li">The loss function needs to be some consistent task. If in the first image, the top left object corresponds with the first 4+c activations, and in the second image, we threw things around and suddenly it’s now going with the last 4+c activations, the neural net doesn’t know what to learn.</li><li name="3723" id="3723" class="graf graf--li graf-after--li">Once matching problem is resolved, the rest is just the same as the single object detection.</li></ul><p name="7654" id="7654" class="graf graf--p graf-after--li">Architectures:</p><ul class="postList"><li name="2c45" id="2c45" class="graf graf--li graf-after--p">YOLO — the last layer is fully connected (no concept of geometry)</li><li name="639f" id="639f" class="graf graf--li graf-after--li">SSD — the last layer is convolutional</li></ul><h4 name="db54" id="db54" class="graf graf--h4 graf-after--li">k (zooms x ratios)[<a href="https://youtu.be/0frKXR-2PBY?t=1h29m39s" data-href="https://youtu.be/0frKXR-2PBY?t=1h29m39s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">1:29:39</a>]</h4><p name="c68a" id="c68a" class="graf graf--p graf-after--h4">For every grid cell which can be different sizes, we can have different orientations and zooms representing different anchor boxes which are just like conceptual ideas that every one of anchor boxes is associated with one set of <code class="markup--code markup--p-code">4+c</code> activations in our model. So however many anchor boxes we have, we need to have that times <code class="markup--code markup--p-code">(4+c)</code> activations. That does not mean that each convolutional layer needs that many activations. Because 4x4 convolutional layer already has 16 sets of activations, the 2x2 layer has 4 sets of activations, and finally 1x1 has one set. So we basically get 1 + 4 + 16 for free. So we only needs to know <code class="markup--code markup--p-code">k</code> where <code class="markup--code markup--p-code">k</code> is the number of zooms by the number of aspect ratios. Where else, the grids, we will get for free through our architecture.</p><h4 name="ca16" id="ca16" class="graf graf--h4 graf-after--p">Model Architecture [<a href="https://youtu.be/0frKXR-2PBY?t=1h31m10s" data-href="https://youtu.be/0frKXR-2PBY?t=1h31m10s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">1:31:10</a>]</h4><pre name="4a50" id="4a50" class="graf graf--pre graf-after--h4">drop=0.4<br><br><strong class="markup--strong markup--pre-strong">class</strong> <strong class="markup--strong markup--pre-strong">SSD_MultiHead</strong>(nn.Module):<br>    <strong class="markup--strong markup--pre-strong">def</strong> __init__(self, k, bias):<br>        super().__init__()<br>        self.drop = nn.Dropout(drop)<br>        self.sconv0 = StdConv(512,256, stride=1, drop=drop)<br>        self.sconv1 = StdConv(256,256, drop=drop)<br>        self.sconv2 = StdConv(256,256, drop=drop)<br>        self.sconv3 = StdConv(256,256, drop=drop)<br>        self.out1 = OutConv(k, 256, bias)<br>        self.out2 = OutConv(k, 256, bias)<br>        self.out3 = OutConv(k, 256, bias)<br><br>    <strong class="markup--strong markup--pre-strong">def</strong> forward(self, x):<br>        x = self.drop(F.relu(x))<br>        x = self.sconv0(x)<br>        x = self.sconv1(x)<br>        o1c,o1l = self.out1(x)<br>        x = self.sconv2(x)<br>        o2c,o2l = self.out2(x)<br>        x = self.sconv3(x)<br>        o3c,o3l = self.out3(x)<br>        <strong class="markup--strong markup--pre-strong">return</strong> [torch.cat([o1c,o2c,o3c], dim=1),<br>                torch.cat([o1l,o2l,o3l], dim=1)]<br><br>head_reg4 = SSD_MultiHead(k, -4.)<br>models = ConvnetBuilder(f_model, 0, 0, 0, custom_head=head_reg4)<br>learn = ConvLearner(md, models)<br>learn.opt_fn = optim.Adam</pre><p name="5fd9" id="5fd9" class="graf graf--p graf-after--pre">The model is nearly identical to what we had before. But we have a number of stride 2 convolutions which is going to take us through to 4x4, 2x2, and 1x1 (each stride 2 convolution halves our grid size in both directions).</p><ul class="postList"><li name="5dc6" id="5dc6" class="graf graf--li graf-after--p">After we do our first convolution to get to 4x4, we will grab a set of outputs from that because we want to save away the 4x4 anchors.</li><li name="16d7" id="16d7" class="graf graf--li graf-after--li">Once we get to 2x2, we grab another set of now 2x2 anchors</li><li name="f368" id="f368" class="graf graf--li graf-after--li">Then finally we get to 1x1</li><li name="afc1" id="afc1" class="graf graf--li graf-after--li">We then concatenate them all together, which gives us the correct number of activations (one activation for every anchor box).</li></ul><h4 name="5984" id="5984" class="graf graf--h4 graf-after--li">Training [<a href="https://youtu.be/0frKXR-2PBY?t=1h32m50s" data-href="https://youtu.be/0frKXR-2PBY?t=1h32m50s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">1:32:50</a>]</h4><pre name="676d" id="676d" class="graf graf--pre graf-after--h4">learn.crit = ssd_loss<br>lr = 1e-2<br>lrs = np.array([lr/100,lr/10,lr])</pre><pre name="1dca" id="1dca" class="graf graf--pre graf-after--pre">learn.lr_find(lrs/1000,1.)<br>learn.sched.plot(n_skip_end=2)</pre><figure name="1150" id="1150" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_jB_OxbaTmMXHbkeXE4G0SQ.png"></figure><pre name="a580" id="a580" class="graf graf--pre graf-after--figure">learn.fit(lrs, 1, cycle_len=4, use_clr=(20,8))</pre><pre name="0d46" id="0d46" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">epoch      trn_loss   val_loss                            <br>    0      15.124349  15.015433 <br>    1      13.091956  10.39855                            <br>    2      11.643629  9.4289                              <br>    3      10.532467  8.822998</em></pre><pre name="296f" id="296f" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">[8.822998]</em></pre><pre name="7b9f" id="7b9f" class="graf graf--pre graf-after--pre">learn.save('tmp')</pre><pre name="7493" id="7493" class="graf graf--pre graf-after--pre">learn.freeze_to(-2)<br>learn.fit(lrs/2, 1, cycle_len=4, use_clr=(20,8))</pre><pre name="98c2" id="98c2" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">epoch      trn_loss   val_loss                            <br>    0      9.821056   10.335152 <br>    1      9.419633   11.834093                           <br>    2      8.78818    7.907762                            <br>    3      8.219976   7.456364</em></pre><pre name="727f" id="727f" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">[7.4563637]</em></pre><pre name="2c78" id="2c78" class="graf graf--pre graf-after--pre">x,y = next(iter(md.val_dl))<br>y = V(y)<br>batch = learn.model(V(x))<br>b_clas,b_bb = batch<br>x = to_np(x)<br><br>fig, axes = plt.subplots(3, 4, figsize=(16, 12))<br><strong class="markup--strong markup--pre-strong">for</strong> idx,ax <strong class="markup--strong markup--pre-strong">in</strong> enumerate(axes.flat):<br>    ima=md.val_ds.ds.denorm(x)[idx]<br>    bbox,clas = get_y(y[0][idx], y[1][idx])<br>    a_ic = actn_to_bb(b_bb[idx], anchors)<br>    torch_gt(ax, ima, a_ic, b_clas[idx].max(1)[1], <br>             b_clas[idx].max(1)[0].sigmoid(), <strong class="markup--strong markup--pre-strong">0.2</strong>)<br>plt.tight_layout()</pre><p name="bac0" id="bac0" class="graf graf--p graf-after--pre">Here, we printed out those detections with at least probability of <code class="markup--code markup--p-code">0.2</code>&nbsp;. Some of them look pretty hopeful but others not so much.</p><figure name="bc4f" id="bc4f" class="graf graf--figure graf--layoutOutsetCenter graf-after--p" data-scroll="native"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_l168j5d3fWBZLST3XLPD6A.png"></figure><h3 name="acc2" id="acc2" class="graf graf--h3 graf-after--figure">History of object detection [<a href="https://youtu.be/0frKXR-2PBY?t=1h33m43s" data-href="https://youtu.be/0frKXR-2PBY?t=1h33m43s" class="markup--anchor markup--h3-anchor" rel="nofollow noopener" target="_blank">1:33:43</a>]</h3><figure name="16b5" id="16b5" class="graf graf--figure graf-after--h3"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_bQPvoI0soxtlBt1cEZlzcQ.png"></figure><p name="8ece" id="8ece" class="graf graf--p graf-after--figure"><a href="https://arxiv.org/abs/1312.2249" data-href="https://arxiv.org/abs/1312.2249" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Scalable Object Detection using Deep Neural Networks</a></p><ul class="postList"><li name="c5f6" id="c5f6" class="graf graf--li graf-after--p">When people refer to the multi-box method, they are talking about this paper.</li><li name="1caf" id="1caf" class="graf graf--li graf-after--li">This was the paper that came up with the idea that we can have a loss function that has this matching process and then you can use that to do object detection. So everything since that time has been trying to figure out how to make this better.</li></ul><p name="29bb" id="29bb" class="graf graf--p graf-after--li"><a href="https://arxiv.org/abs/1506.01497" data-href="https://arxiv.org/abs/1506.01497" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Faster R-CNN: Towards Real-Time Object Detection with Region Proposal Networks</a></p><ul class="postList"><li name="3858" id="3858" class="graf graf--li graf-after--p">In parallel, Ross Girshick was going down a totally different direction. He had these two-stage process where the first stage used the classical computer vision approaches to find edges and changes of gradients to guess which parts of the image may represent distinct objects. Then fit each of those into a convolutional neural network which was basically designed to figure out if that is the kind of object we are interested in.</li><li name="9e50" id="9e50" class="graf graf--li graf-after--li">R-CNN and Fast R-CNN are hybrid of traditional computer vision and deep learning.</li><li name="3b77" id="3b77" class="graf graf--li graf-after--li">What Ross and his team then did was they took the multibox idea and replaced the traditional non-deep learning computer vision part of their two stage process with the conv net. So now they have two conv nets: one for region proposals (all of the things that might be objects) and the second part was the same as his earlier work.</li></ul><p name="9a15" id="9a15" class="graf graf--p graf-after--li"><a href="https://arxiv.org/abs/1506.02640" data-href="https://arxiv.org/abs/1506.02640" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">You Only Look Once: Unified, Real-Time Object Detection</a></p><p name="cb78" id="cb78" class="graf graf--p graf-after--p"><a href="https://arxiv.org/abs/1512.02325" data-href="https://arxiv.org/abs/1512.02325" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">SSD: Single Shot MultiBox Detector</a></p><ul class="postList"><li name="9e7d" id="9e7d" class="graf graf--li graf-after--p">At similar time these paper came out. Both of these did something pretty cool which is they achieved similar performance as the Faster R-CNN but with 1 stage.</li><li name="ea38" id="ea38" class="graf graf--li graf-after--li">They took the multibox idea and they tried to figure out how to deal with messy outputs. The basic ideas were to use, for example, hard negative mining where they would go through and find all of the matches that did not look that good and throw them away, use very tricky and complex data augmentation methods, and all kind of hackery. But they got them to work pretty well.</li></ul><p name="a3f4" id="a3f4" class="graf graf--p graf-after--li"><a href="https://arxiv.org/abs/1708.02002" data-href="https://arxiv.org/abs/1708.02002" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Focal Loss for Dense Object Detection</a> (RetinaNet)</p><ul class="postList"><li name="e6d1" id="e6d1" class="graf graf--li graf-after--p">Then something really cool happened late last year which is this thing called focal loss.</li><li name="883d" id="883d" class="graf graf--li graf-after--li">They actually realized why this messy thing wasn’t working. When we look at an image, there are 3 different granularities of convolutional grid (4x4, 2x2, 1x1) [<a href="https://youtu.be/0frKXR-2PBY?t=1h37m28s" data-href="https://youtu.be/0frKXR-2PBY?t=1h37m28s" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">1:37:28</a>]. The 1x1 is quite likely to have a reasonable overlap with some object because most photos have some kind of main subject. On the other hand, in the 4x4 grid cells, the most of 16 anchor boxes are not going to have a much of an overlap with anything. So if somebody was to say to you “$20 bet, what do you reckon this little clip is?” and you are not sure, you will say “background” because most of the time, it is the background.</li></ul><p name="05da" id="05da" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Question</strong>: I understand why we have a 4x4 grid of receptive fields with 1 anchor box each to coarsely localize objects in the image. But what I think I’m missing is why we need multiple receptive fields at different sizes. The first version already included 16 receptive fields, each with a single anchor box associated. With the additions, there are now many more anchor boxes to consider. Is this because you constrained how much a receptive field could move or scale from its original size? Or is there another reason? [<a href="https://youtu.be/0frKXR-2PBY?t=1h38m47s" data-href="https://youtu.be/0frKXR-2PBY?t=1h38m47s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:38:47</a>] It is kind of backwards. The reason Jeremy did the constraining was because he knew he was going to be adding more boxes later. But really, the reason is that the Jaccard overlap between one of those 4x4 grid cells and a picture where a single object that takes up most of the image is never going to be 0.5. The intersection is much smaller than the union because the object is too big. So for this general idea to work where we are saying you are responsible for something that you have better than 50% overlap with, we need anchor boxes which will on a regular basis have a 50% or higher overlap which means we need to have a variety of sizes, shapes, and scales. This all happens in the loss function. The vast majority of the interesting stuff in all of the object detection is the loss function.</p><h4 name="bfb0" id="bfb0" class="graf graf--h4 graf-after--p">Focal Loss [<a href="https://youtu.be/0frKXR-2PBY?t=1h40m38s" data-href="https://youtu.be/0frKXR-2PBY?t=1h40m38s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">1:40:38</a>]</h4><figure name="aa98" id="aa98" class="graf graf--figure graf-after--h4"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_6Bood7G6dUuhigy9cxkZ-Q.png"></figure><p name="7caf" id="7caf" class="graf graf--p graf-after--figure">The key thing is this very first picture. The blue line is the binary cross entropy loss. If the answer is not a motorbike [<a href="https://youtu.be/0frKXR-2PBY?t=1h41m46s" data-href="https://youtu.be/0frKXR-2PBY?t=1h41m46s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:41:46</a>], and I said “I think it’s not a motorbike and I am 60% sure” with the blue line, the loss is still about 0.5 which is pretty bad. So if we want to get our loss down, then for all these things which are actually back ground, we have to be saying “I am sure that is background”, “I am sure it’s not a motorbike, or a bus, or a person” — because if I don’t say we are sure it is not any of these things, then we still get loss.</p><p name="75ba" id="75ba" class="graf graf--p graf-after--p">That is why the motorbike example did not work [<a href="https://youtu.be/0frKXR-2PBY?t=1h42m39s" data-href="https://youtu.be/0frKXR-2PBY?t=1h42m39s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:42:39</a>]. Because even when it gets to lower right corner and it wants to say “I think it’s a motorbike”, there is no payoff for it to say so. If it is wrong, it gets killed. And the vast majority of the time, it is background. Even if it is not background, it is not enough just to say “it’s not background” — you have to say which of the 20 things it is.</p><p name="0405" id="0405" class="graf graf--p graf-after--p">So the trick is to trying to find a different loss function [<a href="https://youtu.be/0frKXR-2PBY?t=1h44m" data-href="https://youtu.be/0frKXR-2PBY?t=1h44m" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:44:00</a>] that looks more like the purple line. Focal loss is literally just a scaled cross entropy loss. Now if we say “I’m&nbsp;.6 sure it’s not a motorbike” then the loss function will say “good for you! no worries” [<a href="https://youtu.be/0frKXR-2PBY?t=1h44m42s" data-href="https://youtu.be/0frKXR-2PBY?t=1h44m42s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:44:42</a>].</p><p name="e20f" id="e20f" class="graf graf--p graf-after--p">The actual contribution of this paper is to add <code class="markup--code markup--p-code">(1 − pt)^γ</code> to the start of the equation [<a href="https://youtu.be/0frKXR-2PBY?t=1h45m6s" data-href="https://youtu.be/0frKXR-2PBY?t=1h45m6s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:45:06</a>] which sounds like nothing but actually people have been trying to figure out this problem for years. When you come across a paper like this which is game-changing, you shouldn’t assume you are going to have to write thousands of lines of code. Very often it is one line of code, or the change of a single constant, or adding log to a single place.</p><p name="3d32" id="3d32" class="graf graf--p graf-after--p">A couple of terrific things about this paper [<a href="https://youtu.be/0frKXR-2PBY?t=1h46m8s" data-href="https://youtu.be/0frKXR-2PBY?t=1h46m8s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:46:08</a>]:</p><ul class="postList"><li name="4dce" id="4dce" class="graf graf--li graf-after--p">Equations are written in a simple manner</li><li name="b4f3" id="b4f3" class="graf graf--li graf-after--li">They “refactor”</li></ul><h4 name="021e" id="021e" class="graf graf--h4 graf-after--li">Implementing Focal Loss [<a href="https://youtu.be/0frKXR-2PBY?t=1h49m27s" data-href="https://youtu.be/0frKXR-2PBY?t=1h49m27s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">1:49:27</a>]:</h4><figure name="a6b9" id="a6b9" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*wIp0HYEWPnkiuxLeCfEiAg.png" data-width="429" data-height="36" src="../img/1_wIp0HYEWPnkiuxLeCfEiAg.png"></figure><p name="0a90" id="0a90" class="graf graf--p graf-after--figure">Remember, -log(pt) is the cross entropy loss and focal loss is just a scaled version. When we defined the binomial cross entropy loss, you may have noticed that there was a weight which by default was none:</p><pre name="2c64" id="2c64" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">class</strong> <strong class="markup--strong markup--pre-strong">BCE_Loss</strong>(nn.Module):<br>    <strong class="markup--strong markup--pre-strong">def</strong> __init__(self, num_classes):<br>        super().__init__()<br>        self.num_classes = num_classes<br><br>    <strong class="markup--strong markup--pre-strong">def</strong> forward(self, pred, targ):<br>        t = one_hot_embedding(targ, self.num_classes+1)<br>        t = V(t[:,:-1].contiguous())<em class="markup--em markup--pre-em">#.cpu()</em><br>        x = pred[:,:-1]<br>        w = self.get_weight(x,t)<br>        <strong class="markup--strong markup--pre-strong">return</strong> F.binary_cross_entropy_with_logits(x, t, w, <br>                          size_average=<strong class="markup--strong markup--pre-strong">False</strong>)/self.num_classes<br>    <br>    <strong class="markup--strong markup--pre-strong">def</strong> get_weight(self,x,t): <strong class="markup--strong markup--pre-strong">return</strong> <strong class="markup--strong markup--pre-strong">None</strong></pre><p name="0e89" id="0e89" class="graf graf--p graf-after--pre">When you call <code class="markup--code markup--p-code">F.binary_cross_entropy_with_logits</code>, you can pass in the weight. Since we just wanted to multiply a cross entropy by something, we can just define <code class="markup--code markup--p-code">get_weight</code>. Here is the entirety of focal loss [<a href="https://youtu.be/0frKXR-2PBY?t=1h50m23s" data-href="https://youtu.be/0frKXR-2PBY?t=1h50m23s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:50:23</a>]:</p><pre name="1cbf" id="1cbf" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">class</strong> <strong class="markup--strong markup--pre-strong">FocalLoss</strong>(BCE_Loss):<br>    <strong class="markup--strong markup--pre-strong">def</strong> get_weight(self,x,t):<br>        alpha,gamma = 0.25,2.<br>        p = x.sigmoid()<br>        pt = p*t + (1-p)*(1-t)<br>        w = alpha*t + (1-alpha)*(1-t)<br>        <strong class="markup--strong markup--pre-strong">return</strong> w * (1-pt).pow(gamma)</pre><p name="9651" id="9651" class="graf graf--p graf-after--pre">If you were wondering why alpha and gamma are 0.25 and 2, here is another excellent thing about this paper, because they tried lots of different values and found that these work well:</p><figure name="9bed" id="9bed" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_qFPRvFHQMQplSJGp3QLiNA.png"></figure><h4 name="6ed2" id="6ed2" class="graf graf--h4 graf-after--figure">Training [<a href="https://youtu.be/0frKXR-2PBY?t=1h51m25s" data-href="https://youtu.be/0frKXR-2PBY?t=1h51m25s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">1:51:25</a>]</h4><pre name="ebda" id="ebda" class="graf graf--pre graf-after--h4">learn.lr_find(lrs/1000,1.)<br>learn.sched.plot(n_skip_end=2)</pre><figure name="5e64" id="5e64" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_lQPSR3V2IXbxOpcgNE-U-Q.png"></figure><pre name="cf7e" id="cf7e" class="graf graf--pre graf-after--figure">learn.fit(lrs, 1, cycle_len=10, use_clr=(20,10))</pre><pre name="a909" id="a909" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">epoch      trn_loss   val_loss                            <br>    0      24.263046  28.975235 <br>    1      20.459562  16.362392                           <br>    2      17.880827  14.884829                           <br>    3      15.956896  13.676485                           <br>    4      14.521345  13.134197                           <br>    5      13.460941  12.594139                           <br>    6      12.651842  12.069849                           <br>    7      11.944972  11.956457                           <br>    8      11.385798  11.561226                           <br>    9      10.988802  11.362164</em></pre><pre name="f3db" id="f3db" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">[11.362164]</em></pre><pre name="08b0" id="08b0" class="graf graf--pre graf-after--pre">learn.save('fl0')<br>learn.load('fl0')</pre><pre name="5836" id="5836" class="graf graf--pre graf-after--pre">learn.freeze_to(-2)<br>learn.fit(lrs/4, 1, cycle_len=10, use_clr=(20,10))</pre><pre name="911e" id="911e" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">epoch      trn_loss   val_loss                            <br>    0      10.871668  11.615532 <br>    1      10.908461  11.604334                           <br>    2      10.549796  11.486127                           <br>    3      10.130961  11.088478                           <br>    4      9.70691    10.72144                            <br>    5      9.319202   10.600481                           <br>    6      8.916653   10.358334                           <br>    7      8.579452   10.624706                           <br>    8      8.274838   10.163422                           <br>    9      7.994316   10.108068</em></pre><pre name="44c8" id="44c8" class="graf graf--pre graf-after--pre"><em class="markup--em markup--pre-em">[10.108068]</em></pre><pre name="268f" id="268f" class="graf graf--pre graf-after--pre">learn.save('drop4')<br>learn.load('drop4')</pre><pre name="eed6" id="eed6" class="graf graf--pre graf-after--pre">plot_results(0.75)</pre><figure name="3481" id="3481" class="graf graf--figure graf-after--pre"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_G4HCc1mpkvHFqbhrb5Uwpw.png"></figure><p name="bc8c" id="bc8c" class="graf graf--p graf-after--figure">This time things are looking quite a bit better. So our last step, for now, is to basically figure out how to pull out just the interesting ones.</p><h4 name="dc8a" id="dc8a" class="graf graf--h4 graf-after--p">Non Maximum Suppression [<a href="https://youtu.be/0frKXR-2PBY?t=1h52m15s" data-href="https://youtu.be/0frKXR-2PBY?t=1h52m15s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">1:52:15</a>]</h4><p name="f1db" id="f1db" class="graf graf--p graf-after--h4">All we are going to do is we are going to go through every pair of these bounding boxes and if they overlap by more than some amount, say 0.5, using Jaccard and they are both predicting the same class, we are going to assume they are the same thing and we are going to pick the one with higher <code class="markup--code markup--p-code">p</code> value.</p><p name="6313" id="6313" class="graf graf--p graf-after--p">It is really boring code, Jeremy didn’t write it himself and copied somebody else’s. No reason particularly to go through it.</p><pre name="1f12" id="1f12" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">def</strong> nms(boxes, scores, overlap=0.5, top_k=100):<br>    keep = scores.new(scores.size(0)).zero_().long()<br>    <strong class="markup--strong markup--pre-strong">if</strong> boxes.numel() == 0: <strong class="markup--strong markup--pre-strong">return</strong> keep<br>    x1 = boxes[:, 0]<br>    y1 = boxes[:, 1]<br>    x2 = boxes[:, 2]<br>    y2 = boxes[:, 3]<br>    area = torch.mul(x2 - x1, y2 - y1)<br>    v, idx = scores.sort(0)  <em class="markup--em markup--pre-em"># sort in ascending order</em><br>    idx = idx[-top_k:]  <em class="markup--em markup--pre-em"># indices of the top-k largest vals</em><br>    xx1 = boxes.new()<br>    yy1 = boxes.new()<br>    xx2 = boxes.new()<br>    yy2 = boxes.new()<br>    w = boxes.new()<br>    h = boxes.new()<br><br>    count = 0<br>    <strong class="markup--strong markup--pre-strong">while</strong> idx.numel() &gt; 0:<br>        i = idx[-1]  <em class="markup--em markup--pre-em"># index of current largest val</em><br>        keep[count] = i<br>        count += 1<br>        <strong class="markup--strong markup--pre-strong">if</strong> idx.size(0) == 1: <strong class="markup--strong markup--pre-strong">break</strong><br>        idx = idx[:-1]  <em class="markup--em markup--pre-em"># remove kept element from view</em><br>        <em class="markup--em markup--pre-em"># load bboxes of next highest vals</em><br>        torch.index_select(x1, 0, idx, out=xx1)<br>        torch.index_select(y1, 0, idx, out=yy1)<br>        torch.index_select(x2, 0, idx, out=xx2)<br>        torch.index_select(y2, 0, idx, out=yy2)<br>        <em class="markup--em markup--pre-em"># store element-wise max with next highest score</em><br>        xx1 = torch.clamp(xx1, min=x1[i])<br>        yy1 = torch.clamp(yy1, min=y1[i])<br>        xx2 = torch.clamp(xx2, max=x2[i])<br>        yy2 = torch.clamp(yy2, max=y2[i])<br>        w.resize_as_(xx2)<br>        h.resize_as_(yy2)<br>        w = xx2 - xx1<br>        h = yy2 - yy1<br>        <em class="markup--em markup--pre-em"># check sizes of xx1 and xx2.. after each iteration</em><br>        w = torch.clamp(w, min=0.0)<br>        h = torch.clamp(h, min=0.0)<br>        inter = w*h<br>        <em class="markup--em markup--pre-em"># IoU = i / (area(a) + area(b) - i)</em><br>        rem_areas = torch.index_select(area, 0, idx)  <br>        <em class="markup--em markup--pre-em"># load remaining areas)</em><br>        union = (rem_areas - inter) + area[i]<br>        IoU = inter/union  <em class="markup--em markup--pre-em"># store result in iou</em><br>        <em class="markup--em markup--pre-em"># keep only elements with an IoU &lt;= overlap</em><br>        idx = idx[IoU.le(overlap)]<br>    <strong class="markup--strong markup--pre-strong">return</strong> keep, count</pre><pre name="6e66" id="6e66" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">def</strong> show_nmf(idx):<br>    ima=md.val_ds.ds.denorm(x)[idx]<br>    bbox,clas = get_y(y[0][idx], y[1][idx])<br>    a_ic = actn_to_bb(b_bb[idx], anchors)<br>    clas_pr, clas_ids = b_clas[idx].max(1)<br>    clas_pr = clas_pr.sigmoid()<br><br>    conf_scores = b_clas[idx].sigmoid().t().data<br><br>    out1,out2,cc = [],[],[]<br>    <strong class="markup--strong markup--pre-strong">for</strong> cl <strong class="markup--strong markup--pre-strong">in</strong> range(0, len(conf_scores)-1):<br>        c_mask = conf_scores[cl] &gt; 0.25<br>        <strong class="markup--strong markup--pre-strong">if</strong> c_mask.sum() == 0: <strong class="markup--strong markup--pre-strong">continue</strong><br>        scores = conf_scores[cl][c_mask]<br>        l_mask = c_mask.unsqueeze(1).expand_as(a_ic)<br>        boxes = a_ic[l_mask].view(-1, 4)<br>        ids, count = nms(boxes.data, scores, 0.4, 50)<br>        ids = ids[:count]<br>        out1.append(scores[ids])<br>        out2.append(boxes.data[ids])<br>        cc.append([cl]*count)<br>    cc = T(np.concatenate(cc))<br>    out1 = torch.cat(out1)<br>    out2 = torch.cat(out2)<br><br>    fig, ax = plt.subplots(figsize=(8,8))<br>    torch_gt(ax, ima, out2, cc, out1, 0.1)</pre><pre name="26af" id="26af" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">for</strong> i <strong class="markup--strong markup--pre-strong">in</strong> range(12): show_nmf(i)</pre><figure name="fc05" id="fc05" class="graf graf--figure graf--layoutOutsetCenter graf-after--pre" data-scroll="native"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_MXk2chJJEcjOz8hMn1ZsOQ.png"></figure><figure name="d53d" id="d53d" class="graf graf--figure graf--layoutOutsetCenter graf-after--figure" data-scroll="native"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_Fj9fK3G6iXBsGI_XJrxXyg.png"></figure><figure name="2958" id="2958" class="graf graf--figure graf--layoutOutsetCenter graf-after--figure" data-scroll="native"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_6p3dm-i-YxC9QkxouHJdoA.png"></figure><figure name="75fa" id="75fa" class="graf graf--figure graf--layoutOutsetCenter graf-after--figure" data-scroll="native"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_nkEpAd2_H4lG1vQfnCJn4Q.png"></figure><figure name="cbef" id="cbef" class="graf graf--figure graf--layoutOutsetCenter graf-after--figure" data-scroll="native"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_THGq5C21NaP92vw5E_QNdA.png"></figure><figure name="b2b2" id="b2b2" class="graf graf--figure graf--layoutOutsetCenter graf-after--figure" data-scroll="native"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_0wckbiUSax2JpBlgJxJ05g.png"></figure><figure name="a1f1" id="a1f1" class="graf graf--figure graf--layoutOutsetCenter graf-after--figure" data-scroll="native"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_EWbNGEQFvYMgC4PSaLe8Ww.png"></figure><figure name="5cba" id="5cba" class="graf graf--figure graf--layoutOutsetCenter graf-after--figure" data-scroll="native"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_vTRCVjln4vkma1R6eBeSwA.png"></figure><figure name="4351" id="4351" class="graf graf--figure graf--layoutOutsetCenter graf-after--figure" data-scroll="native"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_3Q01FZuzfptkYrekJiGm1g.png"></figure><figure name="b40b" id="b40b" class="graf graf--figure graf--layoutOutsetCenter graf-after--figure" data-scroll="native"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_-cD3LQIG9FnyJbt0cnpbNg.png"></figure><figure name="ead3" id="ead3" class="graf graf--figure graf--layoutOutsetCenter graf-after--figure" data-scroll="native"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_Hkgs1u9PFH9ZrTKL8YBW2Q.png"></figure><figure name="bb83" id="bb83" class="graf graf--figure graf--layoutOutsetCenter graf-after--figure" data-scroll="native"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="../img/1_uyTNlp61jcyaW9knbnNSEw.png"></figure><p name="55b5" id="55b5" class="graf graf--p graf-after--figure">There are some things still to fix here [<a href="https://youtu.be/0frKXR-2PBY?t=1h53m43s" data-href="https://youtu.be/0frKXR-2PBY?t=1h53m43s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:53:43</a>]. The trick will be to use something called feature pyramid. That is what we are going to do in lesson 14.</p><h4 name="5eed" id="5eed" class="graf graf--h4 graf-after--p">Talking a little more about SSD paper [<a href="https://youtu.be/0frKXR-2PBY?t=1h54m3s" data-href="https://youtu.be/0frKXR-2PBY?t=1h54m3s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">1:54:03</a>]</h4><p name="b19e" id="b19e" class="graf graf--p graf-after--h4">When this paper came out, Jeremy was excited because this and YOLO were the first kind of single-pass good quality object detection method that come along. There has been this continuous repetition of history in the deep learning world which is things that involve multiple passes of multiple different pieces, over time, particularly where they involve some non-deep learning pieces (like R-CNN did), over time, they always get turned into a single end-to-end deep learning model. So I tend to ignore them until that happens because that’s the point where people have figured out how to show this as a deep learning model, as soon as they do that they generally end up something much faster and much more accurate. So SSD and YOLO were really important.</p><p name="0629" id="0629" class="graf graf--p graf-after--p">The model is 4 paragraphs. Papers are really concise which means you need to read them pretty carefully. Partly, though, you need to know which bits to read carefully. The bits where they say “here we are going to prove the error bounds on this model,” you could ignore that because you don’t care about proving error bounds. But the bit which says here is what the model is, you need to read real carefully.</p><p name="18c6" id="18c6" class="graf graf--p graf-after--p">Jeremy reads a section <strong class="markup--strong markup--p-strong">2.1 Model</strong> [<a href="https://youtu.be/0frKXR-2PBY?t=1h56m37s" data-href="https://youtu.be/0frKXR-2PBY?t=1h56m37s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">1:56:37</a>]</p><p name="1d2d" id="1d2d" class="graf graf--p graf-after--p">If you jump straight in and read a paper like this, these 4 paragraphs would probably make no sense. But now that we’ve gone through it, you read those and hopefully thinking “oh that’s just what Jeremy said, only they sad it better than Jeremy and less words [<a href="https://youtu.be/0frKXR-2PBY?t=2h37s" data-href="https://youtu.be/0frKXR-2PBY?t=2h37s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">2:00:37</a>]. If you start to read a paper and go “what the heck”, the trick is to then start reading back over the citations.</p><p name="9414" id="9414" class="graf graf--p graf-after--p">Jeremy reads <strong class="markup--strong markup--p-strong">Matching strategy</strong> and <strong class="markup--strong markup--p-strong">Training objective</strong> (a.k.a. Loss function)[<a href="https://youtu.be/0frKXR-2PBY?t=2h1m44s" data-href="https://youtu.be/0frKXR-2PBY?t=2h1m44s" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">2:01:44</a>]</p><h4 name="11d8" id="11d8" class="graf graf--h4 graf-after--p">Some paper tips [<a href="https://youtu.be/0frKXR-2PBY?t=2h2m34s" data-href="https://youtu.be/0frKXR-2PBY?t=2h2m34s" class="markup--anchor markup--h4-anchor" rel="nofollow noopener" target="_blank">2:02:34</a>]</h4><p name="6731" id="6731" class="graf graf--p graf-after--h4"><a href="https://arxiv.org/pdf/1312.2249.pdf" data-href="https://arxiv.org/pdf/1312.2249.pdf" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Scalable Object Detection using Deep Neural Networks</a></p><ul class="postList"><li name="20f5" id="20f5" class="graf graf--li graf--startsWithDoubleQuote graf-after--p">“Training objective” is loss function</li><li name="1d70" id="1d70" class="graf graf--li graf-after--li">Double bars and two 2’s like this means Mean Squared Error</li></ul><figure name="4909" id="4909" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*LubBtX9ODFMBgI34bFHtdw.png" data-width="446" data-height="73" src="../img/1_LubBtX9ODFMBgI34bFHtdw.png"></figure><ul class="postList"><li name="72d3" id="72d3" class="graf graf--li graf-after--figure">log(c) and log(1-c), and x and (1-x) they are all the pieces for binary cross entropy:</li></ul><figure name="ba87" id="ba87" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*3Xq3HB72jsVKI7uHOHzRDQ.png" data-width="562" data-height="86" src="../img/1_3Xq3HB72jsVKI7uHOHzRDQ.png"></figure><p name="2118" id="2118" class="graf graf--p graf-after--figure graf--trailing">This week, go through the code and go through the paper and see what is going on. Remember what Jeremy did to make it easier for you was he took that loss function, he copied it into a cell and split it up so that each bit was in a separate cell. Then after every sell, he printed or plotted that value. Hopefully this is a good starting point.</p><hr class="section-divider"><p name="27d5" id="27d5" class="graf graf--p graf--leading graf--trailing">Lessons: <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-1-602f73869197" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-1-602f73869197" class="markup--anchor markup--p-anchor" target="_blank">1</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-2-eeae2edd2be4" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-2-eeae2edd2be4" class="markup--anchor markup--p-anchor" target="_blank">2</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-3-74b0ef79e56" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-3-74b0ef79e56" class="markup--anchor markup--p-anchor" target="_blank">3</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-4-2048a26d58aa" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-4-2048a26d58aa" class="markup--anchor markup--p-anchor" target="_blank">4</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-5-dd904506bee8" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-5-dd904506bee8" class="markup--anchor markup--p-anchor" target="_blank">5</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-6-de70d626976c" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-6-de70d626976c" class="markup--anchor markup--p-anchor" target="_blank">6</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-7-1b9503aff0c" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-1-lesson-7-1b9503aff0c" class="markup--anchor markup--p-anchor" target="_blank">7</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-8-5ae195c49493" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-8-5ae195c49493" class="markup--anchor markup--p-anchor" target="_blank">8</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-9-5f0cf9e4bb5b" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-9-5f0cf9e4bb5b" class="markup--anchor markup--p-anchor" target="_blank"><strong class="markup--strong markup--p-strong">9</strong></a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-10-422d87c3340c" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-10-422d87c3340c" class="markup--anchor markup--p-anchor" target="_blank">10</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-11-61477d24dc34" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-11-61477d24dc34" class="markup--anchor markup--p-anchor" target="_blank">11</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-12-215dfbf04a94" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-12-215dfbf04a94" class="markup--anchor markup--p-anchor" target="_blank">12</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-13-43454b21a5d0" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-13-43454b21a5d0" class="markup--anchor markup--p-anchor" target="_blank">13</a> ・ <a href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-14-e0d23c7a0add" data-href="https://medium.com/@hiromi_suenaga/deep-learning-2-part-2-lesson-14-e0d23c7a0add" class="markup--anchor markup--p-anchor" target="_blank">14</a></p></body></html>